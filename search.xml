<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JQuery学习笔记</title>
      <link href="/2020/01/25/jquery-xue-xi-bi-ji/"/>
      <url>/2020/01/25/jquery-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><hr><h3 id="1-js写法"><a href="#1-js写法" class="headerlink" title="1.js写法"></a>1.js写法</h3><pre><code>&lt;script&gt;    // 这个js的写法    window.onload = function () {        var btn = document.getElementById(&quot;btn&quot;);        var box = document.getElementById(&quot;box&quot;);        btn.onclick = function () {            box.style.display = &quot;none&quot;; // 赋值加&quot;&quot;        }    }&lt;/script&gt;</code></pre><hr><h3 id="2-js和jQuery写法对比"><a href="#2-js和jQuery写法对比" class="headerlink" title="2.js和jQuery写法对比"></a>2.js和jQuery写法对比</h3><pre><code>&lt;script&gt;    // js：    Window.onload = function () {}    // jQuery:    $(function () {});&lt;/script&gt;</code></pre><h3 id="3-jQuery写法先引入包-不加on"><a href="#3-jQuery写法先引入包-不加on" class="headerlink" title="3.jQuery写法先引入包((不加on))"></a>3.jQuery写法先引入包((不加on))</h3><pre><code>&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;button&quot;).click(function () {            // $(&quot;div&quot;).hide();            $(&quot;div&quot;).hide(1000); // 写得少，做得多,效果更好.        })    })    // 注意：hide(1000)里面加毫秒，动画效果&lt;/script&gt;&lt;script src=&quot;jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;</code></pre><hr><h3 id="4-基本动画效果-展开和收起动画"><a href="#4-基本动画效果-展开和收起动画" class="headerlink" title="4.基本动画效果(展开和收起动画)"></a>4.基本动画效果(展开和收起动画)</h3><pre><code>&lt;p&gt;    &lt;button id=&quot;xs&quot;&gt;显示&lt;/button&gt;    &lt;button id=&quot;yc&quot;&gt;隐藏&lt;/button&gt;&lt;/p&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    // 1. show（）; 把隐藏的显示    // 2. hide（）； 把显示的隐藏    // 3. toggle（）； 切换显示和隐藏    // 4. slideUp（）； 上滑    // 5. slideDown（）； 下滑    // 6. slideToggle（）； 切换滑动    // 案例：    $(function () {        $(&#39;#xs&#39;).click(function () {            $(&#39;#box&#39;).show(1000);        });        $(&#39;#yc&#39;).click(function () {            $(&#39;#box&#39;).hide(1000);        });    });&lt;/script&gt;</code></pre><hr><h3 id="5-jQuery转换js对象"><a href="#5-jQuery转换js对象" class="headerlink" title="5.jQuery转换js对象"></a>5.jQuery转换js对象</h3><pre><code>&lt;div id=&quot;demo&quot;&gt;认识一下大家&lt;/div&gt;&lt;script&gt;    // 1.[0]    // 2. get(0) // 注意是括号    // 案例： jq转换js对象， 调用js方法    alert($(&#39;#demo&#39;)[0].innerHTML); // jq转换js对象    alert($(&quot;#demo&quot;).get(0).innerHTML); // 这样也可以,JQ对象转换为了DOM对象    // 这个是JQ获取文字内容的写法:    alert($(&quot;#demo&quot;).html());    // 这个是JQ获取纯文本:    alert($(&quot;#demo&quot;).text());    // 这个是JQ获取表单值:    alert($(&quot;#demo&quot;).val());&lt;/script&gt;</code></pre><hr><h3 id="6-js对象转换成jQuery对象"><a href="#6-js对象转换成jQuery对象" class="headerlink" title="6.js对象转换成jQuery对象"></a>6.js对象转换成jQuery对象</h3><pre><code>&lt;!-- 案例： --&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;btn&quot;&gt;&lt;script&gt;    window.onload = function () {        // DOM对象调用jQuery对象的方法。需要把DOM对象转换成jQuery对象。        var btn = document.getElementById(&quot;btn&quot;);        $(btn).click(function () { // 不用加字符串符号            console.log(&quot;哈哈，我又变帅了&quot;);        });    };&lt;/script&gt;</code></pre><hr><h3 id="7-jQuery操作DOM对象"><a href="#7-jQuery操作DOM对象" class="headerlink" title="7.jQuery操作DOM对象"></a>7.jQuery操作DOM对象</h3><pre><code>&lt;script&gt;    // 1. html() 2. text() 3. val()    // 案例：    $(function () {        $(&quot;button&quot;).click(function () {            console.log($(&quot;div&quot;).html()); // 获取结果&lt;span&gt;我是文字&lt;/span&gt;            console.log($(&quot;div&quot;).text()); // 获取真正的文字            console.log($(&quot;input&quot;).val()); // 获取表单值，你填写什么就获取什么        });    });&lt;/script&gt;</code></pre><hr><h3 id="8-jQuery操作CSS样式"><a href="#8-jQuery操作CSS样式" class="headerlink" title="8.jQuery操作CSS样式"></a>8.jQuery操作CSS样式</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        background-color: deeppink;    }&lt;/style&gt;&lt;button&gt;点击&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // 1. css里面只有一个属性的写法:css(“width”);---返回该属性的值；    // 2. css里面有一对属性值:css（“width”,”300px”）;---改变该属性的值；    // 3. 如果css里面有多组属性值:css（{“width”：“300px”，“height”：“300px”}）;---改变多组属性值；    // 案例：        $(function () {        $(&quot;button&quot;).click(function () {            // console.log($(&quot;div&quot;).css(&quot;width&quot;)); // css里面只有一个属性---返回该属性的值            // $(&quot;div&quot;).css(&quot;width&quot;,&quot;300px&quot;); // 有一对属性值---是改变该属性的值            $(&quot;div&quot;).css({                &quot;width&quot;: &quot;300px&quot;,                &quot;height&quot;: &quot;300px&quot;,                &quot;background-color&quot;: &quot;green&quot;            }); // 有多组属性值---改变多组属性值        });    });&lt;/script&gt;</code></pre><hr><h3 id="9-jQuery中的this自身、自己-this"><a href="#9-jQuery中的this自身、自己-this" class="headerlink" title="9.jQuery中的this自身、自己 $(this)"></a>9.jQuery中的this自身、自己 $(this)</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        background-color: pink;    }&lt;/style&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // jQuery代码：    // 注意：1.this可以看事件前面点，就代表那个对象 2.this不要加&quot;&quot;    $(function () {        $(&quot;div&quot;).mouseover(function () {            $(this).css(&quot;background-color&quot;, &quot;green&quot;); // this自身，自己        });        $(&quot;div&quot;).mouseout(function () {            $(this).css(&quot;background-color&quot;, &quot;pink&quot;);        });    });&lt;/script&gt;</code></pre><hr><h3 id="10-jQuery操作类"><a href="#10-jQuery操作类" class="headerlink" title="10.jQuery操作类"></a>10.jQuery操作类</h3><pre><code>    1. addClass()  添加新类（addClass(&quot;cls&quot;); addClass(&quot;cls&quot;)一定不能加点）;    2. removeClass() 移除类 removeClass(&quot;cls&quot;);    3. hasClass(’myClass’)    判断是否有类</code></pre><hr><h3 id="11-开关灯案例（操作类）"><a href="#11-开关灯案例（操作类）" class="headerlink" title="11.开关灯案例（操作类）"></a>11.开关灯案例（操作类）</h3><pre><code>&lt;style&gt;    .cls {        background-color: #000;    }&lt;/style&gt;&lt;input type=&quot;button&quot; value=&quot;开/关&quot; id=&quot;btn&quot; /&gt;&lt;script&gt;    // $(function() {    //         $(&quot;#btn&quot;).click(function() {    //             // 判断这个body有没有这个类    //             if ($(&quot;body&quot;)[0].className == &quot;cls&quot;) { //记得转换[0]或者get(0)    //                 $(&quot;body&quot;)[0].className = &quot;&quot;;    //             } else {    //                 $(&quot;body&quot;)[0].className = &quot;cls&quot;;    //             }    //         })    //     })    // 下面优化代码写法通过addClass()添加类、removeClass()移除类，hasClass()判断是否有这个类来实现(注意：cls前面不要加点)    $(function () {        $(&quot;#btn&quot;).click(function () {            // 判断            if ($(&quot;body&quot;).hasClass(&quot;cls&quot;)) {                $(&quot;body&quot;).removeClass(&quot;cls&quot;);            } else {                $(&quot;body&quot;).addClass(&quot;cls&quot;);            }        })    })&lt;/script&gt;</code></pre><hr><h3 id="12-开关灯更改样式案例"><a href="#12-开关灯更改样式案例" class="headerlink" title="12.开关灯更改样式案例"></a>12.开关灯更改样式案例</h3><pre><code>&lt;script&gt;    $(function () {        $(&quot;#btn&quot;).click(function () {            // 换个实现通过val值改变css样式来实现网页开关灯            if ($(this).val() == &quot;关灯&quot;) {                $(&quot;body&quot;).css(&quot;background-color&quot;, &quot;black&quot;);                $(this).val(&quot;开灯&quot;);            } else {                $(&quot;body&quot;).css(&quot;background-color&quot;, &quot;&quot;);                $(this).val(&quot;关灯&quot;);            }        });    })&lt;/script&gt;</code></pre><hr><h3 id="13-基本选择器"><a href="#13-基本选择器" class="headerlink" title="13.基本选择器"></a>13.基本选择器</h3><table><thead><tr><th align="center">名称</th><th align="center">用法</th><th align="center">描述</th><th align="center">参考实例</th></tr></thead><tbody><tr><td align="center">标签选择器</td><td align="center">$(“div”);</td><td align="center">获取同一类标签的所有元素</td><td align="center">$(“div”)或者$(“p”)</td></tr><tr><td align="center">ID选择器</td><td align="center">$(“#id”);</td><td align="center">获取指定ID的元素</td><td align="center">$(“#demo”)</td></tr><tr><td align="center">类选择器</td><td align="center">$(“.class”);</td><td align="center">获取同一类class的元素</td><td align="center">$(“.box”)</td></tr><tr><td align="center">通配符选择器</td><td align="center">$(“*”)</td><td align="center">匹配所有的元素，很少用</td><td align="center">$(“*”)</td></tr><tr><td align="center">并集选择器</td><td align="center">$(“.demo，.test”)</td><td align="center">使用逗号分隔，将每个复合条件的选择</td><td align="center">$(“.demo，.test”)</td></tr><tr><td align="center">后代选择器</td><td align="center">$(“li p”);</td><td align="center">后代选择器，子代和后代都会选择</td><td align="center">$(“li p”)</td></tr></tbody></table><hr><pre><code>&lt;script&gt;    // 案例:    $(function () {        $(&quot;button&quot;).click(function () {            $(&quot;.demo&quot;).css(&quot;background&quot;, &quot;pink&quot;);            // 获取类            $(&quot;.demo,.test&quot;).css(&quot;background&quot;, &quot;pink&quot;);            // 并集选择器            // 后代选择器            $(&quot;li p&quot;).css({                &quot;background&quot;: &quot;pink&quot;;            })        });    })&lt;/script&gt;</code></pre><hr><h3 id="14-层级选择器"><a href="#14-层级选择器" class="headerlink" title="14.层级选择器"></a>14.层级选择器</h3><table><thead><tr><th align="center">名称</th><th align="center">用法</th><th align="center">描述</th><th align="center">参考实例</th></tr></thead><tbody><tr><td align="center">子代选择器</td><td align="center">$(“li&gt;p”);</td><td align="center">获取儿子层级的元素，注意，并不会获取孙子层级的元素</td><td align="center">$(“li&gt;p”);</td></tr><tr><td align="center">紧邻选择器</td><td align="center">$(“.one+li”);</td><td align="center">选择one下面的第一个li</td><td align="center">$(“.one+li”)</td></tr><tr><td align="center">兄弟姐妹选择器</td><td align="center">$(“.one~li”)</td><td align="center">选择one下面的所有的li</td><td align="center">$(“.one~li”)</td></tr></tbody></table><hr><pre><code>&lt;!-- 案例： --&gt;&lt;button&gt;点击&lt;/button&gt;&lt;ul&gt;    &lt;li&gt;我是列表内容&lt;/li&gt;    &lt;li&gt;我是列表内容&lt;/li&gt;    &lt;li&gt;        &lt;p&gt;我是li的儿子标签&lt;/p&gt;        &lt;div&gt;            &lt;p&gt;我是li的孙子标签&lt;/p&gt;        &lt;/div&gt;    &lt;/li&gt;    &lt;li class=&quot;demo&quot;&gt;我是demo的类样式&lt;/li&gt;    &lt;li class=&quot;test&quot;&gt;我是test的类样式&lt;/li&gt;    &lt;li&gt;我是列表内容&lt;/li&gt;    &lt;li&gt;我是列表内容&lt;/li&gt;    &lt;li class=&quot;one&quot;&gt;我是列表内容&lt;/li&gt;    &lt;li&gt;我是one的第一个邻居&lt;/li&gt;    &lt;li&gt;我是列表内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // id选择器和标签前面一样    $(function () {        $(&quot;button&quot;).click(function () {            // $(&quot;.demo&quot;).css(&quot;background&quot;, &quot;pink&quot;); 获取类            // $(&quot;.demo,.test&quot;).css(&quot;background&quot;, &quot;pink&quot;);并集选择器            // 后代选择器            // $(&quot;li p&quot;).css({            //     &quot;background&quot;: &quot;pink&quot;            // })            // 以下叫做层级选择器            // $(&quot;li &gt; p&quot;).css(&quot;background&quot;, &quot;pink&quot;) //子代选择器，只选择儿子             // 紧邻选择器，向下选择第一个邻居            // $(&quot;.one + li&quot;).css(&quot;background&quot;, &quot;pink&quot;)            // 兄弟姐妹选择器，向下选择所有的邻居            $(&quot;.one~li&quot;).css(&quot;background&quot;, &quot;pink&quot;)        });    })&lt;/script&gt;</code></pre><hr><h3 id="15-过滤选择器"><a href="#15-过滤选择器" class="headerlink" title="15.过滤选择器"></a>15.过滤选择器</h3><table><thead><tr><th align="center">名称</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:first</td><td align="center">$(“li:first”)–选择第一个li</td><td align="center">选择满足条件的第一个元素</td></tr><tr><td align="center">:last</td><td align="center">$(“li:last”)—选择最后一个li</td><td align="center">选择满足条件的最后一个元素</td></tr><tr><td align="center">:even偶数</td><td align="center">$(“li:even”).css(“color”, ”red”);</td><td align="center">获取到的li元素中索引为奇数的元素，因为从0开始</td></tr><tr><td align="center">:odd奇数</td><td align="center">$(“li:odd”).css(“color”, ”red”);</td><td align="center">获取到的li元素中索引为偶数的元素，因为从0开始</td></tr><tr><td align="center">:eq（index）</td><td align="center">$(“li:eq(2)”).css(“color”, ”red”);</td><td align="center">获取到的li元素中第三个li元素，索引号index从0开始</td></tr></tbody></table><hr><pre><code>&lt;!-- 案例： --&gt;&lt;ul&gt;    &lt;li&gt;测试呼呼&lt;/li&gt;    &lt;li&gt;测试呼呼&lt;/li&gt;    &lt;li&gt;测试呼呼&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 注意:even偶数/odd奇数  是从下标0开始    $(function () {        $(&#39;li:first&#39;).css(&#39;color&#39;, &#39;blueviolet&#39;);        $(&#39;li:last&#39;).css(&#39;color&#39;, &#39;red&#39;);        $(&#39;li:even&#39;).css(&#39;color&#39;, &#39;blueviolet&#39;); // 偶数 是从下标0开始    })&lt;/script&gt;</code></pre><hr><h3 id="16-筛选选择器方法-函数"><a href="#16-筛选选择器方法-函数" class="headerlink" title="16.筛选选择器方法(函数)"></a>16.筛选选择器方法(函数)</h3><table><thead><tr><th align="center">名称</th><th align="center">用法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">eq(index)</td><td align="center">$(“li”).eq(2);</td><td align="center">选择第index个，从0开始</td></tr><tr><td align="center">parent()</td><td align="center">$(“li”).parent();</td><td align="center">查找父亲</td></tr><tr><td align="center">children()</td><td align="center">$(“li”).children(‘ul’);</td><td align="center">选择孩子或者空</td></tr><tr><td align="center">siblings()</td><td align="center">$(“.one”).siblings();</td><td align="center">选择兄弟，不分上下只要是兄弟，这个用的地方很多</td></tr></tbody></table><hr><pre><code>&lt;script&gt;    // 重点： hover() 方法使用：    $(&#39;#box&gt;ul&gt;li&#39;).hover(function () {        $(this).children(&#39;ul&#39;).stop().slideToggle();    });    // 案例：    $(function () {        $(&#39;li&#39;).eq(2).css(&#39;color&#39;, &#39;blueviolet&#39;); //选择第index个，从0开始        $(&#39;li&#39;).parent().css(&#39;color&#39;, &#39;red&#39;); //查找父亲        $(&#39;ul&#39;).children().css(&#39;color&#39;, &#39;green&#39;);        // 典型的排他思想，tab栏效果        $(&quot;.one&quot;).siblings().css(&quot;color&quot;, &quot;pink&quot;);    })&lt;/script&gt;</code></pre><hr><h3 id="17-下拉动画，stop-排队机制-（下拉菜单6种写法）案例："><a href="#17-下拉动画，stop-排队机制-（下拉菜单6种写法）案例：" class="headerlink" title="17.下拉动画，stop()排队机制 （下拉菜单6种写法）案例："></a>17.下拉动画，stop()排队机制 （下拉菜单6种写法）案例：</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    body {        font-size: 12px;        font-family: &quot;微软雅黑&quot;;        color: #fff;    }    #box {        width: 400px;        height: 30px;        margin: 100px auto;    }    #box ul li {        float: left;        width: 100px;        height: 30px;        text-align: center;        line-height: 30px;    }    #box ul li a {        display: block;        height: 30px;        background-color: #ccc;        color: #fff;        text-decoration: none;    }    #box ul li a:hover {        background-color: pink;    }    #box ul li ul {        display: none;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;代码学习&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 第一种写法：        $(&quot;#box&gt;ul&gt;li&quot;).mouseover(function () {            // alert(&quot;弹出&quot;);测试弹出效果，我们要的是demo里面的儿子li            $(this).children(&quot;ul&quot;).show();        });        $(&quot;#box&gt;ul&gt;li&quot;).mouseout(function () {            $(this).children(&quot;ul&quot;).hide();        });        // 第二种：链式操作:        $(&quot;#box&gt;ul&gt;li&quot;).mouseover(function () {            $(this).children(&quot;ul&quot;).show();        }).mouseout(function () {            $(this).children(&quot;ul&quot;).hide();        });        // 第三种写法mousemove和mouseleave一般会一起使用:        $(&quot;#box&gt;ul&gt;li&quot;).mousemove(function () {            $(this).children(&quot;ul&quot;).slideDown();        }).mouseleave(function () {            $(this).children(&quot;ul&quot;).slideUp();        });        // 第四种写法：        $(&quot;#box&gt;ul&gt;li&quot;).mousemove(function () {            $(this).children(&quot;ul&quot;).stop().slideDown();        }).mouseleave(function () {            $(this).children(&quot;ul&quot;).stop().slideUp();        });        // 第五种写法:        $(&quot;#box&gt;ul&gt;li&quot;).hover(function () {            $(this).children(&quot;ul&quot;).stop().slideDown();        }, function () {            $(this).children(&quot;ul&quot;).stop().slideUp();        });        // 第六种写法：        $(&quot;#box&gt;ul&gt;li&quot;).hover(function () {            $(this).children(&quot;ul&quot;).stop().slideToggle(); // 这个写法最优化，高薪        });    });&lt;/script&gt;</code></pre><hr><h3 id="18-tab动画切换案例"><a href="#18-tab动画切换案例" class="headerlink" title="18.tab动画切换案例"></a>18.tab动画切换案例</h3><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    .wrapper {        width: 1000px;        height: 475px;        margin: 0 auto;        margin-top: 100px;    }    .tab {        border: 1px solid #ddd;        border-bottom: 0;        height: 36px;        width: 320px;    }    .tab li {        position: relative;        float: left;        width: 80px;        height: 34px;        line-height: 34px;        text-align: center;        cursor: pointer;        border-top: 4px solid #fff;    }    .tab span {        position: absolute;        right: 0;        top: 10px;        background: #ddd;        width: 1px;        height: 14px;        overflow: hidden;    }    .products {        width: 1002px;        border: 1px solid #ddd;        height: 476px;    }    .products .main {        float: left;        display: none;    }    .products .main.selected {        display: block;    }    .tab li.active {        border-color: red;        border-bottom: 0;    }&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt;    &lt;ul class=&quot;tab&quot;&gt;        &lt;li class=&quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class=&quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class=&quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class=&quot;tab-item&quot;&gt;男士精品&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;products&quot;&gt;        &lt;div class=&quot;main selected&quot;&gt;            &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/guojidapai.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;main&quot;&gt;            &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/guozhuangmingpin.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;main&quot;&gt;            &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/qingjieyongpin.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;main&quot;&gt;            &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/nanshijingpin.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 引入js文件：    $(function () {        $(&#39;.tab-item&#39;).hover(function () {            // 添加当前class 将兄弟选择器删除class            $(this).addClass(&#39;active&#39;).siblings().removeClass(&#39;active&#39;);            // 另一个盒子            $(&#39;.main&#39;).eq($(this).index()).show().siblings().hide();        })    })&lt;/script&gt;&lt;script src=&quot;jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;table.js&quot;&gt;&lt;/script&gt;</code></pre><hr><h3 id="19-添加移除类的操作"><a href="#19-添加移除类的操作" class="headerlink" title="19.添加移除类的操作"></a>19.添加移除类的操作</h3><pre><code>&lt;style&gt;    .box {        width: 300px;        height: 300px;        background-color: pink;        border: 1px solid #000;    }    .box01 {        font-size: 30px;    }&lt;/style&gt;&lt;!-- 1.addClass() 添加类名   2.removeClass() 删除类名   3.toggleClass() 切换类名  4.hasClass(’myClass’)    判断是否有类 --&gt;&lt;!-- 案例： --&gt;&lt;button&gt;添加类&lt;/button&gt;&lt;button&gt;删除类&lt;/button&gt;&lt;button&gt;切换类&lt;/button&gt;&lt;button&gt;是否拥有box这个类&lt;/button&gt;&lt;div class=&quot;box01&quot;&gt;盒子&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;button&quot;).eq(0).click(function () {            $(&quot;div&quot;).addClass(&quot;box&quot;);        });        $(&quot;button&quot;).eq(1).click(function () {            $(&quot;div&quot;).removeClass(&quot;box&quot;);        });        $(&quot;button&quot;).eq(2).click(function () {            $(&quot;div&quot;).toggleClass(&quot;box&quot;);        });        $(&quot;button&quot;).eq(3).click(function () {            // 判断是否有这个类            if ($(&quot;div&quot;).hasClass(&quot;box&quot;)) {                alert(&quot;有这个类&quot;);            } else {                alert(&quot;没有这个类&quot;);            }        });    });&lt;/script&gt;</code></pre><hr><h3 id="20-淘宝精选服饰"><a href="#20-淘宝精选服饰" class="headerlink" title="20.淘宝精选服饰"></a>20.淘宝精选服饰</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    img {        display: block;    }    a {        color: #333;        text-decoration: none;        font-size: 12px;    }    .box {        width: 298px;        height: 250px;        border: 1px solid pink;        margin: 100px auto;        overflow: hidden;    }    #left,    #right,    #middle {        float: left;    }    #left li,    #right li {        height: 27px;        line-height: 27px;        text-align: center;        border-bottom: 1px solid pink;        background-color: #fcf2f1;    }    #left,    #right {        width: 48px;    }    #middle {        width: 200px;        border-left: 1px solid pink;        border-right: 1px solid pink;    }    #left a,    #right a {        display: block;        height: 27px;    }    #left a:hover,    #right a:hover {        background: url(&quot;images/abg.gif&quot;) repeat-x;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul id=&quot;left&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女靴&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;雪地靴&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;冬裙&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;呢大衣&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;毛衣&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;棉服&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女裤&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;羽绒服&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;牛仔裤&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;ul id=&quot;middle&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/雪地靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/冬裙.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/呢大衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/羽绒服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/牛仔裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/登山鞋.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮带.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/围巾.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot; /&gt;&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;ul id=&quot;right&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女包&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男包&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登山鞋&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮带&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;围巾&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮衣&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男毛衣&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男棉服&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男靴&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;#left li&quot;).mouseover(function () {            // alert($(this).index()); // 获取当前类的索引值            var num = $(this).index();            $(&quot;#middle li&quot;).eq(num).show().siblings().hide();        });        $(&quot;#right li&quot;).mouseover(function () {            num = $(this).index();            // alert(num);右面的num要加9因为不能从零开始和左面就会重复了            $(&quot;#middle li&quot;).eq(num + 9).show().siblings().hide();        });        // 第二种：遍历循环        $(&quot;#left li,#right li&quot;).each(function (index, el) {            $(this).mouseover(function () {                $(&quot;#middle li&quot;).eq(index).show().siblings().hide();            });        });    });&lt;/script&gt;</code></pre><hr><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-淡入和淡出动画"><a href="#1-淡入和淡出动画" class="headerlink" title="1.淡入和淡出动画"></a>1.淡入和淡出动画</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        background-color: pink;        display: none;    }&lt;/style&gt;&lt;!-- 案例： --&gt;&lt;button&gt;淡入&lt;/button&gt;&lt;button&gt;淡出&lt;/button&gt;&lt;button&gt;淡入淡出切换&lt;/button&gt;&lt;button&gt;透明度&lt;/button&gt;&lt;div&gt; &lt;/div&gt;&lt;script&gt;    fadeIn(speed， callBack); ///淡入动画    fadeOut(speed， callBack) //淡出动画    fadeToggle(speed, callBack) //切换动画    fadeTo(speed, opactity， callBack) //透明度,透明度的取值范围为0.0~1.0。    // 参数：        // speed参数：动画执行的速度，单位为毫秒。    // callBack参数：动画执行完毕的回调函数，可选    // opacity参数：指定的标签透明度（0.0~1.0）    $(function () {        $(&quot;button&quot;).eq(0).click(function () {            $(&quot;div&quot;).fadeIn(2000); //表示2秒钟         });        $(&quot;button&quot;).eq(1).click(function () {            $(&quot;div&quot;).fadeOut(2000);        });        $(&quot;button:eq(2)&quot;).click(function () {            $(&quot;div&quot;).fadeToggle(2000);        });        $(&quot;button:eq(3)&quot;).click(function () {            $(&quot;div&quot;).fadeTo(2000, 0.5); //2000毫秒，注意：透明度一定要写--规范        });    })&lt;/script&gt;</code></pre><hr><h3 id="2-唱戏页面-淡入-案例："><a href="#2-唱戏页面-淡入-案例：" class="headerlink" title="2.唱戏页面(淡入)案例："></a>2.唱戏页面(淡入)案例：</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    img {        display: block;    }    body {        background-color: #000;    }    .box {        width: 630px;        border: 1px solid #fff;        margin: 100px auto;        padding: 10px 0 0 10px;        overflow: hidden;    }    .box ul li {        float: left;        margin: 0 10px 10px 0;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;images/06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    // jQuery 代码:    $(function () {        $(&quot;.box li&quot;).hover(function () {            $(this).siblings().stop().fadeTo(800, 0.5); // 当前不变，兄弟变淡        }, function () {            $(&quot;li&quot;).stop().fadeTo(800, 1);        });    });&lt;/script&gt;</code></pre><hr><h3 id="3-自定义动画-左移动右移动"><a href="#3-自定义动画-左移动右移动" class="headerlink" title="3.自定义动画(左移动右移动)"></a>3.自定义动画(左移动右移动)</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        background-color: pink;        position: absolute;        top: 50px;        left: 50px;    }&lt;/style&gt;&lt;!-- 案例： --&gt;&lt;button&gt;animate跑&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // animate(params,speed,callBack)    // 1.第一个参数：    // params是一个对象。在该对象中以键值对的方式来要控制的属性样式和对应的值表示。    // 2.第二个参数：    // speed速度，可以是默认字符串中的某个（“slow” “normal” “fast”）或者是自定义的数字。    // 3.第三个参数：动画执行完毕后的回调函数是可选参数。    $(function () {        $(&quot;button&quot;).click(function () {            $(&quot;div&quot;)                .animate({                    &quot;left&quot;: &quot;500px&quot;                }, 1000)                .animate({                    &quot;left&quot;: &quot;500px&quot;,                    &quot;top&quot;: &quot;400px&quot;                }, 1000)                .animate({                    &quot;left&quot;: &quot;30px&quot;,                    &quot;top&quot;: &quot;400px&quot;                }, 1000)                .animate({                    &quot;left&quot;: &quot;30px&quot;,                    &quot;top&quot;: &quot;30px&quot;                }, 1000);        });    });&lt;/script&gt;</code></pre><hr><h3 id="4-延迟动画的语法-delay-speed"><a href="#4-延迟动画的语法-delay-speed" class="headerlink" title="4.延迟动画的语法(delay(speed);)"></a>4.延迟动画的语法(delay(speed);)</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        background-color: pink;        border: 1px solid #000;    }&lt;/style&gt;&lt;button&gt;走你&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 点击按钮，盒子边框，延迟一会再变高        $(&quot;button&quot;).click(function () {            // 盒子先变宽，等一秒钟后，盒子再变高            $(&quot;div&quot;).animate({                    &quot;width&quot;: &quot;500px&quot;                }, 1000),                $(&quot;div&quot;).delay(1000).animate({                    &quot;height&quot;: &quot;500px&quot;                }, 1000);        });    });&lt;/script&gt;</code></pre><hr><h3 id="5-京东页面凸出效果"><a href="#5-京东页面凸出效果" class="headerlink" title="5.京东页面凸出效果"></a>5.京东页面凸出效果</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    body {        font-size: 0;        /*用这个来解决图片下面5px的问题*/    }    .box {        width: 790px;        height: 361px;        margin: 100px auto;        background-color: #000;        overflow: hidden;    }    .shuang,    .dan {        width: 158px;        float: left;        overflow: hidden;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;shuang&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;dan&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;shuang&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;dan&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/06.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;shuang&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/07.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;        &lt;a href=&quot;#&quot; class=&quot;jd&quot;&gt;&lt;img src=&quot;images/08.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 练习each方法    $(function () {        $(&quot;.box .jd&quot;).each(function (index, ele) {            // index 索引             // ele元素            $(this).hover(function () {                $(&quot;.box .jd&quot;).stop().fadeTo(500, 0.5); // 所有的jd都变淡                $(this).stop().fadeTo(500, 1); // 自己变亮                $(this).children(&quot;img&quot;).stop().animate({                    &quot;marginLeft&quot;: &quot;-15px&quot;                }, 500);            }, function () {                $(&quot;.box .jd&quot;).stop().fadeTo(500, 1);                $(this).children(&quot;img&quot;).stop().animate({                    &quot;marginLeft&quot;: &quot;0&quot;                }, 500);            });        });    });    // 方法二：利用find()    $(function () {        var speed = 500; // 时间        $(&quot;.box&quot;).find(&quot;.jd&quot;).hover(function () {            $(&quot;.jd&quot;).stop().fadeTo(speed, 0.7); // 所以的jd都变淡            $(this).stop().fadeTo(speed, 1); // 自己当前变亮            $(this).children(&quot;img&quot;).stop().animate({                &quot;marginLeft&quot;: &quot;-15px&quot;            }, speed);        }, function () {            $(&quot;.jd&quot;).stop().fadeTo(speed, 1); // 所有的京东都变亮            $(this).children(&quot;img&quot;).stop().animate({                &quot;marginLeft&quot;: &quot;-15px&quot;            }, speed);        });    });&lt;/script&gt;</code></pre><hr><h3 id="6-百度浏览器模块滑动（案例九宫格布局）"><a href="#6-百度浏览器模块滑动（案例九宫格布局）" class="headerlink" title="6.百度浏览器模块滑动（案例九宫格布局）"></a>6.百度浏览器模块滑动（案例九宫格布局）</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    img {        display: block;    }    #box {        width: 752px;        margin: 100px auto;        border: 1px solid #ccc;        padding: 10px 0 0 10px;        overflow: hidden;    }    #box ul li {        width: 178px;        height: 125px;        float: left;        margin: 0 10px 10px 0;        overflow: hidden;        position: relative;        /*父相子绝*/    }    #box ul li div {        width: 178px;        height: 25px;        position: absolute;        left: 0;        bottom: -25px;        background-color: #000;    }    #box ul li p {        width: 178px;        height: 25px;        line-height: 25px;        text-align: center;        position: absolute;        left: 0;        bottom: -25px;        color: #fff;        font-size: 12px;        background: url(&quot;images/bg.png&quot;) no-repeat 10px 0;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;img src=&quot;images/01.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/02.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/03.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/04.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/05.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/06.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/07.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;images/08.JPG&quot; alt=&quot;&quot;&gt;            &lt;div&gt;&lt;/div&gt;            &lt;p&gt;百度一下,你就知道&lt;/p&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        var speed = 500; // 定义一个变量时间        $(&quot;#box div&quot;).fadeTo(0, 0.5); // jq实现透明        // 遍历循环精灵图        $(&quot;#box p&quot;).each(function (index, ele) {            var num = -index * 25;            // 注意：this这个地方可以改成ele元素            $(ele).css(&quot;background-position&quot;, &quot;10px &quot; + num + &quot;px&quot;);            $(&quot;#box ul li&quot;).hover(function () {                $(this).children(&quot;p,div&quot;).stop().animate({                    &quot;bottom&quot;: &quot;0&quot;                }, speed);            }, function () {                $(this).children(&quot;p,div&quot;).stop().animate({                    &quot;bottom&quot;: &quot;-25px&quot;                }, speed);            })        });    });&lt;/script&gt;</code></pre><hr><h3 id="7-手风琴案例"><a href="#7-手风琴案例" class="headerlink" title="7.手风琴案例"></a>7.手风琴案例</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    .box {        width: 1020px;        height: 400px;        margin: 100px auto;    }    .box ul li {        float: left;        width: 200px;        height: 400px;        border: 1px solid gold;        background: url(&quot;images/1.jpg&quot;) no-repeat;        /* 解决边框层叠问题 */        margin-left: -1px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 遍历背景图        var speed = 500;        $(&quot;.box li&quot;).each(function (index, el) {            var num = index + 1; // 表示要让我的图片和索引对应            $(el).css({                &quot;background&quot;: &quot;url(&#39;images/&quot; + num + &quot;.jpg&#39;) no-repeat&quot;            });            $(&quot;.box li&quot;).hover(function () {                $(this).stop().animate({                    &quot;width&quot;: &quot;600px&quot;                }, speed).siblings().stop().animate({                    &quot;width&quot;: &quot;100px&quot;                }, speed)            }, function () {                $(&quot;.box li&quot;).stop().animate({                    &quot;width&quot;: &quot;200px&quot;                }, speed)            });        });    });&lt;/script&gt;</code></pre><hr><h3 id="8-获取鼠标在网页中的坐标pageX和pageY"><a href="#8-获取鼠标在网页中的坐标pageX和pageY" class="headerlink" title="8.获取鼠标在网页中的坐标pageX和pageY"></a>8.获取鼠标在网页中的坐标pageX和pageY</h3><pre><code>&lt;!-- 案例： --&gt;&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;body,html&quot;).mousemove(function (event) { // 鼠标移动事件:mousemove            var x = event.pageX; // 获取在页面中的x坐标            var y = event.pageY; // 获取在页面中的y坐标            $(&quot;.test&quot;).html(&quot;页面中x坐标是&quot; + x + &quot;页面中y坐标是&quot; + y);        });    });&lt;/script&gt;</code></pre><hr><h3 id="9-鼠标跟随效果"><a href="#9-鼠标跟随效果" class="headerlink" title="9.鼠标跟随效果"></a>9.鼠标跟随效果</h3><pre><code>&lt;style&gt;    .box {        width: 50px;        height: 50px;        background-color: pink;        position: absolute;        /* cursor: pointer; */        /* cursor: default; */        cursor: move;        /*光标效果*/    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;body,html&quot;).mousemove(function (event) {            var x = event.pageX - 25;            var y = event.pageY - 25;            $(&quot;.box&quot;).css({                &quot;left&quot;: x,                &quot;top&quot;: y            });        });    });&lt;/script&gt;</code></pre><hr><h3 id="10-屏幕滚动事件"><a href="#10-屏幕滚动事件" class="headerlink" title="10.屏幕滚动事件"></a>10.屏幕滚动事件</h3><pre><code>&lt;script&gt;    // 屏幕滚动事件    $(window).scroll(function () {        // 语句;    });    // 获取页面被卷去的上面    $(window).scrollTop();    // 获取页面被卷去的左面    $(window).scrollLeft();&lt;/script&gt;</code></pre><hr><h3 id="11-腾讯体育可以固定滑动的导航栏-滚动事件案例"><a href="#11-腾讯体育可以固定滑动的导航栏-滚动事件案例" class="headerlink" title="11.腾讯体育可以固定滑动的导航栏(滚动事件案例)"></a>11.腾讯体育可以固定滑动的导航栏(滚动事件案例)</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    .top {        width: 100%;        height: 168px;        background: url(&quot;images/top.png&quot;) no-repeat center top;    }    .nav {        width: 100%;        height: 84px;        background: url(&quot;images/nav.png&quot;) no-repeat center top;    }    .main {        width: 100%;        height: 1370px;        margin: 0 auto;        background: url(&quot;images/main.png&quot;);    }&lt;/style&gt;&lt;div class=&quot;top&quot;&gt;&lt;/div&gt;&lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 屏幕滚动事件        $(window).scroll(function () {            // 在滚动事件里面            var gao = $(&quot;.top&quot;).height();            // 获取到被卷去的上面,有人会写document            var tou = $(window).scrollTop();            // console.log(tou);            // 核心思想：当我滚动到了168的位置的时候，就要把nav变成固定定位            if (tou &gt;= gao) {                // alert(&quot;我滚动到了&quot;)                $(&quot;.nav&quot;).css({                    &quot;position&quot;: &quot;fixed&quot;,                    &quot;top&quot;: &quot;0&quot;                });                $(&quot;.main&quot;).css({                    &quot;marginTop&quot;: &quot;84px&quot;                });            } else {                $(&quot;.nav&quot;).css({                    &quot;position&quot;: &quot;static&quot;,                });                $(&quot;.main&quot;).css({                    &quot;marginTop&quot;: &quot;0&quot;                });            }        });    });&lt;/script&gt;</code></pre><hr><h3 id="12-自动检测盒子的宽度和高度"><a href="#12-自动检测盒子的宽度和高度" class="headerlink" title="12.自动检测盒子的宽度和高度"></a>12.自动检测盒子的宽度和高度</h3><pre><code>&lt;style&gt;    div {        width: 200px;        height: 200px;        border: 6px solid #000;        padding: 10px;        margin: 15px;        background-color: pink;    }&lt;/style&gt;&lt;!-- 案例： --&gt;&lt;button&gt;点击&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // 1.width（）    // 2.height（）    // 3.innerHeight（）   // 获取到div的实际的高度+内边距    // 4.innerWidth（）    // 5.outerHeight（）   // 获取到div的实际的高度+内边距+边框    // 6.outerHeight(true) // 一切都算（实际的高度+内边距+边框+外边距）    // 7.outerWidth（）    // 强大了，我们可以通过height innerHeight outerHeight获取到盒子高度(宽度同理)    $(function () {        $(&quot;button&quot;).click(function () {            // console.log($(&quot;div&quot;).height());    // 获取到div的实际的高度            // console.log($(&quot;div&quot;).innerHeight()); // 获取到div的实际的高度+内边距            // console.log($(&quot;div&quot;).outerHeight()); // 获取到div的实际的高度+内边距+边框            console.log($(&quot;div&quot;).outerHeight(true)); // 一切都算（实际的高度+内边距+边框+外边距）        });    })&lt;/script&gt;</code></pre><hr><h3 id="13-两侧跟随广告-跟随鼠标滚动广告"><a href="#13-两侧跟随广告-跟随鼠标滚动广告" class="headerlink" title="13.两侧跟随广告(跟随鼠标滚动广告)"></a>13.两侧跟随广告(跟随鼠标滚动广告)</h3><pre><code>&lt;style&gt;    .left,    .right {        position: absolute;        top: 50px;    }    .left {        left: 0;    }    .right {        right: 0;    }&lt;/style&gt;&lt;img src=&quot;1.gif&quot; alt=&quot;&quot; class=&quot;left&quot;&gt;&lt;img src=&quot;2.gif&quot; alt=&quot;&quot; class=&quot;right&quot;&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;p&gt;天王盖地虎，小鸡炖蘑菇&lt;/p&gt;&lt;script&gt;    $(function () {        $(&quot;.left,.right&quot;).click(function () {            $(this).hide(); // 点击谁谁就关闭效果        });        // 滚动跟随广告效果        $(window).scroll(function () {            var val = $(window).scrollTop();            $(&quot;.left,.right&quot;).stop().animate({                &quot;top&quot;: val + 50            }, 800);        });    });&lt;/script&gt;</code></pre><hr><h3 id="14-表单搜索效果"><a href="#14-表单搜索效果" class="headerlink" title="14.表单搜索效果"></a>14.表单搜索效果</h3><pre><code>&lt;style&gt;    input {        color: gray;        outline: none;        resize: none;        /*禁止textare任意拖动*/        /*清除表单蓝色边框*/    }&lt;/style&gt;搜索:&lt;input type=&quot;text&quot; value=&quot;请输入...&quot;&gt;&lt;script&gt;    // 注意：val（）方法，设置值 val(&#39;这样天填写&#39;）1.焦点focus() 2.失去焦点blur()    $(function () {        $(&quot;input&quot;).focus(function () { // 获取焦点---搜索都是用获取焦点            // 判断            if ($(&quot;input&quot;).val() == &quot;请输入...&quot;) {                $(this).val(&quot;&quot;); // 代表清空数据                $(this).css({                    &quot;color&quot;: &quot;black&quot;                });            }        }).blur(function () {            // 判断            if ($(&quot;input&quot;).val() == &quot;&quot;) { // 如果你等于空                $(this).val(&quot;请输入...&quot;);                $(this).css({                    &quot;color&quot;: &quot;gray&quot;                });            }        });    });&lt;/script&gt;</code></pre><hr><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="1-事件绑定"><a href="#1-事件绑定" class="headerlink" title="1.事件绑定"></a>1.事件绑定</h3><pre><code>简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐)</code></pre><hr><h3 id="2-bind事件绑定"><a href="#2-bind事件绑定" class="headerlink" title="2.bind事件绑定"></a>2.bind事件绑定</h3><pre><code>&lt;!-- 案例： --&gt;&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;&gt;&lt;script&gt;    // click()    单击事件    // mouseenter()    鼠标进入事件    // mouseleave()    鼠标离开事件    // 1. 第一种写法：为按钮绑定鼠标进入，鼠标离开，点击三个事件    $(&quot;#btn&quot;).mouseenter(function () {        $(this).css(&quot;backgroundColor&quot;, &quot;red&quot;);    });    $(&quot;#btn&quot;).mouseleave(function () {        $(this).css(&quot;backgroundColor&quot;, &quot;green&quot;);    });    $(&quot;#btn&quot;).click(function () {        alert(&quot;啊~，我被点了&quot;);    });    // 2. 第二种写法：链式操作    $(&quot;#btn&quot;).mouseenter(function () {        $(this).css(&quot;backgroundColor&quot;, &quot;red&quot;);    }).mouseleave(function () {        $(this).css(&quot;backgroundColor&quot;, &quot;green&quot;);    }).click(function () {        alert(&quot;啊~，我被点了&quot;);    });    // 3. 第三种写法：bind方法绑定事件    $(&quot;#btn&quot;).bind(&quot;click&quot;, function () {        alert(&quot;嘎嘎&quot;);    });    $(&quot;#btn&quot;).bind(&quot;mouseenter&quot;, function () {        $(this).css(&quot;backgroundColor&quot;, &quot;red&quot;);    });    $(&quot;#btn&quot;).bind(&quot;mouseleave&quot;, function () {        $(this).css(&quot;backgroundColor&quot;, &quot;green&quot;);    });    // 4. 第四种写法: bind方法链式绑定事件    $(&quot;#btn&quot;).bind(&quot;click&quot;, function () {        alert(&quot;嘎嘎&quot;);    }).bind(&quot;mouseenter&quot;, function () {        $(this).css(&quot;backgroundColor&quot;, &quot;red&quot;);    }).bind(&quot;mouseleave&quot;, function () {        $(this).css(&quot;backgroundColor&quot;, &quot;green&quot;);    });    // 5. 第五种写法: bind对象的方法绑定事件    $(&quot;#btn&quot;).bind({        &quot;click&quot;: function () {            alert(&quot;嘎嘎&quot;);        },        &quot;mouseenter&quot;: function () {            $(this).css(&quot;backgroundColor&quot;, &quot;red&quot;);        },        &quot;mouseleave&quot;: function () {            $(this).css(&quot;backgroundColor&quot;, &quot;green&quot;);        }    });&lt;/script&gt;</code></pre><hr><h3 id="3-（绑定多个事件）事件不会被覆盖，但是采用对象键值对的方式，只能执行最后一个"><a href="#3-（绑定多个事件）事件不会被覆盖，但是采用对象键值对的方式，只能执行最后一个" class="headerlink" title="3.（绑定多个事件）事件不会被覆盖，但是采用对象键值对的方式，只能执行最后一个"></a>3.（绑定多个事件）事件不会被覆盖，但是采用对象键值对的方式，只能执行最后一个</h3><pre><code>&lt;input type=&quot;button&quot; value=&quot;显示效果&quot; id=&quot;btn&quot;&gt;&lt;script&gt;    // 1.第一个参数：事件类型 2.第二个参数：事件处理程序    $(&quot;#btn&quot;).bind({        &quot;click&quot;: function () {            console.log(&quot;第一个事件&quot;);        },        &quot;click&quot;: function () {            console.log(&quot;第二个事件&quot;);        }    });    // 2.绑定多个事件不会覆盖案例：    // jquery click事件不会覆盖    $(&quot;#btn&quot;).click(function () {        console.log(&quot;我是第一个事件&quot;);    });    $(&quot;#btn&quot;).click(function () {        console.log(&quot;我是第二事件&quot;);    });    $(&quot;#btn&quot;).click(function () {        console.log(&quot;我是第三个事件&quot;);    })    //测试bind-    $(&quot;#btn&quot;).bind(&quot;click&quot;, function () {        console.log(&quot;我是bind绑定第一个事件&quot;);    }).bind(&quot;click&quot;, function () {        console.log(&quot;我是bind绑定第二个事件&quot;);    });&lt;/script&gt;</code></pre><hr><h3 id="4-delegate注册委托事件"><a href="#4-delegate注册委托事件" class="headerlink" title="4.delegate注册委托事件"></a>4.delegate注册委托事件</h3><pre><code>&lt;!-- 案例： --&gt;&lt;input type=&quot;button&quot; value=&quot;为div绑定事件&quot; id=&quot;btn&quot;&gt;&lt;div id=&quot;dv&quot;&gt;    &lt;p&gt;这是段落p标签&lt;/p&gt;    &lt;p&gt;这是段落p2标签&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    // 语法：    // $(&quot;.parentBox&quot;).delegate(&quot;p&quot;, &quot;click&quot;, function () {    //     为.parentBox下面的所有的p标签绑定事件    // });    // 第一个参数：selector，要绑定事件的元素 p span 子元素    // 第二个参数：事件类型    // 第三个参数：事件处理函数    $(function () {        $(&quot;#btn&quot;).click(function () {            // 为父级元素绑定事件,父级元素可以代替子级绑定事件，就是把子级元素的事件委托给了父级元素。            $(&quot;#dv&quot;).delegate(&quot;p&quot;, &quot;click&quot;, function () {                alert(&quot;我被点击了&quot;);            })        })    })&lt;/script&gt;</code></pre><hr><h3 id="5-on注册事件-重点"><a href="#5-on注册事件-重点" class="headerlink" title="5.on注册事件(重点)"></a>5.on注册事件(重点)</h3><pre><code>&lt;!-- 案例： --&gt;&lt;input type=&quot;button&quot; value=&quot;绑定事件&quot; id=&quot;btn&quot;&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script&gt;    // 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定    // $(selector).on(&quot;click&quot;, “span”, function () {});    // 语法：    // $(selector).on(events[, selector][, data], handler);    // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）    // 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。    // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）    // 第四个参数：handler，事件处理函数    // 语法:on(事件类型,选择器,匿名函数)--语法变了--思想是一样事件委托    $(function () {        // 点击按钮为div绑定事件        $(&quot;#btn&quot;).click(function () {            // 动态创建一个标签，追加到div里面appendTo            $(&quot;&lt;p&gt;我是段落标签&lt;/p&gt;&quot;).appendTo(&quot;#dv&quot;);            $(&quot;#dv&quot;).on(&quot;click&quot;, &quot;p&quot;, function () {                alert(&quot;p被点击了&quot;);            })        })    });&lt;/script&gt;</code></pre><hr><h3 id="6-on注册委托事件"><a href="#6-on注册委托事件" class="headerlink" title="6.on注册委托事件"></a>6.on注册委托事件</h3><pre><code>&lt;script&gt;    // on(事件类型, 选择器, 匿名函数) --语法变了--思想是一样事件委托    // 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定    $(selector).on(&quot;click&quot;, &quot;span&quot;, function () {});&lt;/script&gt;</code></pre><hr><h3 id="7-元素事件解绑"><a href="#7-元素事件解绑" class="headerlink" title="7.元素事件解绑"></a>7.元素事件解绑</h3><pre><code>&lt;script&gt;    // 1.unbind方式（不用）    $(selector).unbind(); // 括号中没有写任何参数,解绑所有的事件    $(selector).unbind(&quot;click&quot;); // 解绑指定的click事件    $(&quot;#dv&quot;).unbind(&quot;mouseenter mouseleave click&quot;) // unbind()括号里面可以写多个参数（中间用空格隔开）--同时解绑多个事件    // 2.undelegate方式（不用）    $(selector).undelegate(); // 解绑该元素身上所有的delegate事件    $(selector).undelegate(&quot;click&quot;); // 解绑所有的click事件    // 3.off方式（on的解绑方式推荐）    // 父级元素和子级元素的所有的事件全部被解绑    $(selector).off();    // 把父级元素和子级元素的点击事件解绑    $(selector).off(&quot;click&quot;);    $(selector).off(&quot;click mouseenter&quot;); //    // 1.案例unbind方式：    // &lt;input type=&quot;button&quot; value=&quot;绑定事件&quot; id=&quot;btn&quot;&gt;    // &lt;input type=&quot;button&quot; value=&quot;解绑事件&quot; id=&quot;btn2&quot;&gt;    // &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;    // 先绑定    $(function () {        $(&quot;#btn&quot;).click(function () {            $(&quot;#dv&quot;).bind(&quot;click&quot;, function () {                console.log(&quot;我是bind方式被点击了&quot;);            });            // 鼠标移入            $(&quot;#dv&quot;).bind(&quot;mouseenter&quot;, function () {                $(this).css(&quot;background&quot;, &quot;pink&quot;);            });            // 鼠标移出            $(&quot;#dv&quot;).bind(&quot;mouseleave&quot;, function () {                $(this).css(&quot;background&quot;, &quot;green&quot;);            });            $(&quot;#dv&quot;).click(function () {                console.log(&quot;我是click给div加的点击事件&quot;);            });        });        // 解绑事件        $(&quot;#btn2&quot;).click(function () {            // $(&quot;#dv&quot;).unbind(&quot;click&quot;); //可以把所有的click事件都解除，解绑            // $(&quot;#dv&quot;).unbind();unbind()里面如果什么都不写，不写任何参数，此时所有的事件都被解绑了            // unbind()括号里面可以加入多个参数(注意：多个参数是用空格隔开的)---同时解绑多个事件            $(&quot;#dv&quot;).unbind(&quot;mouseenter mouseleave click&quot;)        })    })    // 2.on的解绑方式 --off方式使用案例    // &lt;input type=&quot;button&quot; value=&quot;绑定事件&quot; id=&quot;btn&quot;&gt;    // &lt;input type=&quot;button&quot; value=&quot;解绑事件&quot; id=&quot;btn2&quot;&gt;    // &lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;    $(function () {        $(&quot;#btn&quot;).click(function () {            $(&quot;#dv&quot;).click(function () {                console.log(&#39;div被点击了&#39;);            }).mouseenter(function () {                console.log(&quot;div盒子的移入效果&quot;);            }).mouseleave(function () {                console.log(&quot;div的盒子移出事件&quot;);            });            // 动态创建一个p标签（事件冒泡--jquery是有事件冒泡的）            $(&quot;&lt;p&gt;我是动态创建的p&lt;/p&gt;&quot;).appendTo(&quot;#dv&quot;);            $(&quot;#dv&quot;).on(&quot;click&quot;, &quot;p&quot;, function () {                console.log(&quot;我是p标签也被点&quot;);            });            $(&quot;#dv&quot;).on(&quot;mouseenter&quot;, &quot;p&quot;, function () {                console.log(&quot;我是p标签的移入事件&quot;);            });            // 解绑：用什么事件绑定就用什么事件解绑，on绑定---off解绑            $(&quot;#btn2&quot;).click(function () {                // $(&quot;#dv&quot;).off();父级元素和子级元素的所以事件都解绑了                // $(&quot;#dv&quot;).off(&quot;click&quot;);把父级元素和子级元素的点击事件都解绑了                // $(&quot;#dv&quot;).off(&quot;click&quot;, &quot;p&quot;); 扩展解绑子级元素的点击事件（他只会解绑子级身上的点击事件）                // 继续扩展                // $(&quot;#dv&quot;).off(&quot;click mouseenter&quot;)把父级元素和子级元素身上的点击事件和移入事件解绑了                // $(&quot;#dv&quot;).off(&quot;click mouseenter&quot;, &quot;p&quot;);会把p标签上的移入和点击事件都解绑了                // $(&quot;#dv&quot;).off(&quot;&quot;, &quot;p&quot;); 也是可以解绑p标签身上所有的事件--扩展            });        });    });&lt;/script&gt;</code></pre><hr><h3 id="8-冒泡事件及阻止（案例）两种方法-解决冒泡"><a href="#8-冒泡事件及阻止（案例）两种方法-解决冒泡" class="headerlink" title="8.冒泡事件及阻止（案例）两种方法(解决冒泡)"></a>8.冒泡事件及阻止（案例）两种方法(解决冒泡)</h3><pre><code>&lt;div id=&quot;dv1&quot;&gt;    &lt;div id=&quot;dv2&quot;&gt;        &lt;div id=&quot;dv3&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 1.e.stopPropagation(); // 原生解决冒泡的方法    // 2. return false; // jquery解决冒泡的方法    $(function () {        $(&quot;#dv1&quot;).click(function () {            console.log(&#39;第一个div被点击了&#39;);            console.log($(this).attr(&quot;id&quot;)); // 跟css语法一样        });        $(&quot;#dv2&quot;).click(function () {            console.log(&#39;第二个div被点击了&#39;);            console.log($(this).attr(&quot;id&quot;));        });        $(&quot;#dv3&quot;).click(function (e) {            console.log(&#39;第三个div被点击了&#39;);            console.log($(this).attr(&quot;id&quot;));            // e.stopPropagation(); // 原生解决冒泡的方法            return false; // jquery解决冒泡的方法        });    })&lt;/script&gt;</code></pre><hr><h3 id="9-默认事件（焦点事件）"><a href="#9-默认事件（焦点事件）" class="headerlink" title="9.默认事件（焦点事件）"></a>9.默认事件（焦点事件）</h3><pre><code>&lt;!-- 案例： --&gt;&lt;input type=&quot;button&quot; value=&quot;我也要触发文本框的获取焦点的事件&quot; id=&quot;btn&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;txt&quot;&gt;&lt;span id=&quot;sp&quot;&gt;&lt;/span&gt;&lt;script&gt;    // 1.focus() 2.trigger(&quot;focus&quot;) rigger 触发的意思 3.triggerHandler(&quot;focus&quot;);    // 第一种和第二种是一样的，第三种方法只是把默认的光标闪烁给取消    $(function () {        $(&quot;#txt&quot;).focus(function () {            console.log(&quot;我是获取焦点事件&quot;);            $(this).next(&quot;span&quot;).text(&quot;我们下午主要任务做轮播图，写完就可以加在自己的项目里面&quot;)        });        $(&quot;#btn&quot;).click(function () {            // 点击按钮获取文本框焦点事件            // $(&quot;#txt&quot;).focus();            // $(&quot;#txt&quot;).trigger(&quot;focus&quot;); // trigger 触发的意思            $(&quot;#txt&quot;).triggerHandler(&quot;focus&quot;);            // 总结：第一种和第二种是一样的，第三种方法只是把默认的光标闪烁给取消        })    })    // 文本框验证    $(&#39;#txt&#39;).focus(function () {        $(this).next(&#39;span&#39;).text(&#39;测试duochu&#39;)    }).blur(function () {        $(this).next(&#39;span&#39;).text($(this).val());        $(this).next(&#39;span&#39;).css(&#39;color&#39;, &#39;red&#39;);    });&lt;/script&gt;`</code></pre><hr><h3 id="10-通过each遍历改变不透明度"><a href="#10-通过each遍历改变不透明度" class="headerlink" title="10.通过each遍历改变不透明度"></a>10.通过each遍历改变不透明度</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    li {        width: 100px;        height: 100px;        background-color: pink;        margin-right: 10px;        float: left;    }&lt;/style&gt;&lt;ul id=&quot;uu&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;    &lt;li&gt;6&lt;/li&gt;    &lt;li&gt;7&lt;/li&gt;    &lt;li&gt;8&lt;/li&gt;    &lt;li&gt;9&lt;/li&gt;    &lt;li&gt;10&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 隐士迭代--内部帮助我们循环遍历做操作    // each方法,帮助我们遍历jquery的对象    $(function () {        // for(var i = 0; i &lt; $(&quot;li&quot;).length; i++){        //      $(&quot;li&quot;).eq(i).css(&quot;opacity&quot;,(i+1)/10);        // }        //each方法        $(&quot;li&quot;).each(function (index, e) {            $(e).css(&quot;opacity&quot;, (index + 1) / 10);        });    });&lt;/script&gt;</code></pre><hr><h3 id="11-改变修改元属性attr"><a href="#11-改变修改元属性attr" class="headerlink" title="11.改变修改元属性attr()"></a>11.改变修改元属性attr()</h3><pre><code>&lt;img src=&quot;yao.jpg&quot; alt=&quot;&quot;&gt;&lt;script&gt;    // Jquery代码如下：    $(function () {        $(&quot;img&quot;).mouseover(function () {            $(this).attr({                &quot;src&quot;: &quot;li.jpg&quot;,                &quot;title&quot;: &quot;我是李宇春&quot;            });        }).mouseout(function () {            $(this).attr(&quot;src&quot;, &quot;yao.jgp&quot;);        });    });&lt;/script&gt;</code></pre><hr><h3 id="12-京东轮播图效果（淡入淡出效果）"><a href="#12-京东轮播图效果（淡入淡出效果）" class="headerlink" title="12.京东轮播图效果（淡入淡出效果）"></a>12.京东轮播图效果（淡入淡出效果）</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul,    ol {        list-style: none;    }    img {        display: block;    }    #box {        width: 670px;        height: 240px;        margin: 100px auto;        position: relative;        overflow: hidden;        /*把下面的图片切掉*/    }    #box ul {        position: absolute;        top: 0;        left: 0;    }    /*这个案例li不要加浮动*/    #box ol {        position: absolute;        bottom: 10px;        right: 10px;    }    #box ol li {        float: left;        width: 22px;        height: 22px;        border-radius: 50%;        background-color: gray;        margin: 0 5px;        text-align: center;        line-height: 22px;        color: #fff;        cursor: pointer;        font-size: 14px;    }    #box ol li.current {        background-color: #E4393C;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;img src=&quot;01.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;03.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;04.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;05.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;06.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;        &lt;li&gt;6&lt;/li&gt;    &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        var $key = 0; // 因为我们加了$就表示是jq的变量,此时这个变量用来控制播放下一张        $(&quot;#box ol li&quot;).mousemove(function () {            $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            $(&quot;#box ul li&quot;).eq($(this).index()).stop().fadeIn(&quot;fast&quot;).siblings().fadeOut(&quot;fast&quot;);            // 当鼠标经过，获取新的$key            $key = $(this).index();        });        // 开始添加定时器        var timer = setInterval(autoplay, 1500); // 开启定时器,1.5秒自动播放        function autoplay() {            $key++; // 因为已经处于第一张，它从第二张开始播放，所以先自加,一定要先++在判断--个人经验            if ($key &gt; 5) { // 如果大于5，说明已经走完第6张了，需要清零                $key = 0;            }            $(&quot;#box ol li&quot;).eq($key).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            $(&quot;#box ul li&quot;).eq($key).stop().fadeIn(&quot;fast&quot;).siblings().fadeOut(&quot;fast&quot;);        }        // 清除定时器，鼠标经过时就不能自动播放了，给大盒子加，只要经过这个大盒子都清除定时器-        $(&quot;#box&quot;).hover(function () {            clearInterval(timer); //清除定时器        }, function () {            // 个人经验，开启定时器先清除定时器            clearInterval(timer);            timer = setInterval(autoplay, 1500); // 开启定时器        });    });&lt;/script&gt;</code></pre><hr><h3 id="13-京东轮播图效果（上下轮播效果）"><a href="#13-京东轮播图效果（上下轮播效果）" class="headerlink" title="13.京东轮播图效果（上下轮播效果）"></a>13.京东轮播图效果（上下轮播效果）</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul,    ol {        list-style: none;    }    img {        display: block;    }    #box {        width: 670px;        height: 240px;        margin: 100px auto;        position: relative;        /*父相子绝*/        overflow: hidden;    }    #box ul {        position: absolute;        left: 0;        top: 0;    }    #box ol {        position: absolute;        bottom: 10px;        right: 10px;    }    #box ol li {        float: left;        width: 22px;        height: 22px;        line-height: 22px;        text-align: center;        color: #fff;        border-radius: 50%;        background-color: gray;        cursor: pointer;        margin: 0 5px;        font-size: 14px;    }    #box ol li.current {        background-color: #E4393C;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;img src=&quot;01.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;03.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;04.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;05.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;06.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;        &lt;li&gt;6&lt;/li&gt;    &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        var $key = 0; // 一般在工作里面看到$key表示是jq的变量，此时这个变量是用来控制播放下一张        $(&quot;#box ol li&quot;).mousemove(function () {            $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            // 当鼠标经过，获取新的$key            $key = $(this).index();            $(&quot;#box ul&quot;).stop().animate({                &quot;top&quot;: -$key * 240            }, 500);        });        // 定时器开始 setInterval        var timer = setInterval(autoplay, 1500);        // 函数封装---去查询一下设表先关        function autoplay() {            $key++; // 为啥：因为我此时已经处于第一张，上来就要播放第二张，所以会先++（工作经验：先++后判断）            // 判断            if ($key &gt; 5) { // 大于5，因为图片是6张，索引值从0开始的                $key = 0;            }            console.log($key);            $(&quot;#box ol li&quot;).eq($key).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            $(&quot;#box ul&quot;).stop().animate({                &quot;top&quot;: -$key * 240            }, 500);        }        // 清除定时器，鼠标经过时就不能自动播放了，给大盒子加，只要经过这个大盒子都清除定时器        $(&quot;#box&quot;).hover(function () {            clearInterval(timer); //清除定时器        }, function () {            // 个人经验，开启定时器先清除定时器---设表先关            clearInterval(timer); // 清除定时器            timer = setInterval(autoplay, 1500);        });    });&lt;/script&gt;</code></pre><hr><h3 id="14-京东轮播图效果（左右轮播效果）"><a href="#14-京东轮播图效果（左右轮播效果）" class="headerlink" title="14.京东轮播图效果（左右轮播效果）"></a>14.京东轮播图效果（左右轮播效果）</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul,    ol {        list-style: none;    }    img {        display: block;    }    #box {        width: 670px;        height: 240px;        margin: 100px auto;        position: relative;        /*父相子绝*/        overflow: hidden;    }    #box ul {        position: absolute;        left: 0;        top: 0;        width: 5000px;    }    #box ul li {        float: left;    }    #box ol {        position: absolute;        bottom: 10px;        right: 10px;    }    #box ol li {        float: left;        width: 22px;        height: 22px;        line-height: 22px;        text-align: center;        color: #fff;        border-radius: 50%;        background-color: gray;        cursor: pointer;        margin: 0 5px;        font-size: 14px;    }    #box ol li.current {        background-color: #E4393C;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;img src=&quot;01.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;03.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;04.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;05.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;06.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;        &lt;li&gt;6&lt;/li&gt;    &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        var $key = 0; // 一般在工作里面看到$key表示是jq的变量，此时这个变量是用来控制播放下一张        $(&quot;#box ol li&quot;).mousemove(function () {            $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            // 当鼠标经过，获取新的$key            $key = $(this).index();            $(&quot;#box ul&quot;).stop().animate({                &quot;left&quot;: -$key * 670            }, 500);        });        // 定时器开始 setInterval        var timer = setInterval(autoplay, 1500);        // 函数封装---去查询一下设表先关        function autoplay() {            $key++; // 为啥：因为我此时已经处于第一张，上来就要播放第二张，所以会先++（工作经验：先++后判断）            // 判断            if ($key &gt; 5) { // 大于5，因为图片是6张，索引值从0开始的                $key = 0;            }            console.log($key);            $(&quot;#box ol li&quot;).eq($key).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            $(&quot;#box ul&quot;).stop().animate({                &quot;left&quot;: -$key * 670            }, 500);        }        // 清除定时器，鼠标经过时就不能自动播放了，给大盒子加，只要经过这个大盒子都清除定时器        $(&quot;#box&quot;).hover(function () {            clearInterval(timer); // 清除定时器        }, function () {            // 个人经验，开启定时器先清除定时器---设表先关            clearInterval(timer); // 清除定时器            timer = setInterval(autoplay, 1500);        })    })&lt;/script&gt;</code></pre><hr><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="1-小米呼吸轮播图"><a href="#1-小米呼吸轮播图" class="headerlink" title="1.小米呼吸轮播图"></a>1.小米呼吸轮播图</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul,    ol {        list-style: none;    }    img {        display: block;        border: 0;    }    .box {        width: 992px;        height: 420px;        margin: 100px auto;        position: relative;        /*父相子绝*/        overflow: hidden;    }    .box ul li {        position: absolute;        left: 0;        top: 0;        /*先隐藏全部*/        display: none;    }    .box ol {        position: absolute;        right: 10px;        bottom: 10px;    }    .box ol li {        width: 28px;        height: 18px;        border: 1px solid #ccc;        background: rgba(0, 0, 0, 0.3);        float: left;        line-height: 18px;        text-align: center;        margin: 0 5px;        cursor: pointer;    }    .box ol li:hover {        background: rgba(0, 0, 0, 0.6);    }    .left,    .right {        position: absolute;        width: 41px;        height: 69px;        background: url(&quot;images/arr.png&quot;) no-repeat;        z-index: 9999;        top: 175px;        /*先隐藏你的三角，然后用jq做效果*/        display: none;    }    .left {        background-position: -84px 0;        left: 0;    }    .left:hover {        background-position: left;    }    .right {        background-position: right;        right: 0;    }    .right:hover {        background-position: -42px 0;    }    .box ol li.current {        background: rgba(0, 0, 0, 0.6);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;a href=&quot;javascirpt:;&quot; class=&quot;left&quot;&gt;&lt;/a&gt;    &lt;a href=&quot;javascirpt:;&quot; class=&quot;right&quot;&gt;&lt;/a&gt;    &lt;ul&gt;        &lt;li style=&quot;display: block;&quot;&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;    &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 因为在工作里面为了区分是jq变量，前面会加$ 控制播放下一张        $key = 0;        // 第一、先淡出        $(&quot;.right&quot;).click(function () { //右侧按钮写完了，定时器就写好了欧了            autoplay(); //优化代码        });        // 工作里面就是这样只写一个，把right改成left，然后++改成--        $(&quot;.left&quot;).click(function () { //右侧按钮写完了，定时器就写好了欧了            // 先第一张图片淡出            $(&quot;.box ul li&quot;).eq($key).fadeOut(600);            $key--;            // if ($key &gt; 4) { // 因为我们是5张图，索引值是从0开始的            //     $key = 0; // 第一张图            // }            // alert($(&quot;.box ul li&quot;).length);            $key = $key % $(&quot;.box ul li&quot;).length; // 推荐用这个            // console.log($key);            $(&quot;.box ul li&quot;).eq($key).fadeIn(600);            $(&quot;.box ol li&quot;).eq($key).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);        });        // 定时器：相当于点击了右侧按钮        var timer = setInterval(autoplay, 2000);        // 函数封装        function autoplay() { // 复制右侧里面的代码，谁需要谁调用            // 先第一张图片淡出            $(&quot;.box ul li&quot;).eq($key).fadeOut(600);            $key++;            // if ($key &gt; 4) { // 因为我们是5张图，索引值是从0开始的            //     $key = 0; // 第一张图            // }            // alert($(&quot;.box ul li&quot;).length);            $key = $key % $(&quot;.box ul li&quot;).length;            // console.log($key);            $(&quot;.box ul li&quot;).eq($key).fadeIn(600);            $(&quot;.box ol li&quot;).eq($key).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);        }        // 鼠标经过经过和离开        $(&quot;.box&quot;).hover(function () {            $(&quot;.left,.right&quot;).show();            clearInterval(timer);            timer = null; // 节省内存        }, function () {            $(&quot;.left,.right&quot;).hide();            // 一般在开启定时器之前，首先清除定时器            clearInterval(timer); // 设表先关            timer = setInterval(autoplay, 2000);        });        // 鼠标点击小ol li ，会跳到相应的页面上        $(&quot;.box ol li&quot;).click(function () {            // 第一张图片淡出            $(&quot;.box ul li&quot;).eq($key).fadeOut(600);            $key = $(this).index(); // 点击的时候要从新获取索引值            $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);            $(&quot;.box ul li&quot;).eq($key).fadeIn(600);        });    });&lt;/script&gt;</code></pre><hr><h3 id="2-创建节点两种插入节点"><a href="#2-创建节点两种插入节点" class="headerlink" title="2.创建节点两种插入节点"></a>2.创建节点两种插入节点</h3><pre><code>&lt;style&gt;    div {        width: 100px;        height: 100px;        background-color: pink;        float: left;    }    .demo {        background-color: purple;    }&lt;/style&gt;&lt;div class=&quot;demo&quot;&gt;我是文字&lt;/div&gt;&lt;div class=&quot;demo&quot;&gt;我是文字&lt;/div&gt;&lt;script&gt;    // 1. before盒子之前  2.after盒子之后    // 创建并插入节点 before盒子之前，after盒子之后    $(function () {        var DIV = $(&quot;&lt;div&gt;创建节点&lt;/div&gt;&quot;); // 创建节点        // $(&quot;.demo&quot;).before(DIV);//插入在盒子之前        // 插入在盒子之后        $(&quot;.demo&quot;).after(DIV);    })&lt;/script&gt;</code></pre><hr><h3 id="3-元素中添加内容两种-插入标签-插入内容"><a href="#3-元素中添加内容两种-插入标签-插入内容" class="headerlink" title="3.元素中添加内容两种 插入标签 插入内容"></a>3.元素中添加内容两种 插入标签 插入内容</h3><pre><code>&lt;style&gt;    .box {        width: 300px;        height: 300px;        border: 1px solid #000;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;明天要休息啦！&lt;/div&gt;&lt;script&gt;    // 1.prepend //在内容前面追加    // 2.append  //在内容后面追加    $(function () {        // $(&quot;.box&quot;).prepend(&quot;好消息&quot;); // 在内容前面追加        $(&quot;.box&quot;).append(&quot;可以看熊大熊二&quot;); // 在内容后面追加    })&lt;/script&gt;</code></pre><hr><h3 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h3><pre><code>&lt;style&gt;    ul {        border: 1px solid #000;    }&lt;/style&gt;&lt;button&gt;删除节点&lt;/button&gt;&lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 1.remove() 删除所选择的元素  （选择的元素和它里面所有元素都被删除）    // 2.empty() 删除所选择元素里面的元素    $(function () {        $(&quot;button&quot;).click(function () {            // $(&quot;ul&quot;).remove(); 删除所有包含ul盒子本身            $(&quot;ul&quot;).empty(); // 边框线还是存在的        });    });&lt;/script&gt;</code></pre><hr><h3 id="5-无缝拼接轮播图-左右"><a href="#5-无缝拼接轮播图-左右" class="headerlink" title="5.无缝拼接轮播图(左右)"></a>5.无缝拼接轮播图(左右)</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul,    ol {        list-style: none;    }    a {        text-decoration: none;    }    img {        display: block;    }    #box {        width: 900px;        height: 350px;        margin: 100px auto;        position: relative;        /*父相子绝*/        overflow: hidden;    }    #box ul {        position: absolute;        left: 0;        top: 0;        width: 9999px;    }    #box ul li {        float: left;    }    #box ol {        position: absolute;        right: 10px;        bottom: 10px;    }    #box ol li {        float: left;        width: 20px;        height: 20px;        background: #333;        margin: 0 5px;        text-align: center;        line-height: 20px;        cursor: pointer;        color: #999;    }    #box ol li.current {        color: #f40;        border: 1px solid #f40;    }    #left,    #right {        position: absolute;        width: 40px;        height: 80px;        background: rgba(0, 0, 0, 0.5);        z-index: 999;        top: 50%;        margin-top: -40px;        font-size: 50px;        color: #fff;        text-align: center;        line-height: 80px;    }    #left {        left: 0;    }    #right {        right: 0;    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;    &lt;a href=&quot;javascript:;&quot; id=&quot;left&quot;&gt;&amp;lt;&lt;/a&gt;    &lt;a href=&quot;javascript:;&quot; id=&quot;right&quot;&gt;&amp;gt;&lt;/a&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;        &lt;li&gt;5&lt;/li&gt;    &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // 因为我们图片的个数和有序列表的个数不一样        var $key = 0; // 控制播放下一张图片的        var $circle = 0; // 控制下面的有序列表的        var speed = 500;        // 先做右侧        $(&quot;#right&quot;).click(function () {            autoplay(); // 直接调用定时器的函数        });        // 工作里面直接复制右侧给左侧，right改成left，然后++改成--        $(&quot;#left&quot;).click(function () {            // 先++后判断            $key--;            // 判断            if ($key &lt; 0) { // 第一张                $key = 4; // 表示第五张图                $(&quot;#box ul&quot;).css(&quot;left&quot;, -4500); // 不会有动画效果            }            $(&quot;#box ul&quot;).stop().animate({                &quot;left&quot;: -$key * 900            }, speed);            // 下面有序列表跟着走            $circle--; // 先++后判断            if ($circle &lt; 0) {                $circle = 4;            }            // console.log($circle);            $(&quot;#box ol li&quot;).eq($circle).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);        });        // 定时器就相当于你的右侧按钮        var timer = setInterval(autoplay, 2000);        // 函数        function autoplay() {            // 先++后判断            $key++;            // 判断            if ($key &gt; 5) {                $key = 1;                $(&quot;#box ul&quot;).css(&quot;left&quot;, 0); // 不会有动画效果            }            $(&quot;#box ul&quot;).stop().animate({                &quot;left&quot;: -$key * 900            }, speed);            // 下面有序列表跟着走            $circle++; //先++后判断            if ($circle &gt; 4) {                $circle = 0;            }            // console.log($circle);            $(&quot;#box ol li&quot;).eq($circle).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);        }        // 点击有序列表按钮效果        $(&quot;#box ol li&quot;).click(function () {            // 之前学的点击的时候从新获取索引值            $key = $(this).index();            $circle = $(this).index();            $(&quot;#box ul&quot;).stop().animate({                &quot;left&quot;: -$key * 900            }, speed);            $(&quot;#box ol li&quot;).eq($circle).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);        });        // 鼠标经过和离开        $(&quot;#box&quot;).hover(function () {            clearInterval(timer);        }, function () {            // 设表先关            clearInterval(timer);            timer = setInterval(autoplay, 2000);        });    });&lt;/script&gt;</code></pre><hr><h3 id="6-盒子距离上面距离-注意没有括号-盒子边距计算"><a href="#6-盒子距离上面距离-注意没有括号-盒子边距计算" class="headerlink" title="6.盒子距离上面距离(注意没有括号)盒子边距计算"></a>6.盒子距离上面距离(注意没有括号)盒子边距计算</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    #box {        width: 200px;        height: 200px;        background-color: pink;        margin-top: 150px;    }&lt;/style&gt;&lt;p&gt;我是段落标签&lt;/p&gt;&lt;p&gt;我是段落标签&lt;/p&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    // 1.offset().top   // 盒子距离页面顶端距离    // 2.offset().left     // 盒子距离页面左侧距离    $(function () {        alert($(&quot;#box&quot;).offset().top)    })&lt;/script&gt;</code></pre><hr><h3 id="7-获取光标位置案例："><a href="#7-获取光标位置案例：" class="headerlink" title="7.获取光标位置案例："></a>7.获取光标位置案例：</h3><pre><code>&lt;style&gt;    .box {        width: 300px;        height: 300px;        background-color: pink;        margin: 100px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        $(&quot;body,html&quot;).mousemove(function (event) {            var x = event.pageX;            var y = event.pageY;            var X = x - $(&quot;.box&quot;).offset().left;            var Y = y - $(&quot;.box&quot;).offset().top;            $(&quot;.box&quot;).html(X + &quot; &quot; + Y);        })    })&lt;/script&gt;</code></pre><hr><h3 id="8-放大镜案例（放大图片）案例"><a href="#8-放大镜案例（放大图片）案例" class="headerlink" title="8.放大镜案例（放大图片）案例"></a>8.放大镜案例（放大图片）案例</h3><pre><code>&lt;style&gt;    .product {        width: 350px;        height: 350px;        border: 1px solid #000;        margin: 100px;        float: left;        position: relative;        /*父相子绝*/    }    .follow {        width: 150px;        height: 150px;        position: absolute;        background: #daa520;        left: 0;        top: 0;        opacity: 0.5;        cursor: move;        display: none;    }    .bigpic {        width: 350px;        height: 350px;        float: left;        background: url(&quot;datu.jpg&quot;) no-repeat;        display: none;        position: absolute;        top: 100px;        left: 500px;    }&lt;/style&gt;&lt;div class=&quot;product&quot;&gt;    &lt;img src=&quot;xiaotu.jpg&quot; alt=&quot;&quot;&gt;    &lt;div class=&quot;follow&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;bigpic&quot;&gt;&lt;/div&gt;&lt;script&gt;    $(function () {        // $(&quot;.product&quot;).hover(function() {        //     $(this).children(&quot;.follow&quot;).show();        //     $(this).siblings(&quot;.bigpic&quot;).show();        // }, function() {        //     $(this).children(&quot;.follow&quot;).hide();        //     $(this).siblings(&quot;.bigpic&quot;).hide();        // })        var x = 0;        var y = 0;        $(&quot;.product&quot;).hover(function () {            $(this).children(&quot;.follow&quot;).toggle();            $(this).siblings(&quot;.bigpic&quot;).toggle();        });        // 鼠标移动效果        $(&quot;.product&quot;).mousemove(function (event) {            x = event.pageX - $(this).offset().left - $(&quot;.follow&quot;).width() / 2;            y = event.pageY - $(this).offset().top - $(&quot;.follow&quot;).height() / 2;            // 判断 follow在盒子里面            if (x &lt; 0) {                x = 0;            } else if (x &gt; 200) {                x = 200;            }            if (y &lt; 0) {                y = 0;            } else if (y &gt; 200) {                y = 200;            }            $(this).children(&quot;.follow&quot;).css({                &quot;left&quot;: x,                &quot;top&quot;: y            });            var bigpicX = -x * (800 / 350);            var bigpicY = -y * (800 / 350);            $(this).siblings(&quot;.bigpic&quot;).css(&quot;background-position&quot;, &quot;&quot; + bigpicX + &quot;px &quot; + bigpicY +                &quot;px&quot;);        })    })&lt;/script&gt;</code></pre><hr><h3 id="9-div中添加其他的页面（添加内容）"><a href="#9-div中添加其他的页面（添加内容）" class="headerlink" title="9.div中添加其他的页面（添加内容）"></a>9.div中添加其他的页面（添加内容）</h3><pre><code>&lt;script&gt;    $(&#39;#id&#39;).load(&#39;./1.html&#39;); //添加进内容&lt;/script&gt;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript加深学习笔记</title>
      <link href="/2020/01/13/javascript-jia-shen-xue-xi-bi-ji/"/>
      <url>/2020/01/13/javascript-jia-shen-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript加深学习笔记"><a href="#JavaScript加深学习笔记" class="headerlink" title="JavaScript加深学习笔记"></a>JavaScript加深学习笔记</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="1-其他数据类型转换为Boolean（-）"><a href="#1-其他数据类型转换为Boolean（-）" class="headerlink" title="1.其他数据类型转换为Boolean（!!）"></a>1.其他数据类型转换为Boolean（!!）</h3><pre><code>    在谷歌打印台(!!)号 输入(!![{name:&#39;小明&#39;},{name:&#39;小李&#39;}])打印true    (!!)号控制台 数据类型转换的时候：将其他数据类型转换为Boolean的时候的隐式转换的方式</code></pre><hr><h3 id="2-javascript-三部分组成"><a href="#2-javascript-三部分组成" class="headerlink" title="2.javascript 三部分组成"></a>2.javascript 三部分组成</h3><pre><code>     三部分组成：行内式，内嵌式和外链式</code></pre><hr><h3 id="3-javaScript-变量类型"><a href="#3-javaScript-变量类型" class="headerlink" title="3..javaScript 变量类型"></a>3..javaScript 变量类型</h3><pre><code>    var obj = null;    console.log(typeof obj); // 打印的Object对象</code></pre><hr><h3 id="4-undefined-未定义"><a href="#4-undefined-未定义" class="headerlink" title="4.undefined 未定义"></a>4.undefined 未定义</h3><pre><code>     undefined未定义,声明一个变量,没有赋值</code></pre><hr><h3 id="5-小数相加（隐藏bug）"><a href="#5-小数相加（隐藏bug）" class="headerlink" title="5.小数相加（隐藏bug）"></a>5.小数相加（隐藏bug）</h3><pre><code>    var result = 0.1 + 0.2    console.log(result); // 0.3000000000004    // number:我们的js语言是不区分小数和整数，不管是小数还是整数都是number    var num1 = 88;    var num2 = 88.88;    console.log(typeof num1);    console.log(typeof num2);</code></pre><hr><h3 id="6-JS的基本数据类型"><a href="#6-JS的基本数据类型" class="headerlink" title="6.JS的基本数据类型"></a>6.JS的基本数据类型</h3><pre><code>    JS的基本数据类型：number、string、boolean、null、undefined--未定义</code></pre><hr><h3 id="7-注释"><a href="#7-注释" class="headerlink" title="7.注释"></a>7.注释</h3><pre><code>    /* alt+shift+a 多行注释*/    // var x = 10;  记住这个就够了 ctrl + / 反斜杠 </code></pre><hr><h3 id="8-NaN问题"><a href="#8-NaN问题" class="headerlink" title="8.NaN问题"></a>8.NaN问题</h3><pre><code>    // 一个数字 和undefined相加是 NaN    // 不要用NaN判断和NaN是否相等; NaN 与任何值都不相等的，包括他本身    // 如果是数字返回false,不是数字返回true    var age = 18;    console.log(isNaN(age)); // false    var bb;    console.log(isNaN(bb)); // true</code></pre><hr><h3 id="9-字符串拼接"><a href="#9-字符串拼接" class="headerlink" title="9.字符串拼接"></a>9.字符串拼接</h3><pre><code>    // 减 乘 除（遇到数字的字符串）会隐式转换（除+号回拼接）    var age1 = 10;    var age2 = &quot;5&quot;;    console.log(age1 - age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）    console.log(age1 * age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）    console.log(age1 / age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）    var aa = 250;    var bb = &quot;250&quot;;    console.log(aa + bb); // 250250</code></pre><hr><h3 id="10-boolean-和-undefind-（true-1-，false-0）"><a href="#10-boolean-和-undefind-（true-1-，false-0）" class="headerlink" title="10. boolean 和 undefind （true 1 ，false 0）"></a>10. boolean 和 undefind （true 1 ，false 0）</h3><pre><code>    // boolean:布尔类型就两个结果，true和false（在做算术运算的时候true当1看，false当0看）    var flag = true;    console.log(flag);    // null就是接收了一个null的赋值    var nll = null;    console.log(nll);    // undefined 声明一个变量，没有赋值那么他就是undefined    var age;    console.log(age);</code></pre><hr><h3 id="11-数值转换-三个"><a href="#11-数值转换-三个" class="headerlink" title="11.数值转换 三个"></a>11.数值转换 三个</h3><pre><code>    1.parseInt()  2.parseFloat() 3.Number()    // 如果想就转换整数就用parseInt()    // 如果想转换小数就用 parseFloat()    // Number()只转换数字，只要遇到字母就是NaN    console.log(parseInt(&quot;10&quot;)); // 10    console.log(parseInt(&quot;10abcdefg&quot;)); // 10    console.log(parseInt(&quot;g10sdfsdfs&quot;)); // NaN    console.log(parseInt(&quot;1sadfasdf&quot;)); // 1    console.log(parseInt(&quot;10.98&quot;)); // 10    console.log(parseInt(&quot;10.98asdfsdfs&quot;)); // 10    // parseFloat()转换小数----浮点型    console.log(&quot;=======&quot;);    console.log(parseFloat(&quot;10&quot;)); // 10    console.log(parseFloat(&quot;10abcdefg&quot;)); // 10    console.log(parseFloat(&quot;g10sdfsdfs&quot;)); // NaN    console.log(parseFloat(&quot;1sadfasdf&quot;)); // 1    console.log(parseFloat(&quot;10.98&quot;)); // 10.98    console.log(parseFloat(&quot;10.98asdfsdfs&quot;));// 10.98    console.log(&quot;==========&quot;);    console.log(Number(&quot;10&quot;)); // 10    console.log(Number(&quot;10abcdefg&quot;)); // NaN    console.log(Number(&quot;g10sdfsdfs&quot;)); // NaN    console.log(Number(&quot;1sadfasdf&quot;)); // NaN    console.log(Number(&quot;10.98&quot;)); // 10.98    console.log(Number(&quot;10.98asdfsdfs&quot;)); // NaN</code></pre><hr><h3 id="12-转义字符"><a href="#12-转义字符" class="headerlink" title="12.转义字符"></a>12.转义字符</h3><pre><code>    // 要求掌握转义符    \\&#39;    \\&quot;    \t    \n    四个的用法    console.log(&quot;哈哈\t嘎嘎&quot;); // 空格    console.log(&quot;哈哈\n嘎嘎&quot;); // 换行    console.log(&quot;哈哈\&quot;嘎嘎&quot;);    console.log(&quot;哈哈\&#39;嘎嘎&quot;);</code></pre><hr><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-显示对话框-prompt-“您觉得我帅吗-y-n”"><a href="#1-显示对话框-prompt-“您觉得我帅吗-y-n”" class="headerlink" title="1.显示对话框( prompt(“您觉得我帅吗?y/n”))"></a>1.显示对话框( prompt(“您觉得我帅吗?y/n”))</h3><pre><code>    // 使用do-while循环:问用户:您觉得我帅吗?提示用户请输入y/n ,如果n就一直问,我帅不帅,如果用户输入的y,则结束,并提示用户,您真有眼光。    do {        var result = prompt(&quot;您觉得我帅吗?y/n&quot;);    } while (result != &quot;y&quot;);    console.log(&quot;您真有眼光&quot;);</code></pre><hr><h3 id="2-转换字符串类"><a href="#2-转换字符串类" class="headerlink" title="2.转换字符串类"></a>2.转换字符串类</h3><pre><code>    toString() 和String()方法     null和undefined 是不能用toString()---null和undefined是没有意义的，所以是不能转换的。</code></pre><hr><h3 id="3-重点5个类型boolean默认为false-考点-其他的都是true（隐式转换"><a href="#3-重点5个类型boolean默认为false-考点-其他的都是true（隐式转换" class="headerlink" title="3.重点5个类型boolean默认为false(考点) 其他的都是true（隐式转换 )"></a>3.重点5个类型boolean默认为false(考点) 其他的都是true（隐式转换 )</h3><pre><code>    console.log(Boolean(0));  // false    console.log(Boolean(null)); // false    console.log(Boolean(undefined)); // false    console.log(Boolean(&quot;&quot;)); // false    console.log(Boolean(NaN)); // false    console.log(Boolean(Boolean(-1))); // true</code></pre><hr><h2 id="第三天（循环）"><a href="#第三天（循环）" class="headerlink" title="第三天（循环）"></a>第三天（循环）</h2><h3 id="1-面试坑-false默认为0"><a href="#1-面试坑-false默认为0" class="headerlink" title="1.(面试坑)false默认为0"></a>1.(面试坑)false默认为0</h3><pre><code>    var num = 0;    if(num){ // num = false; false默认数值为false        console.log(num); // 这个num不会输出    }</code></pre><hr><h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><pre><code>    1.先执行后判断    do{        counter += 1;    }while(counter &lt;= 100)    2.先判断后执行    var i = 0;    while(i &lt;= 9){        console.log(&#39;----&#39;)        i++;  //这是终止条件    }</code></pre><hr><h3 id="3-输出到页面"><a href="#3-输出到页面" class="headerlink" title="3.输出到页面"></a>3.输出到页面</h3><pre><code>    consle.log(&quot;---&quot;);    document.write(&quot;输出&quot;)； //不会换行</code></pre><hr><h3 id="4-continue的使用"><a href="#4-continue的使用" class="headerlink" title="4.continue的使用"></a>4.continue的使用</h3><pre><code>    var i = 0;    while (i &lt; 5) {        console.log(i);        // continue; // 加个continue直接就死循环了，小心面试坑!        i++;    }    求100-200之间所有的奇数的和（用continue）    var sum = 0;    var i = 1;    while (i &lt;= 10) {        // 判断        if (i % 2 == 0) {            i++;            continue;        }        sum += i;        i++;    }    console.log(&quot;100-200之间所有的奇数的和:&quot; + sum);</code></pre><hr><h3 id="5-数组求和"><a href="#5-数组求和" class="headerlink" title="5.数组求和"></a>5.数组求和</h3><pre><code>    var arr1 = [10, 20, 30, 40, 50];    var sum = 0;    for (var i = 0; i &lt; arr1.length; i++) {        sum += arr1[i];    }    console.log(&quot;组中所有元素的和：&quot; + sum);</code></pre><hr><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="1-九九乘法表"><a href="#1-九九乘法表" class="headerlink" title="1.九九乘法表"></a>1.九九乘法表</h3><pre><code>    document.write(&quot;&lt;table border = &#39;1&#39; cellpadding= &#39;0&#39; cellspacing=&#39;0&#39;&gt;&quot;);    for (var i = 1; i &lt;= 9; i++) {        document.write(&quot;&lt;tr&gt;&quot;);        for (var j = 1; j &lt;= i; j++) {            document.write(&quot;&lt;td&gt;&quot;);            document.write(j + &quot;*&quot; + i + &quot;=&quot; + i * j);            document.write(&quot;&lt;/td&gt;&quot;);        }        document.write(&quot;&lt;/tr&gt;&quot;);    }    document.write(&quot;&lt;/table&gt;&quot;);</code></pre><hr><h3 id="2-数组倒装"><a href="#2-数组倒装" class="headerlink" title="2.数组倒装"></a>2.数组倒装</h3><pre><code>    var arr = [10,1,2,3,9,1];    for(var i = 0; i &lt; arr.length / 2; i++){  //交换一半5的话是2        var temp = arr[i];        arr[i] = arr[arr.length - 1 - i];        arr[arr.length - 1 - i] = temp;    }</code></pre><hr><h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h3><pre><code>    var arr=[10,1,3];    //比较的轮数    for(var i = 0;i &lt;arr.length - 1; i++){        //比较的次数        for(var j = 0; j&lt;arr.length - 1 - i; j++){           if(arr[j] &gt; arr[j + 1]){               var tem =arr[j];               arr[j] = arr[j + 1]               arr[j + 1] = tem;           }       }    }    console.log(arr);</code></pre><hr><h3 id="4-定义函数"><a href="#4-定义函数" class="headerlink" title="4.定义函数"></a>4.定义函数</h3><pre><code>    function 函数名(形参1, 形参2, 形参...){        //函数体 return 值;    }</code></pre><hr><h3 id="5-函数的形参和实参个数不等"><a href="#5-函数的形参和实参个数不等" class="headerlink" title="5.函数的形参和实参个数不等"></a>5.函数的形参和实参个数不等</h3><pre><code>    //第一种情况：如果实参的个数大于形参的个数，那么多余的实参会被丢弃。    //第二种情况：如果实参的个数小于形参的个数，那么结果是NaN，因为是数字 + undefined = NaNnotanumber</code></pre><hr><h3 id="6-对话输入框并转换"><a href="#6-对话输入框并转换" class="headerlink" title="6.对话输入框并转换"></a>6.对话输入框并转换</h3><pre><code>    function he (x, y){        var sum = x + y;        console.log(sum);    }    var num1 = parseInt(prompt(&quot;输入第一个数字&quot;));    var num2 = parseInt(prompt(&quot;输入第二个数字&quot;));    he(num1, num2);</code></pre><hr><h3 id="7-调用方法接受"><a href="#7-调用方法接受" class="headerlink" title="7.调用方法接受"></a>7.调用方法接受</h3><pre><code>    var bb = config(x,y);</code></pre><hr><h3 id="8-什么会NAN"><a href="#8-什么会NAN" class="headerlink" title="8.什么会NAN"></a>8.什么会NAN</h3><pre><code>    数字 + undefined //结果是NaN</code></pre><hr><h3 id="9-什么情况下undefind"><a href="#9-什么情况下undefind" class="headerlink" title="9.什么情况下undefind"></a>9.什么情况下undefind</h3><pre><code>    1、如果函数中没有使用 return语句 ，那么函数有默认的返回值：undefined    2、如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined    3、如果函数使用 return语句，那么跟在return后面的值，就成了函数的返回值,里面的所有其他代码都不会再执行    4、函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。</code></pre><hr><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-Math内置对象-计算面积"><a href="#1-Math内置对象-计算面积" class="headerlink" title="1.Math内置对象(计算面积)"></a>1.Math内置对象(计算面积)</h3><pre><code>    Math.PI * r * r</code></pre><hr><h3 id="2-数组倒置函数"><a href="#2-数组倒置函数" class="headerlink" title="2.数组倒置函数"></a>2.数组倒置函数</h3><pre><code>    function reverseArr(arr){        for(var i = 0; i &lt; arr.length / 2; i++){            var temp = arr[i];            arr[i] = arr[arr.length - 1 - i];            arr[arr.length - 1 - i] = temp;        }        return arr;    };    var arr = [3,42,6,8,3];    var result = reverseArr(arr);    console.log(result);</code></pre><hr><h3 id="3-阶乘"><a href="#3-阶乘" class="headerlink" title="3.阶乘"></a>3.阶乘</h3><pre><code>    function jiecheng(num){        var value = 1;        for(var i = 1; i &lt;= num; i++){            value * = i        }        return value;    }    var value2 = jiecheng(5);    console.log(value2);</code></pre><hr><h3 id="4-布局的优先级"><a href="#4-布局的优先级" class="headerlink" title="4.布局的优先级"></a>4.布局的优先级</h3><pre><code>    首先考虑标准流，其次考虑浮动，最后考虑定位</code></pre><hr><h3 id="5-斐波那契数列-重点"><a href="#5-斐波那契数列-重点" class="headerlink" title="5.斐波那契数列(重点)"></a>5.斐波那契数列(重点)</h3><pre><code>    (兔子的规律为数列，1，1，2，3，5，8，13，21,34,55,89,144)     // 找规律----这个是属于算法---需要时间需理解    var num1 = 1;//第一个月    var num2 = 1;//第二个月    var sum = num1 + num2;//第三个月    // 模拟第四个月    var num1 = num2//第二个月    var num2 = sum;//第三个月    var sum = num1 + num2;//第四个月    // 继续模拟伪代码，就是我们推论的规律    var num1 = num2;    var num2 = sum;    var sum = num1 + num2;    var num1 = 1;    var num2 = 1;    var sum = 0; //总和    for (var i = 3; i &lt;= 12; i++) {        sum = num1 + num2;        num1 = num2;        num2 = sum;    }    console.log(&quot;12个月的斐波那契数列的和是:&quot; + sum);</code></pre><hr><h3 id="6-函数-arguments-伪数组"><a href="#6-函数-arguments-伪数组" class="headerlink" title="6.函数 arguments 伪数组"></a>6.函数 arguments 伪数组</h3><pre><code>    // 直接使用 i&lt; arguments.length;    function getSum() {        var sum = 0 ;        for(var i = 0; i &lt; arguments.length; i++){            sum += arguments[i];        }        return sum;    }    var result = getSum(23, 4, 56, 4);     console.log(result);     </code></pre><hr><h3 id="7-常规函数定义-（函数创建）"><a href="#7-常规函数定义-（函数创建）" class="headerlink" title="7.常规函数定义 （函数创建）"></a>7.常规函数定义 （函数创建）</h3><pre><code>    function fun() {        console.log(&quot;我就是命名函数，我是有函数名的。&quot;);    }    fun();</code></pre><hr><h3 id="8-匿名函数-记得加-分号-一般初始化（函数创建）"><a href="#8-匿名函数-记得加-分号-一般初始化（函数创建）" class="headerlink" title="8.匿名函数 (记得加 ;分号),一般初始化（函数创建）"></a>8.匿名函数 (记得加 ;分号),一般初始化（函数创建）</h3><pre><code>    1.带有变量名的    var age = 18;     var f1 = function(){}; // 匿名要加分号    f1(); // 函数执行加括号    window.onload = function(){} // 匿名函数最大    2.不带变量名的    ()(); // 这样定义，第一个括号填function(){}    (function(){        console.log(&quot;99iiii&quot;);    })();</code></pre><hr><h3 id="9-this关键字的讲解"><a href="#9-this关键字的讲解" class="headerlink" title="9.this关键字的讲解"></a>9.this关键字的讲解</h3><pre><code>    console.log(this); // 在全局作用域下this指向window    // 普通函数this指向window    function fun() {        console.log(this); // 普通函数里面的this也指向window    }    fun();</code></pre><hr><h3 id="10-作用域理解"><a href="#10-作用域理解" class="headerlink" title="10.作用域理解"></a>10.作用域理解</h3><pre><code>    作用域:全局作用域和局部作用域(或者说私有作用域)    全局作用域：(工作经验：网页一打开就形成了一个全局作用域)---函数外面都称为全局作用域;    全局变量:在全局作用域下面定义的变量叫做全局变量（函数外面定义的变量都叫做全局变量）    局部作用域:函数已执行就形成了局部作用域（也有人叫做私有作用域）    局部变量:在局部作用域下面定义的变量叫做局部变量（函数里面定义的变量叫做局部变量，形参也是局部变量）</code></pre><hr><h3 id="11-计算今天在这年中第多少天"><a href="#11-计算今天在这年中第多少天" class="headerlink" title="11.计算今天在这年中第多少天"></a>11.计算今天在这年中第多少天</h3><pre><code>    // 定义一个函数,输入某年某月某日,判断这一天是这一年的第几天？    // 假设我们输入的是2020-1-31    function getDays(year, month, day) { //year--年,month--月,--day天        // 先定义一个变量来存储天数        var days = day;        // 如果用户输入的时候一月份, 没有必要向后算天数，直接返回天数就ok了        if (month == 1) {            return days; // 函数里面遇到return后面代码不再执行了        }        // 如果代码继续往下执行了,说明用户输入的一定不是1月份,除了1月份的任意的其他月份2,3,4,5...12月        // 假设用户输入的是2020年4月1; 1月的天数+2月的天数+3月的天数+1天        // 1,3,5,7,8,10,12----31天; 2月是--28天; 4,6,9,11---30天        // 定义一个数组来存储每个月的天数        var months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];        // 如果用户输入的不是一月份,就要开始遍历循环数组把数组里面天数加起来        for (var i = 0; i &lt; month - 1; i++) {            days += months[i];        }        // 判断，记得上面要调用我们的公用文件publick.js        if (isLeapYear(year) &amp;&amp; month &gt; 2) {            days++; // 判断公式：是闰年并且大于2月才会加这一天         }        return days; // 返回值    }    var result = getDays(2020, 3, 2);    console.log(result);    // 判断闰年公式是公用文件只写一次下次就直接调用了    function isLeapYear(year) {        return year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;    }</code></pre><hr><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-预解析"><a href="#1-预解析" class="headerlink" title="1.预解析"></a>1.预解析</h3><p>可以参考 : <a href="https://blog.csdn.net/qq_43615908/article/details/86495976" target="_blank" rel="noopener">JavaScript中域解析的拆解</a></p><pre><code>域解析是指在正式执行js代码之前，进行的一些解析工作。他会在全局中寻找关键字var声明的变量和关键字function声明的函数。    </code></pre><pre><code>    1. 提升变量声明：把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。    2. 提升函数声明：把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</code></pre><hr><h3 id="2-js中同名的变量名"><a href="#2-js中同名的变量名" class="headerlink" title="2.js中同名的变量名"></a>2.js中同名的变量名</h3><pre><code>    1.变量和变量同名，解析之后只存在一个当前变量的声明    console.log(a); // undefined    var a = 123;    console.log(a); // 123    var a = 456;    console.log(a); // 456    2.函数名和变量名一样了，只提升函数，不提升变量var a,函数和变量同名，函数声明提升，忽略变量的声明    console.log(a); // 函数体    var a = 123;    console.log(a); // 123    function a() {} // 小心函数名和变量名一样了，只提升函数，不提升变量var a    3. 局部方法定义var 与不带var    // console.log(a); // undefined    // var a = 12;    // function fn() {    // console.log(a); // undefined    // var a = 13;    // }    // fn();    // console.log(a); // 12    //小心//    console.log(a); // undefined    var a = 12;    function fn() {        console.log(a); // 12        a = 13;    }    fn();    console.log(a) // 13    4.比较难理解    // 小心掉坑    var foo = 1;    function bar() {    // 不管条件成立还是不成立都要进行变量提升。  var foo; !undefind== true    console.log(undefind == false + &#39;---&#39;);       if (!foo) {           var foo = 10;       }       console.log(foo);    }    bar(); // 10    5.比较难理解    var a;    console.log(a); // undefined    a = 12;    function fn(a) {       console.log(a); // 12       a = 13; // 虽然没有var但是是形参，形参也是局部变量，修改私有的,不会修改全局的    }    fn(a);    console.log(a); // 12</code></pre><hr><h3 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链:"></a>3.作用域链:</h3><pre><code>    // 作用域链:我们的作用域链是从里往外一层一层查找，这种查找机制叫做作用域链。    var num = 10;        function fun1() {            //var num = 20;            function fun2() {                //var num = 30;                function fun3() {                    //var num = 50;                    console.log(num);                }                fun3();            }            fun2();        }    fun1();    结果：10</code></pre><hr><h3 id="4-清空控制台"><a href="#4-清空控制台" class="headerlink" title="4.清空控制台"></a>4.清空控制台</h3><pre><code>    console.clear()</code></pre><hr><h3 id="5-全局变量的理解（注意重点）"><a href="#5-全局变量的理解（注意重点）" class="headerlink" title="5.全局变量的理解（注意重点）"></a>5.全局变量的理解（注意重点）</h3><pre><code>    // 在函数里面只要var了，就不会修改全局的, 函数里面变量没有var及没有形参 ,可以修改全局,这么理解    console.log(a, b, c); // undefind    var a = 10,        b = 20,        c = 30;    function f(a){        var b;        console.log(a, b, c);  // 10 undefind 30        b = a = c = 100;        console.log(a, b, c) // 100，100 ，100    }        f(10, 20); // 多余的实参丢掉    console.log(a, b, c); // 10 20 100</code></pre><hr><h3 id="6-拆解var-a-b-constant的声明与赋值"><a href="#6-拆解var-a-b-constant的声明与赋值" class="headerlink" title="6.拆解var a = b = constant的声明与赋值"></a>6.拆解var a = b = constant的声明与赋值</h3><pre><code>    // var a = b = contant可拆解为:    var a;    b = contant;    a = b;</code></pre><hr><h3 id="7-函数名一样只会执行最后一个函数"><a href="#7-函数名一样只会执行最后一个函数" class="headerlink" title="7.函数名一样只会执行最后一个函数"></a>7.函数名一样只会执行最后一个函数</h3><pre><code>    function f() {        console.log(&quot;1&quot;);    }    function f() {        console.log(&quot;2&quot;);    }    function f() {        console.log(&quot;3&quot;);    }    f(); // 打印3</code></pre><hr><h3 id="8-查方法字典内置对象-Math"><a href="#8-查方法字典内置对象-Math" class="headerlink" title="8.查方法字典内置对象(Math)"></a>8.查方法字典内置对象(Math)</h3><p>1.参考资料 : <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN字典查询</a></p><pre><code>    1.最大值 Math.max(10,20,30,90,20)打印为90；    var arr = [2, 3, 47, 6];    2.数组最大值     Math.max(...arr);    3.取整数    parseInt();    案例：        //Math.ceil() 向上取整    console.log(Math.ceil(12.3));    console.log(Math.ceil(12.9));    console.log(Math.ceil(12.09));    console.log(Math.ceil(12.03));    console.log(Math.ceil(12.92));    // Math.floor() 向下取整    console.log(Math.floor(12.3));    console.log(Math.floor(12.9));    console.log(Math.floor(12.09));    console.log(Math.floor(12.03));    console.log(Math.floor(12.92));        // Math.max()/Math.min() 取最大和最小值    console.log(Math.max(10,1,9,100,200,45,78));    console.log(Math.min(10,1,9,100,200,45,78));    // Math.abs() 取绝对值    console.log(Math.abs(&#39;-1&#39;)); // 1    console.log(Math.abs(-2)); // 2    console.log(Math.abs(null)); // 0    console.log(Math.abs(&#39;string&#39;)); // NaN    console.log(Math.abs()); // NaN    //Math.power()、Math.sqrt() 求指数次幂/求平方根    console.log(Math.pow(2,4));    console.log(Math.sqrt(16));    //Math.round() 四舍五入     console.log(Math.round(20.49));    console.log(Math.round(20.5));    //随机数 获取一个0到1的随机浮点小数,包含0不包含1    parseInt(Math.random() * 100) + 1) 转换整数 //取1-100之间的数据    //生成随机数    Math.random() 生成随机数 获取一个0到1的随机的浮点数（小数）包含0不包含1 [0,1)    console.log(Math.random());    console.log(parseInt(Math.random() * 5 ) + 1);    console.log(parseInt(Math.random() * 100 ) + 1); // 1-100随机数</code></pre><hr><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><h3 id="1-运用递归计算1234数字的和"><a href="#1-运用递归计算1234数字的和" class="headerlink" title="1.运用递归计算1234数字的和"></a>1.运用递归计算1234数字的和</h3><pre><code>    function getSum(x){        if(x&lt;10){            return x;        }        return x % 10 + dg(parseInt(x / 10)); // 4444 / 10 = 444 444 % 10 = 4       }     var result = getSum(4444)    console.log(result);</code></pre><hr><h3 id="2-计算一个月份斐波那契（小兔子）"><a href="#2-计算一个月份斐波那契（小兔子）" class="headerlink" title="2.计算一个月份斐波那契（小兔子）"></a>2.计算一个月份斐波那契（小兔子）</h3><pre><code>    function getFib(x){        if(x == 1 || x == 2){            return 1;        }        return getFib(x - 1) + getFib(x - 2);    }    var result = getFib(3);    console.log(result);</code></pre><hr><h3 id="3-利用伪数组计算一组数中的最大值"><a href="#3-利用伪数组计算一组数中的最大值" class="headerlink" title="3.利用伪数组计算一组数中的最大值"></a>3.利用伪数组计算一组数中的最大值</h3><pre><code>    function getMax(){        var max = arguments[0];        for(var i = 0; i &lt; arguments.length; i++){                if(max &lt; arguments[i]){                    max = arguments[i];                }        }        return max;    }    // var list = [12, 34, 56, 78];    // var result =getMax(list); // 直接返回数组    var result =getMax(12, 67, 45, 36, 78); // 返回最大值    console.log(result); </code></pre><hr><h3 id="4-随机产生一个十六进制的颜色值（随机色）"><a href="#4-随机产生一个十六进制的颜色值（随机色）" class="headerlink" title="4.随机产生一个十六进制的颜色值（随机色）"></a>4.随机产生一个十六进制的颜色值（随机色）</h3><pre><code>    function getColor() {        var str = &quot;#&quot;;// 颜色以#开头        // 一个十六进制的值的数组        var arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];        for(var i = 0; i &lt; 6; i++){        // 产生的每个随机数都是一个索引,根据索引找到数组中对应的值,拼接到一起        var num = parseInt(Math.random() * 16);        str += arr[num];       }       return str; // 返回的是一个字符串类型的，因为有字母和数字    }    var result = getColor();    console.log(result);```***### 5.dom元素操作默认加载```    window.onload = function(){        document.getElementById(&quot;dv&quot;).style.backgroundColor = getColor();    }```***### 6.日期函数    ```    // 注意星期天 返回的是0;    // getFullYear() 返回4位的年份  如 2019    console.log(date.getFullYear());    // getMonth() 返回月份，从0开始 记得+1    console.log(date.getMonth());    // getDate() 返回当前月的第几天（日）    console.log(date.getDate());    // getDay() 返回星期几 0 表示周日，6 表示周六    console.log(date.getDay());    // getHours() 根据本地时间，返回一个指定的日期对象的小时数 0-23    console.log(date.getHours());    // getMinutes() 根据本地时间，返回一个指定的日期对象的分钟数。0-59    console.log(date.getMinutes());    // getSeconds() 根据本地时间，返回一个指定的日期对象的秒数。0-59    console.log(date.getSeconds());    ```***### 7.拼接今天的时间周几```    function getToday(today){        var y = today.getFullYear();        var m = today.getMonth() + 1;        var d = today.getDay();        var hour =today.getHours();        var minute = today.getMinutes();        var second = today.getSeconds();        var week = today.getDay(); // 返回的数字是4          switch(week){            case 1:                week = &quot;星期一&quot;;                break;            case 2:                week = &quot;星期二&quot;;                break;            case 3:                week = &quot;星期三&quot;;                break;            case 4:                week =&quot;星期四&quot;;                break;            case 5:                week =&quot;星期五&quot;;                break;            case 6:                week =&quot;星期六&quot;;                break;            case 0:                week =&quot;星期天&quot;;                break;        }    return y +&#39;年&#39;+ m +&#39;月&#39; + d +&#39;日&#39;+ hour +&#39;时&#39;+ minute + &#39;分&#39; + second + &#39;秒&#39;;    }    var today = getToday(new Date());    console.log(today);```***### 8.String类型```    // 1..length 字符串的长度    var str = &quot;hello word&quot;;    console.log(str.length); // 10    // 2.charAt(索引)，返回值是指定索引位置的字符串，超出索引，结果是空字符串    var str = &quot;hello word&quot;;    var result = str.charAt(1);    var result = str.charAt(5); // 这个超出了输出空字符串    console.log(result);    // 3.fromCharCode(数字值，可以是多个参数)，返回的是ASCII码对应的值    var str = String.fromCharCode(83, 79, 83);    console.log(str); //sos    // 4.concat(字符串，字符串)，返回拼接新的字符串    var str1 = &quot;我们&quot;；    var str1 = str1.concat(&quot;,她们！&quot;)；    console.log(str1);    // 5.indexOf(要找的字符串,从某个位置开始) 返回的是这个字符串的索引值，没找到返回-1，第二个参数可以不要    var str = &quot;我们今天真开心&quot;;    var index = str.indexOf(&quot;真&quot;, 5); // 从下表5开始，找‘真’    var index = str.indexOf(&quot;真开&quot;); // 返回第一个&#39;真&#39;索引值    console.log(index); // 返回-1，因为从第5个开始后面就没有真，如果不写后面的5结果就是4正好是真的索引位置    // 6.lastIndexOf(要找的字符串) 从后往前找，但是索引仍然是从左向右的方式，找不到则返回-1;    var str = &quot;hello word&quot;;    var index = str.lastIndexOf(&quot;o&quot;);    console.log(index); // 返回结果7，从后面往前找到后面的那个o    // 7.replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;);用来替换字符串的    var str = &quot;小明真的好帅哦，真的好勇敢哦&quot;;    // 寻找带‘帅’；没有返回-1    if (str.indexOf(&quot;帅&quot;) != -1) {        str = str.replace(&quot;帅&quot;, &quot;丑&quot;);    } else {        console.log(&quot;不存在&quot;);    }    console.log(str);    // 8.slice(开始的索引，结束的索引) 从索引5的位置开始提取(截取)，到索引10的前一个结束，没有10，返回这个提取后的字符串    var str = &quot;如果有一天我邪恶了,请记住,我曾纯洁过&quot;;    str = str.slice(5, 10);    console.log(str);    // 9.split(&quot;以什么字符串拆分&quot;,拆分后留下的字符个数);后面参数    可以省略，直接以什么字符串拆分，他是把字符串以指定的字符    拆分成数组    var str = &quot;乔峰|慕容|凤姐|梅超风|小苏|大蛇丸&quot;;    var arr = str.split(&quot;|&quot;);    console.log(arr); // [&quot;乔峰&quot;, &quot;慕容&quot;, &quot;凤姐&quot;, &quot;梅超风&quot;, &quot;小苏&quot;, &quot;大蛇丸&quot;]    // 10.substr(开始的位置，个数) 返回的是截取后的新的字符串,个数也可以省略，就是从什么位置开始截取到最后    .substring(开始的索引， 结束的索引)， 返回截取后的字符串， 不包含结束的索引字符串    var str = &quot;哈哈,小明真的是好帅哦&quot;;    str = str.substr(5, 5);    console.log(str); // 真的是好帅    //11.substring(开始的索引，结束的索引)，返回截取后的字符串，不包含结束的索引字符串    var str = &quot;哈哈,小明真的是好帅哦&quot;;    str = str.substring(5, 9);    console.log(str); // 真的是好    // 12.转换大小写    .toLowerCase();    // 转小写, 两个方法都是转小写。    .toLocaleLowerCase() // 转小写字母    var str = &quot;HELLO&quot;;    str = str.toLocaleLowerCase();    str = str.toLowerCase();    console.log(str);    .toLocaleUpperCase() // 转大写        .toUpperCase() // 转大写    var str = &quot;hello&quot;;    str = str.toLocaleUpperCase();    str = str.toUpperCase();    console.log(str);    // 13.trim() 删除两端空格,中间的空格是删除不了的    var str3 = &quot;  这是一个神奇的一天  哦我们学了很多很多内置对象  &quot;;    str3 = str3.trim();    console.log(str3);    // 14.案例2：找到字符串中所有的o的出现的位置    var str = &quot;hello wod odd ott fbo nhyo&quot;;    var index = 0;    var key = &quot;o&quot;;    while ((index = str.indexOf(key, index)) != -1) { // 如果是-1了，就表示找完了        console.log(index); // != -1表示找到了，找到立马给我弹出他所在的索引位置        //index += 1; // 这一定要会的        index += key.length; // 这个是扩展的（等价于index += 1）    }    // 15.查找指定的字符    // 案例1.截取字符串&quot;我爱中华人民共和国&quot;，中的&quot;中华&quot;    var str = &quot;我爱中华人民共和国&quot;;    var index = str.indexOf(&quot;中华&quot;);    // console.log(index);    str = str.substr(index, 2);    console.log(str);    // 16.String其他额外方法：    str.search(string): // 查找        str.substring(star, end): // 获取子字符串        str.charAt(i): // 获取某个字符        str.split(“;”): // 分割字符串， 获得字符        str.match(re): // 以数组的形式返回匹配的字符串        str.replace(string, ‘abc’): // 替换字符串```***## 第八天    ### 1.数组的创建方式```    1.第一种    var array = [6];  // 长度为1，下标0为6    console.log(array);    或:    var arr = [1, 2, 3, 4, 5];    console.log(arr);    2.第二种    var array = new Array[6]; // 长度为6的数组    console.log(array);    或:    var arr = new Array(10, 20, 30, 40);    console.log(arr);```***### 2.判断对象是不是数组instanceof关键字和isArray()```    var array = new Array[6];    console.log(array);    1.第一种    console.log(array instanceof Array);    2.第二种    console.log(Array.isArray(arr));```***### 3.轮播图会用到的，数组操作（数组4种方法）```    1.push()  2.unshift()  3.pop()   4.shift()    // 1.push(值1,值2...);把值往数组后面添加、返回值是追加数据之后的数组长度，参数的数据类型不限;    var arr1 = [10, 20, 30, 40, 50];    var result = arr1.push(100, 200);    console.log(result, arr1); // 返回结果：[10, 20, 30, 40, 50, 100, 200]    // 2.unshift(值1,值2...)往数组前面添加，返回的是改变后的数组的长度参数数据类型不限;    var arr2 =[10, 20, 30, 40, 50];    var result = arr2.unshift(100, 200);    console.log(result,arr2); // 返回结果：[100, 200, 10, 20, 30, 40, 50]    // 3.pop()删除数组最后一项，参数无 返回值是删除的那一项;    var arr3 = [10, 20, 30, 40, 50];    var result = arr3.pop();    console.log(result, arr3); // 返回结果：50和[10, 20, 30, 40]    // 4.shift()删除数组第一项，参数无 返回值是删除的那一项;    var arr4 = [10, 20, 30, 40, 50];    var result = arr4.shift();    console.log(result, arr4); // 返回结果：10和[20, 30, 40, 50]```***### 4.数组方法索引查找```    // .indexOf(元素值)查看某个元素在数组里面的索引，如果没有这个元素返回值是-1    var arr2 = [10, 20, 30, 40, 50];    var index = arr2.indexOf(30);    console.log(index);    // 返回值是该元素在数组中的索引值，如果没有返回-1    indexOf（n，m）// 从索引m开始查看n在数组里面的索引值    lastIndexOf（）// 从后往前看```***### 5.数组中元素拼接```    // join(&quot;字符串&quot;)把数组按照指定的字符串拼接成一个字符串,如果没有参数就按默认的逗号拼接成字符串，如果有参数就按照指定的字符串拼接成字符串    var arr2 = [&quot;小白&quot;, &quot;小黑&quot;, &quot;小红&quot;, &quot;小芳&quot;, &quot;小绿&quot;, &quot;小花&quot;];    var str = arr2.join(&quot;|&quot;);    console.log(str);```***### 6.数组反转```    // reverse() 数组反转 参数无 返回值是反转后的数组，(改变原有数组)    var arr3 = [10, 20, 30, 40, 50];    var temp = arr3.reverse(); // 反转    console.log(temp,arr3); // [50, 40, 30, 20, 10]两个结果一样```***### 7.数组排序```    // 1.sort()数组排序 返回值是排好序的数组，改变原有数组。参数可传可不传，如果传参数，参数是回调函数。如果不传参数的时候只能排10以内的数字    // 不传参数的sort（）排序----从小到大    var ary = [1, 2, 3, 6, 5, 4];    var temp = ary.sort();    console.log(temp); // 结果：[1, 2, 3, 4, 5, 6]    console.log(ary); // 结果：[1, 2, 3, 4, 5, 6]    // 2.升序降序(数组排序)    // sort（）带有参数的升序和降序（超过10的数需要匿名函数调用）    // 2.1、从小到大排序 a-b    var ary = [1, 2, 3, 6, 5, 4, 13, 12, 15, 16];    var temp = ary.sort(function (a, b) {        return a - b; // 把原数组升序排 从小到大    });    console.log(temp); // 结果：[1, 2, 3, 4, 5, 6, 12, 13, 15, 16]    // 2.2、从大到小排列 b-a    var temp = ary.sort(function (a, b) {        return b - a;    });    console.log(temp); // 结果：[16, 15, 13, 12, 6, 5, 4, 3, 2, 1]```***### 8.数组索引查找(都是将原数复制一份)```    // slice（n, m）从索引n开始获取到索引m（不包含m）返回值是获取到的元素组成的新数组    var ary = [10,20,30,40,50,60,70,80,90,100];    var temp = ary.slice(2, 6);    console.log(temp); // 结果是[30, 40, 50, 60] 从索引2开始获取到索引6不包括索引6    //注意：slice();和slice(0);都是把原数组复制一份```***### 9.将数组替换删除元素（splice）放置顺序（删除数组）增删改查```    // 1.splice(n,m,x/y/z...) 把数组从索引n开始删除m个元素，用x，y...替换删除的m项。返回值是删除的m项组成的新数组    var ary = [1, 2, 3, 4, 5, 6];    var temp = ary.splice(1, 2, 7, 8, 9, 10);    console.log(temp); // 返回结果是：[2, 3]这个是删除的项组成的新数组，就是删除了2，3    console.log(ary); // 返回结果是：[1, 7, 8, 9, 10, 4, 5, 6]    // 2.当m项是0的时候，它把x,y...替换项放到索引n的前面    var ary = [1, 2, 3, 4, 5, 6];    var temp = ary.splice(1, 0, 7, 8, 9, 10);    console.log(temp); // [] 返回空数组，因为没有删除    console.log(ary); // 结果：[1, 7, 8, 9, 10, 2, 3, 4, 5, 6]    // 3.当不写x、y替换项的时候代表删除数组的元素    var ary = [1, 2, 3, 4, 5];    var temp = ary.splice(1, 2);    console.log(temp); // 结果：[2, 3]    console.log(ary); // 结果：[1, 4, 5]    // 4.当splice（）里面什么都不写的时候，代表没有对数组做任何操作，返回一个空数组    var ary = [1, 2, 3, 4, 5];    var temp = ary.splice();    console.log(temp); // 结果：[]    console.log(ary); // 结果：[1, 2, 3, 4, 5]    // 5.当splice(0)  里面是0 的时候，代表删除整个数组，返回的是原数组的数据，原数组变为空数组    var ary = [1, 2, 3, 4, 5];    var temp = ary.splice(0);    console.log(temp); // 结果： [1, 2, 3, 4, 5]    console.log(ary); // 结果：[]原数组变为空数组    // 6.替换    var str = &quot;hello&quot;;    str = str.replace(&quot;he&quot;, &#39;HHH&#39;)    console.log(str);```***### 10一个对象&amp;&amp;true```    // 如果是一个对象&amp;&amp;true,那么结果是true    var flag = new Boolean(false);    var result = flag &amp;&amp; true;    console.log(result); // 返回true    // 如果是一个true&amp;&amp;对象,那么结果是对象    var flag = new Boolean(false);    var result = true &amp;&amp; flag;    console.log(result); // 返回对象```***# WebAPI阶段## 第一天 document### 1.WebApi```WebApi就是浏览器给我们提供一系列用来操作DOM和BOM的接口```***### 2.打印输出命令```    1.console.log()；    2.console.dir(); // 打印对象的方法和属性```***### 3.js的书写位置？```    body结束前面```***### 4.选择器```    1. 根据id获取元素    document.getElementById(&quot;id名称&quot;)  // 返回不存在null    2.根据类名获取元素    document.getElementsByClassName(&quot;类名&quot;) // 返回不存在空数组    3.根据标签名获取元素    document.getElementsByTagName(&quot;div&quot;) // 返回伪数组 （浏览器兼容问题）    例子：    &lt;input type = &quot;text&quot; name = &quot;user&quot;&gt;    var input = document.getElementsByTagName(&quot;user&quot;);    console.log(input);    4.根据标签名    &lt;input type = &quot;checkbox&quot; name = &quot;check&quot;&gt;    document.getElementsByName(&quot;check&quot;); // 数组集合（浏览器兼容问题）    5.根据选择器获取（单元素）css选择器（返回伪数组）    返回值：        查找成功，返回 选择器规则的第一个元素        查找失败，返回 null    1.案例1:    &lt;div class = &quot;box&quot;&gt;&lt;/div&gt;    var box = document.querySelector(&#39;.box&#39;); // 返回第一个(&lt;div class = &quot;box&quot;&gt;&lt;/div&gt;)    2.案例2：    &lt;ul&gt;        &lt;li&gt;&lt;a&gt;测试&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    var box = document.querySelector(&#39;ul li a&#39;)    6.根据选择器获取（多个元素），如果没有找到返回空数组  css选择器    返回值：    查找成功，返回 选择器规则的全部元素，伪数组，有索引值，有长度，可以遍历    查找失败，返回 空集合伪数组，length 为 0，集合中没有元素    伪数组无法直接操作，需要通过索引取到元素才能操作。    document.querySelectorAll(&#39;选择器&#39;)```***### 5.注册事件```    &lt;input type=&quot;button&quot; name=&quot;name&quot; value=&quot;按钮&quot; class=&quot;anniu&quot;/&gt;    &lt;script&gt;    // 获取元素    var query = document.querySelector(&#39;.anniu&#39;);    console.log(query);    // 获取Body    var body = document.body;    // 注册事件    query.onclick = function () {        body.style.backgroundColor = &#39;rgb(255,1,255)&#39;    };    &lt;/script&gt;    练习1:点击按钮禁用和启用    &lt;input type = &quot;button&quot; value = &quot;点击禁用文本框&quot; id = &quot;btn1&quot;&gt;    &lt;input type = &quot;button&quot; value = &quot;点击启用文本框&quot; id = &quot;btn2&quot;&gt;    &lt;input type = &quot;button&quot; value = &quot;禁用或者启用&quot; id = &quot;btn3&quot;&gt;    &lt;input type = &quot;text&quot; name = &quot;&quot; id = &quot;text&quot;&gt;    &lt;script&gt;        var btn1 = document.getElementById(&#39;btn1&#39;);        var btn2 = document.getElementById(&#39;btn2&#39;);        var btn3 = document.getElementById(&#39;btn3&#39;);        var text = document.getElementById(&#39;text&#39;);        // 注册事件        btn1.onclick = function () {            text.disabled = true;        }        btn2.onclick = function () {            text.disabled = false;        }        btn3.onclick = function () {            text.disabled = !text.disabled;        }    &lt;/script&gt;    练习2：密码的显示和隐藏    请输入密码：&lt;input type = &quot;password&quot; id = &quot;text&quot; value = &quot;123456&quot;&gt;              &lt;input type = &quot;button&quot; id = &quot;btn&quot; value = &quot;显示密码&quot;&gt;    &lt;script&gt;        var pad = document.getElementById(&#39;text&#39;);        var btn = document.getElementById(&#39;btn&#39;);        // 定义变量默认true        var b1 = true;        //注册        btn.onclick = function(){            // 默认是隐藏密码            btn.value = b1 ? &#39;隐藏密码&#39; : &#39;显示密码&#39;;            pad.type = b1 ? &#39;text&#39; : &#39;password&#39;;            b1 = !b1;        }    &lt;/script&gt;    第二种:    if(btn.innerText == &#39;隐藏密码&#39;);    练习3：点击按钮切换图片    &lt;style&gt;        #div{            width: 600px;            margin: 100px auto;            /* border: 1px solid #000; */        }        img{            width: 600px;        }    &lt;/style&gt;    &lt;div id=&quot;div&quot;&gt;        &lt;input type = &quot;button&quot; value = &quot;按钮1&quot; alt = &quot;./images/01.jpg&quot;/&gt;        &lt;input type = &quot;button&quot; value = &quot;按钮2&quot; alt = &quot;./images/02.jpg&quot;/&gt;        &lt;input type = &quot;button&quot; value = &quot;按钮3&quot; alt = &quot;./images/03.jpg&quot;/&gt;        &lt;input type = &quot;button&quot; value = &quot;按钮4&quot; alt = &quot;./images/04.jpg&quot;/&gt;        &lt;img src = &quot;./images/01.jpg&quot; alt = &quot;&quot; id = &quot;img&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        var img = document.getElementById(&quot;img&quot;);        var inputList = document.getElementsByTagName(&#39;input&#39;);        for(var i = 0;i &lt; inputList.length; i++){            inputList[i].onclick = function(){                img.src = this.alt;            }        }    &lt;/script&gt;```***## 第二天### 1.元素的属性```    type、name、checked、src、href、alt 这些事元素的属性```***### 2.获取元素的class(注意点)```    console.log（input1.className）; 这样获取类名    console.log（input1.value）; //获取值```***### 3.js是指标准属性 三个比较特殊（单选赋值、checked、selected、 disabled）```    1.单选：    &lt;input type = &quot;radio&quot; checked&gt;    &lt;script&gt;    var input = document.querySelector(&#39;input&#39;);    input.checked = true;    input.checked = false;    &lt;/script&gt;    2.多选：    &lt;select name = &quot;&quot; id = &quot;&quot;&gt;    &lt;option value = &quot;&quot;&gt;北京&lt;/option&gt;    &lt;option value = &quot;&quot; selected class = &quot;gd&quot;&gt;广东&lt;/option&gt;    &lt;/select&gt;    &lt;script&gt;            var selt = document.querySelector(&#39;select .gd&#39;);        console.log(selt.selected);        selt.selected = false;    &lt;/script&gt;    3.不可更改灰色：    &lt;!-- 如果表单元素设置了disable的属性，表示这个表单元素被禁用 --&gt;    &lt;input type = &quot;text&quot; class = &quot;txt&quot; disabled&gt;       var txt = document.querySelector(&#39;.txt&#39;);    console.log(txt.disabled);    console.log(document.querySelector(&#39;.txt&#39;).disabled = false);```***### 4.innerHTML和innerText两个属性（获取不到用value）```    innerHTML:可以获取到标签    innerText:只能获取文本内容```***### 5.路src的设置```    img.src = &#39;../img/02.jpg&#39;; //设置是相对路径    获取到的是绝对路径```***### 6.案例表格的多选```&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;            &lt;input type = &quot;checkbox&quot; name = &quot;&quot; id = &quot;checkAll&quot; /&gt;全选/全不选        &lt;/th&gt;        &lt;th&gt;菜名&lt;/th&gt;        &lt;th&gt;商家&lt;/th&gt;        &lt;th&gt;价格&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;        &lt;/td&gt;        &lt;td&gt;红烧肉&lt;/td&gt;        &lt;td&gt;隆江猪脚饭&lt;/td&gt;        &lt;td&gt;￥200&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;        &lt;/td&gt;        &lt;td&gt;香酥排骨&lt;/td&gt;        &lt;td&gt;隆江猪脚饭&lt;/td&gt;        &lt;td&gt;￥998&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;        &lt;/td&gt;        &lt;td&gt;北京烤鸭&lt;/td&gt;        &lt;td&gt;隆江猪脚饭&lt;/td&gt;        &lt;td&gt;￥88&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;script&gt;    var checkAll = document.getElementById(&quot;checkAll&quot;);    var checks = document.getElementsByName(&quot;check&quot;);    // 全选状态    checkAll.onclick = function () {        var statu = this.checked;        for (var i = 0; i &lt; checks.length; i++) {            checks[i].checked = statu;        }    }    // 下面的多选框的点击事件    for (var i = 0; i &lt; checks.length; i++) {        checks[i].onclick = function () {            // 判断多个多选框是否同时成立(勾上)            var flag = true;            for (var j = 0; j &lt; checks.length; j++) {                // 如果有某一个没有勾上，假设不成立                // if(checks[j].checked == false){                if (!checks[j].checked) {                    flag = false;                    break;                }            }            // 判断假设是否仍然成立            if (flag) {                // 如果成立，让全选勾上                checkAll.checked = true;            } else {                // 否则，让全选不勾                checkAll.checked = false;            }            // 全选按钮            checkAll.checked = flag;        }    }&lt;/script&gt;```***### 7.自定义属性```    命名规则：data-* * 自定义属性的名称    获取自定义属性值：    元素对象.dataset.属性名    设置属性值：元素对象.dataset.属性名 = 值    案例1：方法中设置            &lt;input type = &quot;text&quot; name = &quot;input&quot; id = &quot;&quot;&gt;        var input = document.querySelector(&#39;input&#39;);        input.dataset.box = &#39;我是新来的&#39;;        console.dir(input);    案例2：    &lt;input type = &quot;text&quot; name = &quot;input&quot; id = &quot;&quot; data-box = &quot;或这样定义&quot;&gt;        &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;images/01.jpg&quot;&gt;```***### 8.自定义属性按钮图片切换```    &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;./images/01.jpg&quot;/&gt;    &lt;input type = &quot;button&quot; value = &quot;美女2&quot; data-src = &quot;./images/02.jpg&quot;/&gt;    &lt;input type = &quot;button&quot; value = &quot;美女3&quot; data-src = &quot;./images/03.jpg&quot;/&gt;    &lt;input type = &quot;button&quot; value = &quot;美女4&quot; data-src = &quot;./images/04.jpg&quot;/&gt;    &lt;input type = &quot;button&quot; value = &quot;美女5&quot; data-src = &quot;./images/05.jpg&quot;/&gt;    &lt;img src = &quot;./images/01.jpg&quot; alt = &quot;&quot; id = &quot;img&quot;/&gt;    &lt;script&gt;    // 获取所有的按钮和图片对象    var btns = document.querySelectorAll(&#39;input&#39;)    // 获取图片对象    let img = document.querySelector(&#39;#img&#39;)    // 给每个按钮注册点击事件    for (let i = 0; i &lt; btns.length; i++) {        btns[i].onclick = function () {            let src = this.getAttribute(&#39;data-src&#39;)            // console.log(src);            img.setAttribute(&#39;src&#39;, src)        }    }    &lt;/script&gt;```***### 9.ES6写法拼接字符串(模版字符串)ESC键下的波浪符```    console.log(~我叫${name}~);```***### 10.ES6写法拼接字符串(模版字符串换行)ESC键下的点```    var str = `我是中国人`    console.log(str);```***### 11.伪数组转换为真数组```    Array.from(&quot;&quot;);```***### 12.排他思想(tab切换选项)```    &lt;div class = &quot;wrapper&quot;&gt;    &lt;ul class = &quot;tab&quot;&gt;        &lt;li class = &quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;男士精品&lt;/li&gt;    &lt;/ul&gt;    &lt;div class = &quot;products&quot;&gt;        &lt;div class = &quot;main selected&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guojidapai.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class = &quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guozhuangmingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class = &quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/qingjieyongpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class=&quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/nanshijingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var lis = document.getElementsByClassName(&quot;tab-item&quot;);    var mains = document.getElementsByClassName(&quot;main&quot;);    for (var i = 0; i &lt; lis.length; i++) {        lis[i].index = i;        lis[i].onmouseover = mouseOverHandle;    }    function mouseOverHandle() {        // 排它思想        for (var j = 0; j &lt; lis.length; j++) {            lis[j].className = &quot;tab-item&quot;;        }        this.className = &quot;tab-item active&quot;;        for (var k = 0; k &lt; mains.length; k++) {            mains[k].className = &quot;main&quot;;        }        mains[this.index].className = &quot;main selected&quot;;    }&lt;/script&gt;```***### 13.（onmouseover）鼠标指针移动到指定的对象上时触发事件（鼠标指针事件tab切换选项）```    &lt;style type = &quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    .wrapper {        width: 1000px;        height: 475px;        margin: 0 auto;        margin-top: 100px;    }    .tab {        border: 1px solid #ddd;        border-bottom: 0;        height: 36px;        width: 320px;    }    .tab li {        position: relative;        float: left;        width: 80px;        height: 34px;        line-height: 34px;        text-align: center;        cursor: pointer;        border-top: 4px solid #fff;    }    .tab span {        position: absolute;        right: 0;        top: 10px;        background: #ddd;        width: 1px;        height: 14px;        overflow: hidden;    }    .products {        width: 1002px;        border: 1px solid #ddd;        height: 476px;    }    .products .main {        float: left;        display: none;    }    .products .main.selected {        display: block;    }    .tab li.active {        border-color: red;        border-bottom: 0;    }&lt;/style&gt;&lt;div class = &quot;wrapper&quot;&gt;    &lt;ul class = &quot;tab&quot;&gt;        &lt;li class = &quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;        &lt;li class = &quot;tab-item&quot;&gt;男士精品&lt;/li&gt;    &lt;/ul&gt;    &lt;div class = &quot;products&quot;&gt;        &lt;div class = &quot;main selected&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guojidapai.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class = &quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guozhuangmingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class = &quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/qingjieyongpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;        &lt;div class = &quot;main&quot;&gt;            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/nanshijingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var items = document.querySelectorAll(&#39;.tab-item&#39;);    var mains = document.querySelectorAll(&#39;.main&#39;);    // 鼠标的移入事件    for (var i = 0; i &lt; items.length; i++) {        items[i].index = i;        items[i].onmouseover = function () {            for (var j = 0; j &lt; items.length; j++) {                items[j].classList.remove(&#39;active&#39;);            }            this.classList.add(&#39;active&#39;);            // 排除            for (var k = 0; k &lt; mains.length; k++) {                mains[k].classList.remove(&#39;selected&#39;);            }            mains[this.index].classList.add(&#39;selected&#39;);        }    }&lt;/script&gt;```***### 14.开关灯效果（开关思想）```    &lt;img src=&quot;./images/off.gif&quot; alt=&quot;&quot;&gt;    &lt;script&gt;        let img = document.querySelector(&#39;img&#39;)        let bl = true;        img.onclick = function () {            img.src = bl ? &#39;./images/on.gif&#39; : &#39;./images/off.gif&#39;;            bl = !bl;        }    &lt;/script&gt;```***### 15.元素的操作标签属性```    1.获取元素属性值： 元素对象.getAttribute(属性名)    2.设置元素属性值： 元素对象.setAttributr(属性，属性值)    案例：    &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;images/01.jpg&quot;/&gt;    &lt;script&gt;    let img = document.querySelector(&#39;#img&#39;);    let src = this.getAttribute(&#39;data-src&#39;);    img.setAttribute(&#39;src&#39;, src);    &lt;/script&gt;    3.删除属性:   元素对象.removeAttribute()    4.检测是否有： 元素对象.hasAttribute()  // 返回fase```***### 16.Attribute   属性 的意思| 功能 | 方法名 | 参数个数 | 是否有返回值 || :-: | :-: | :-: | :-: || 获取属性 | getAttribute() | 一个参数：属性名作为参数 | 有返回值 || 设置属性 | setAttribute() | 两个参数：属性名 和 属性值 | undefined || 移除属性 | removeAttribute() | 一个参数：属性名作为参数 | undefined || 是否有属性 | hasAttribute() | 一个参数：属性名作为参数 | 有返回值，布尔类型 |***## 第三天### 1.对class类进行添加 /类删除(都是对classList中操作)```    &lt;script&gt;    console.log(box.classList.value); // 获取元素所有类名    // 1. 添加    var box = document.querySelector(&#39;.box&#39;);    box.add() //不能直接使用    box.classList.add(&#39;five&#39;, &#39;six&#39;, &#39;seven&#39;); // 通过classList中的add方法添加    // 2. 删除类名（ remove）    var res = box.classList.remove(&#39;two&#39;, &#39;one&#39;); // 删除元素类名    // 3. 包含类名（ contains） 检测类名    box.classList.contains(&#39;one&#39;); // 如果包含返回true，只能传参一个    // 4. 类名替换（ replace）    box.classList.replace(&#39;原类名&#39;, &#39;新替换值&#39;)    box.classList.replace(&#39;one&#39;, &#39;呼呼呼&#39;)    // 5. 切换类名 toggle()    var box = document.querySelector(&#39;.box&#39;);    box.onclick = function () {        box.classList.toggle();    }&lt;/script&gt;```***### 2.创建元素```    &lt;script&gt;    // 1. 标准元素    var res = document.createElement(&#39;div&#39;);    res.innerHTML = &#39;这是动态创建&#39;;    console.log(res);    // 注意： 页面生效要获取body    var body = document.body;    body.appendChild(res);    // 自定义创建元素:    var res = document.createElement(&#39;jj&#39;);    res.innerHTML = &#39;这是动态创建&#39;;    var body = document.body;    body.appendChild(res);    // 2.document.write() //不推荐使用会将原有的内容覆盖掉    document.write(&#39; &lt;a href=&quot;www.baidu.com&quot;&gt;&lt;/a&gt;&#39;)    // 3. innerHTML也不推荐使用，原来的内容会覆盖（ += 不会覆盖）    var body = document.body;    body.innerHTML = &#39;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39;;&lt;/script&gt;```***### 3.追加元素```    appenedChild();  将元素追加到原有的元素后面```***### 4.删除元素的操作```&lt;!-- removeChild(参数) ;调用这个方法的元素一定是被删除的元素的父元素 返回被删除的元素（节点） --&gt;&lt;ul&gt;    &lt;li&gt;这是第1个li的内容&lt;/li&gt;    &lt;li&gt;这是第2个li的内容&lt;/li&gt;    &lt;li&gt;这是第3个li的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var ul = document.querySelector(&#39;ul&#39;);    // 获取所有的li    var lis = document.querySelectorAll(&#39;ul li&#39;);    // 删除元素    var res = ul.removeChild(lis[1]);    console.log(res);    console.log(lis[1] == res);&lt;/script&gt;```***### 5.替换节点操作    ```&lt;!-- replaceChild((参数1,参数2); 调用的时候： 使用要被替换的元素的父元素来调用 返回： 被提换的旧的节点 --&gt;&lt;ul&gt;    &lt;li&gt;这是第1个li的内容&lt;/li&gt;    &lt;li&gt;这是第2个li的内容&lt;/li&gt;    &lt;li&gt;这是第3个li的内容&lt;/li&gt;    &lt;li&gt;这是第4个li的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var ul = document.querySelector(&#39;ul&#39;);    var lis = document.querySelectorAll(&#39;li&#39;);    // 替换节点    var newLi = document.createElement(&#39;li&#39;);    newLi.innerHTML = &#39;我是新创建的&#39;;    var res = ul.replaceChild(newLi, lis[4]);    console.log(res);    console.log(lis[4] == res);&lt;/script&gt;```***### 6.插入节点操作(在..之前插入)```&lt;!-- //在某一个节点前面插入一个节点操作insertBefore(newElement，oldElement); 在调用这个方法的时候也是使用要插入的元素的父元素参数1： 表示要被插入的元素参数2：要被插入的哪个元素的前面 --&gt;&lt;ul&gt;    &lt;li&gt;这是第1个li的内容&lt;/li&gt;    &lt;li&gt;这是第2个li的内容&lt;/li&gt;    &lt;li&gt;这是第3个li的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var ul = document.querySelector(&#39;ul&#39;);    var lis = document.querySelectorAll(&#39;li&#39;);    var res = ul.insertBefore(lis[5], lis[0]);    console.log(res);&lt;/script&gt;```***### 7.复制节点操作（克隆）```&lt;!-- 克隆节点操作：   复制一个节点cloneNode(参数);      返回被克隆的节点注意： 如果不传入参数，表示浅拷贝，只克隆当前的节点，节点中的内容不会被克隆如果传入参数：true，表示深拷贝，就是将这个节点下面的所有的内容都克隆下来返回： 被克隆的节点 --&gt;&lt;ul&gt;    &lt;li&gt;        &lt;a href=&quot;#&quot;&gt;哈哈哈哈&lt;/a&gt;        &lt;p&gt;嘻嘻嘻嘻嘻嘻&lt;/p&gt;    &lt;/li&gt;    &lt;li&gt;这是第5个li的内容&lt;/li&gt;    &lt;li&gt;这是第6个li的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var lis = document.querySelectorAll(&#39;li&#39;);    // 克隆节点操作    var res = lis[0].cloneNode(true); // 这个元素被克隆的，但是元素中的内容没有被克隆    document.querySelector(&#39;ul&#39;).appendChild(res);&lt;/script&gt;```***### 8.案例：克隆表情```&lt;!-- 1.cloneNode() 2.appendChild() --&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div id=&quot;emoji&quot;&gt;        &lt;img src=&quot;img/01.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;        &lt;img src=&quot;img/02.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;        &lt;img src=&quot;img/03.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;        &lt;img src=&quot;img/04.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;    &lt;/div&gt;    &lt;p&gt;        &lt;strong&gt;请发言：&lt;/strong&gt;        &lt;img src=&quot;img/12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;    &lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var imgs = document.querySelectorAll(&#39;#emoji img&#39;);    var p = document.querySelector(&#39;p&#39;);    // for (var i = 0; i &lt; imgs.length; i++) {    //     imgs[i].onclick = function () {    //         let clone = this.cloneNode();    //         p.appendChild(clone);    //     }    // }    imgs.forEach(element =&gt; {        element.onclick = function () {            let newClone = element.cloneNode();            p.appendChild(newClone);        }    });&lt;/script&gt;```***### 9.案例发布内容```&lt;textarea cols = &quot;30&quot; rows = &quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type = &quot;button&quot; value = &quot;发布内容&quot;&gt;&lt;ul&gt;    &lt;li&gt;听说多喝热水能治病哦&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    let txt = document.querySelector(&#39;textarea&#39;)    let btn = document.querySelector(&#39;input&#39;)    let ul = document.querySelector(&#39;ul&#39;)    btn.onclick = function () {        let content = txt.value;        if (content == &#39;&#39;) {            alert(&#39;内容不能为空，请输入内容&#39;)            return;        }        let li = document.createElement(&#39;li&#39;)        li.innerHTML = content;        ul.appendChild(li);        txt.value = &#39;&#39;;    }&lt;/script&gt;```***### 10.获取DOM树 子元素/子节点(都是属性不是方法)```&lt;!-- 1.children 2.childNodes 3.nextElementSibling(下个节点) --&gt;&lt;ul&gt;    &lt;li&gt;获取子元&lt;/li&gt;    &lt;li&gt;获取子元&lt;/li&gt;    &lt;li&gt;获取子元&lt;/li&gt;    &lt;li&gt;获取子元&lt;/li&gt;    &lt;/ul&gt;&lt;script&gt;    var ul = document.querySelector(&#39;ul&#39;);    // 获取子元素    var lis = ul.children; // 获取父元素下面的子元素集合    console.log(lis);    var LisNode = ul.childNodes; // 获取子节点（(换行也是元素)    console.log(LisNode);&lt;/script&gt;```***### 11.案例：仿微博发布往li添加内容```&lt;!-- 1.createElement() 2.innerHTML 3.appendChild() 4.value --&gt;&lt;textarea cols = &quot;30&quot; rows = &quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type = &quot;button&quot; value = &quot;发布内容&quot;&gt;&lt;ul&gt;    &lt;li&gt;测试发送微博&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var text = document.querySelector(&#39;textarea&#39;)    var btn = document.querySelector(&#39;input&#39;)    var ul = document.querySelector(&#39;ul&#39;)    btn.onclick = function () {        var content = text.value;        if (content == &#39;&#39;) {            alert(&#39;内容不能为空，请输入内容&#39;)            return;        }        var li = document.createElement(&#39;li&#39;);        li.innerHTML = content;        ul.appendChild(li);        text.value = &#39;&#39;;    }&lt;/script&gt;```***###    12.通过子元素获取父元素(都是属性不是方法)```&lt;script&gt;    // 1. parentElement 2. parentNode    var lis = document.querySelector(&#39;li&#39;);    //获取父元素    var pe = lis[0].parentElement;    console.log(pe);    var LisNode = lis[0].parentNode; //获取父节点    console.log(LisNode);&lt;/script&gt;```***### 13.兄弟元素和兄弟节点(都是属性不是方法)(下一个节点)```&lt;script&gt;    // 1.previousElementSibling 2.nextElementSibling // 兄弟元素    // 1.previousSibling  2.nextSibling  // 兄弟节点    var lis = document.querySelector(&#39;li&#39;);    //上一个兄弟元素    var pes = lis[0].previousElementSibling;    console.log(pes);    //下一个兄弟元素    var next = lis[0].nextElementSibling;    console.log(next);    //上一个兄弟节点    var pesjd = lis[0].previousSibling;    console.log(pes);    //下一个兄弟节点    var nextjd = lis[0].nextSibling;    console.log(nextjd);&lt;/script&gt;```***### 14.鼠标事件（前面加on）| 英文 | 翻译 | 备注 || :-: | :-: | :-: || click | 鼠标单击 | 重点 || dblclick | 鼠标双击 | double 双倍 || mousemove | 鼠标移动 | || mousedown | 鼠标按下 | || mouseup | 鼠标弹起 | || mouseenter | 鼠标移入 | 重点，推荐使用 || mouseleave | 鼠标移出 | 重点，推荐使用 || mouseover | 鼠标移入 | div中有小div也触发 || mouseout | 鼠标移出 | div中有小div也触发|</code></pre><p>案例：<br>    var divs = document.querySelectorAll(‘div’);<br>    // click: 鼠标单击<br>    divs[0].onclick = function() {<br>        console.log(‘鼠标单击’);<br>    }</p><pre><code>***### 15.鼠标x轴Y轴坐标| 英文 | 翻译 | 备注 || :-: | :-: | :-: || clientX | 鼠标在可视区的 X 轴坐标 | || clientY | 鼠标在可视区的 Y 轴坐标 | |***</code></pre><p>// 案例：小天使跟随鼠标移动</p><style>    img {        position: fixed;        /*固定定位只识别浏览器视口*/    }</style><!-- 1.document.onmousemove(鼠标移动事件) 2.clientX -坐标 3.position: fixed; --><img src = "img/tianshi.gif" alt = "" id = "img" /><script>    var img = document.querySelector('img');    //移动鼠标事件    document.onmousemove = function (e) {        img.style.left = e.clientX + "px";        img.style.top = e.clientY + "px";    }</script><pre><code>***### 16.键盘事件类型（用时加on）| 英文 | 翻译 | 备注 || :-: | :-: | :-: || keydown | 键盘按下 || keyup | 键盘弹起 || keypress | 键盘按下并弹起 |***</code></pre><p>// 案例：<br>// keydown 键盘按下<br>var body = document.body;</p><p>body.onkeydown = function() {<br>     console.log(‘键盘已经按下’);<br>}</p><pre><code>***### 17.键盘事件属性（不用加on）| 英文 | 翻译 | 备注 || :-: | :-: | :-: || keyCode | 获取键盘按键编码 | 重点 || ctrlKey | 是否同时按了组合键 Ctrl | 了解 || altKey | 是否同时按了组合键 Alt | 了解 || shiftKey | 是否同时按了组合键 Shift | 了解 |***</code></pre><p>// 1.alt/ctrl/shift 通过boolean类型的值判断是否被按下<br>// 2.回车键的键盘码 13</p><p>案例：</p><script>document.body.onkeydown = function (e) {    var content = txt.value;    if (e.ctrlKey && e.keyCode == 13) {        if (content == '') {            alert('内容不能为空，请输入内容');            return;        }        fun();    }}</script> <pre><code>***### 18.表单事件类型（用时加on）| 英文 | 翻译 | 备注 || :-: | :-: | :-: || focus | 获取焦点 | || blur | 失去焦点 | blur 模糊就是失去焦点 || change | 重点记 | || submit | 提交表单 | 后面 AJAX 阶段要用到 |***</code></pre><pre><code>注意事项：- 获取焦点和失去焦点主要是表单的输入框元素添加较多- 获取焦点 - 光标在输入内闪烁- 失去焦点 - 光标不再输入框内闪烁 - 鼠标点击了别的地方案例：&lt;input type = &quot;text&quot; class = &quot;txt&quot;&gt;//1.focus 获取焦点&lt;script&gt;document.querySelector(&#39;.txt&#39;).onfocus = function () {    // console.log(&#39;获得了焦点&#39;);    this.value = &#39;请输入用户名&#39;;}&lt;/script&gt;// 2.blur 失去焦点&lt;script&gt;document.querySelector(&#39;.txt&#39;).onblur = function () {    // console.log(&#39;你这样会失去我的&#39;);    this.value = &#39;&#39;;}&lt;/script&gt;//3.change:事件类型 改变 当表单中的内容发生改变的时候触发&lt;script&gt;document.querySelector(&#39;input&#39;).onchange = function () {    console.log(&#39;我又变了&#39;);}&lt;/script&gt;</code></pre><pre><code>***### 19.事件处理函数内的事件对象</code></pre><pre><code>1.所有的事件处理函数内都可以调用事件对象，但是需要在事件处理函数的形参位置起个名字。2.建议大家使用形参名字：event，ev，e 。案例：&lt;script&gt;document.body.onkeydown = function (e) {    var content = txt.value;    if (e.ctrlKey &amp;&amp; e.keyCode == 13) {}}&lt;/script&gt;</code></pre><pre><code>***### 微博升级版</code></pre><p>未做 待补</p><pre><code>***## 第四天### 1.鼠标事件对象页面坐标| 属性名 | 描述 | 备注 || :-: | :-: | :-: || clientX/clientY | 浏览器坐标 | 可视区域 || pageX/pageY | 页面坐标 | |***### 2.案例放大镜</code></pre><style>    * {        margin: 0;        padding: 0;    }    .main {        width: 350px;        height: 350px;        margin: 100px;        border: 1px solid #ccc;        position: relative;    }    .big {        width: 400px;        height: 400px;        position: absolute;        top: 0;        left: 360px;        border: 1px solid #ccc;        overflow: hidden;        display: none;    }    .mask {        width: 175px;        height: 175px;        background: rgba(255, 255, 0, 0.4);        position: absolute;        top: 0px;        left: 0px;        /* 把鼠标指针换成移动图标 */        cursor: move;        display: none;    }    .small {        position: relative;        height: 350px;        width: 350px;    }    .active .mask,    .active .big {        display: block;    }    .big img {        /* 相对定位：相对自己原本的位置定位，原来的位置保留的 */        position: absolute;    }</style><!-- 整个大盒子 --><div class="main" id="main">    <div class="small">        <!--小图-->        <img alt="" class="smallImg" src="images/iphoneX.jpg" width="350" />        <!-- 遮挡层,黄色的小方块 -->        <div class="mask"></div>    </div>    <!--大层-->    <div class="big">        <!--大图-->        <img alt="" class="bigImg" src="images/iphoneX.jpg" width="800" />    </div></div>```<hr><h3 id="3-事件对象中通用属性-target"><a href="#3-事件对象中通用属性-target" class="headerlink" title="3.事件对象中通用属性(target)"></a>3.事件对象中通用属性(target)</h3><table><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">事件类型</td><td align="center"></td></tr><tr><td align="center">timeStamp</td><td align="center">时间标记</td><td align="center">事件触发时候的时间标记，单位是毫秒</td></tr><tr><td align="center">target</td><td align="center">目标元素</td><td align="center">重点，触发事件时候真正被(点击)那个元素</td></tr></tbody></table><hr><pre><code>    // 目标属性案例(target)：    &lt;div class=&quot;box&quot;&gt;    &lt;h1&gt;标题&lt;/h1&gt;    &lt;p&gt;段落&lt;/p&gt;    &lt;span&gt;文本内容&lt;/span&gt;    &lt;ul&gt;        &lt;li&gt;这是第1个里的内容&lt;/li&gt;        &lt;li&gt;这是第2个里的内容&lt;/li&gt;        &lt;li&gt;这是第3个里的内容&lt;/li&gt;    &lt;/ul&gt;    &lt;/div&gt;    &lt;script&gt;    var box = document.querySelector(&#39;.box&#39;);    // 注册点击事件   事件注册box身上    box.onclick = function (e) {        // console.log(e.target);        // 有一个属性可以获取到标签的名字： nodeName        console.log(e.target.nodeName);        // 判断，点击的目标是否是li        if (e.target.nodeName == &#39;LI&#39;) {            console.log(&#39;当li被点击的时候才执行这个逻辑&#39;);        }    }    &lt;/script&gt;</code></pre><hr><h3 id="4-选择有有类名one案例"><a href="#4-选择有有类名one案例" class="headerlink" title="4.选择有有类名one案例"></a>4.选择有有类名one案例</h3><pre><code>&lt;ul&gt;    &lt;li&gt;这是第1个里的内容&lt;/li&gt;    &lt;li class=&quot;one&quot;&gt;这是第2个里的内容&lt;/li&gt;    &lt;li&gt;这是第3个里的内容&lt;/li&gt;    &lt;li&gt;这是第4个里的内容&lt;/li&gt;    &lt;li class=&quot;one&quot;&gt;这是第5个里的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var box = document.querySelector(&#39;.box&#39;);    // 注册点击事件   事件注册box身上    box.onclick = function (e) {        //当点击的li标签中有class=&#39;one&#39;这个类名的元素才执行        // console.log(e.target);        // 判断元素是否有某一个类名，有类名才执行，没有不执行        if (e.target.classList.contains(&#39;one&#39;)) {            console.log(&#39;带有类名的执行&#39;)        }    }&lt;/script&gt;</code></pre><hr><h3 id="5-获取标签名属性（nodeName）"><a href="#5-获取标签名属性（nodeName）" class="headerlink" title="5.获取标签名属性（nodeName）"></a>5.获取标签名属性（nodeName）</h3><pre><code>    1.target  2.nodeName 3.e.target.classList.contains()    1. 判断target中的元素    &lt;script&gt;    e.target; // 获取当前的元素 &lt;li&gt;jjklj&lt;/li&gt;        e.target.nodeName; // li 返回都是大写LI    box.onclick = function (e) {        if (e.target.nodeName == &#39;LI&#39;) {        }    }    &lt;/script&gt;    2.查找带有同类名的li    e.target.classList.contains(&#39;one&#39;); // 有返回true</code></pre><hr><h3 id="6-事件委托（委托父元素）非常重要"><a href="#6-事件委托（委托父元素）非常重要" class="headerlink" title="6.事件委托（委托父元素）非常重要"></a>6.事件委托（委托父元素）非常重要</h3><pre><code>&lt;ul&gt;    &lt;li&gt;这是第1个li中的内容&lt;/li&gt;    &lt;li&gt;这是第2个li中的内容&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 事件委托：事件注册没有在元素本身身上，而是在其父辈元素身上     // 注意： 父辈元素一定是在页面中存在的，而不是动态创建的    var ul = document.querySelector(&#39;ul&#39;);    // 对于动态生成的元素也是可以实现的    var newLi = document.createElement(&#39;li&#39;);    newLi.innerHTML = &#39;新创的li元素&#39;;    ul.appendChild(newLi);    // 事件委托    ul.onclick = function () {        console.log(&#39;li被点击了&#39;);    }&lt;/script&gt;</code></pre><hr><h3 id="7-微博升级（删除-编辑）"><a href="#7-微博升级（删除-编辑）" class="headerlink" title="7.微博升级（删除 编辑）"></a>7.微博升级（删除 编辑）</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;        list-style: none;    }    .weibo {        width: 600px;        border: 1px solid #ccc;        margin: 100px auto;        padding: 10px;    }    .weibo-text {        width: 590px;        height: 140px;        padding: 5px;        border: 1px solid #ccc;        outline: none;        resize: none;    }    .weibo-text:focus {        border-color: #f60;    }    .weibo-btn {        width: 80px;        height: 30px;        background-color: #f90;        color: #fff;        border: 0 none;        margin-top: 5px;        border-radius: 3px;        cursor: pointer;        outline: 0 none;    }    .weibo-list {        padding-top: 10px;    }    .weibo-list li {        font-size: 14px;        line-height: 30px;        border-bottom: 1px dotted #ccc;        overflow: hidden;    }    .weibo-list li p {        float: left;    }    .weibo-list li span {        float: right;        cursor: pointer;    }    .weibo-list li input {        height: 24px;        line-height: 24px;        width: 300px;        font-size: 14px;        /* border: 0 none; */    }&lt;/style&gt;&lt;div class=&quot;weibo&quot;&gt;    &lt;textarea class=&quot;weibo-text&quot;&gt;&lt;/textarea&gt;    &lt;button class=&quot;weibo-btn&quot;&gt;发布&lt;/button&gt;    &lt;ul class=&quot;weibo-list&quot;&gt;        &lt;li&gt;            &lt;p&gt;快来收了这九款用上就停不下来的应用吧！！&lt;/p&gt;            &lt;span&gt;删除&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;p&gt;超级详细的云南大理自助游攻略&lt;/p&gt;            &lt;span&gt;删除&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;p&gt;外国最近很火的舞蹈，舒服简单自然，太棒了！&lt;/p&gt;            &lt;span&gt;删除&lt;/span&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    // 1. 查找元素    var text = document.querySelector(&#39;.weibo-text&#39;);    var btn = document.querySelector(&#39;.weibo-btn&#39;);    var list = document.querySelector(&#39;.weibo-list&#39;);    var realseNews = function () {        //获取值并清空        var str = text.value.trim();        if (str === &#39;&#39;) {            alert(&#39;不能为空!&#39;);            return;        } else if (str.length &gt; 120) {            alert(&#39;输入内容请在120个字符内!&#39;);            return;        } else {            //发布的内容            var newLi = document.createElement(&#39;li&#39;);            newLi.innerHTML = `                &lt;p&gt;${str}&lt;/p&gt;                &lt;span&gt;删除&lt;/span&gt;            `;            //插入第一列            list.insertBefore(newLi, list.children[0]);            text.value = &#39;&#39;;        }    }    btn.onclick = realseNews;    // 把点击事件委派给父级元素    list.onclick = function (e) {        //判断点击是否标签名(点击了删除)        if (e.target.nodeName === &#39;SPAN&#39;) {            //删除当前span父元素li            list.removeChild(e.target.parentElement);            //编辑        } else if (e.target.nodeName === &#39;P&#39;) {            // console.log(&#39;你点击了 p 标签&#39;);            var newInput = document.createElement(&#39;input&#39;);            newInput.type = &#39;text&#39;;            newInput.value = e.target.innerText;            console.log(e.target.parentElement);            //替换            e.target.parentElement.replaceChild(newInput, e.target);            // newInput.focus();       // 主动获取一下获取焦点        }    }    // 按下键盘事件 ctrl + Enter    text.onkeyup = function (e) {        // console.log(e);        if (e.ctrlKey &amp;&amp; e.keyCode === 13) {            realseNews();        }    }    // 文本域进入页面的时候主动获取焦点，用户可以直接编辑，百度搜索框也是主动获取焦点    // text.focus();&lt;/script&gt;</code></pre><hr><h3 id="8-阻止默认行为（event-preventDefault-）"><a href="#8-阻止默认行为（event-preventDefault-）" class="headerlink" title="8.阻止默认行为（event.preventDefault();）"></a>8.阻止默认行为（event.preventDefault();）</h3><table><thead><tr><th align="center">方法名</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">preventDefault()</td><td align="center">阻止默认行为</td><td align="center"></td></tr><tr><td align="center">stopPropagation()</td><td align="center">停止事件传播</td><td align="center"></td></tr></tbody></table><hr><pre><code>案例：1.a阻止默认打开&lt;!-- &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; --&gt;&lt;!-- &lt;input type=&quot;submit&quot;&gt; --&gt;&lt;!-- 阻止元素默认行为： a的跳转     input ---submit --&gt;&lt;script&gt;    var a = document.querySelector(&#39;a&#39;);    a.onclick = function (e) {        //阻止默认行为的方法： preventDefault();        e.preventDefault();    }&lt;/script&gt;2.div域阻止复制&lt;div&gt;这是我们创造的新的东西，不要随便复制。&lt;/div&gt;&lt;script&gt;    document.querySelector(&#39;div&#39;).oncopy = function (e) {        e.preventDefault();        alert(&#39;创造不易，请打发一点&#39;);    }&lt;/script&gt;3.右边菜单禁止打开&lt;script&gt;    document.body.oncontextmenu = function (e) {        e.preventDefault();        alert(&#39;你是不是想复制，不让你复制，气死你&#39;);    }&lt;/script&gt;</code></pre><hr><h2 id="第五天-1"><a href="#第五天-1" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-事件注册（绑定）两种写法"><a href="#1-事件注册（绑定）两种写法" class="headerlink" title="1.事件注册（绑定）两种写法"></a>1.事件注册（绑定）两种写法</h3><pre><code>1.绑定写法1（事件的冒泡）（on会覆盖前面的函数）事件冒泡就是事件委托原理事件源.on事件类型 = 事件处理函数; //缺陷会当执行子div父辈div事件也会执行阻止事件的冒泡：&lt;script&gt;    e.stopPropagation();&lt;/script&gt;2.通过 addEventListener() 方法添加事件(同名函数不会覆盖，不加on，，给谷歌)&lt;script&gt;    事件源.addEventListener(&#39;事件类型&#39;, 事件处理函数);    window.addEventListener(&#39;add&#39;, function () {})&lt;/script&gt;3.attachEvent事件（低版本ie8支持 兼容，不加on)</code></pre><hr><h3 id="2-事件的解绑两种写法"><a href="#2-事件的解绑两种写法" class="headerlink" title="2.事件的解绑两种写法"></a>2.事件的解绑两种写法</h3><pre><code>1.第一种解绑on&lt;script&gt;    事件源.on事件类型 = null;    document.querySelector(&#39;input&#39;).onclick = null; //推荐这种    document.querySelector(&#39;input&#39;).onclick = &#39;&#39;;&lt;/script&gt;2.第二种解绑addEventListener()&lt;script&gt;    事件源.removeEventListener(&#39;事件类型&#39;, 事件处理函数的内存地址)    案例： removeEventListener()    var fn = function () {        console.log(&#39;事件注册成功！&#39;);    }    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;, fn);    //解绑事件    document.querySelector(&#39;input&#39;).removeEventListener(&#39;click&#39;, fn);&lt;/script&gt;3.detachEvent解绑事件</code></pre><hr><h3 id="3-json"><a href="#3-json" class="headerlink" title="3.json"></a>3.json</h3><pre><code>&lt;script&gt;    json是一种轻量级的数据交换格式    3.1 输写json格式    1. 都是键值对出现， 使用引号引起来；    2. 每一组后面加逗号， 最后一组不加逗号    3. 数字和boolean类型不使用引号    3.2 把JSON字符串转对象    var jsonObj = {        name: &#39;小李&#39;,        age: 30,        gender: &#39;不详&#39;    }    var 转换后的结果 = JSON.parse(需要转换的数据);&lt;/script&gt;</code></pre><table><thead><tr><th align="center">方法名</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">JSON.stringify()</td><td align="center">把对象转换成 JSON 字符串</td><td align="center">对象的方法不会转换到字符串中</td></tr><tr><td align="center">JSON.parse()</td><td align="center">把 JSON 字符串转换成对象</td><td align="center">转换失败会报错</td></tr></tbody></table><hr><pre><code>3.3把JSON对象转字符串 （网络传输都是字符串或二进制传输&lt;script&gt;    JSON.stringify(jsonObj);&lt;/script&gt;</code></pre><hr><h3 id="4-页面显示处理（alert打印Obj）"><a href="#4-页面显示处理（alert打印Obj）" class="headerlink" title="4.页面显示处理（alert打印Obj）"></a>4.页面显示处理（alert打印Obj）</h3><pre><code>&lt;script&gt;    alert(), document.write(), innerHTML 会自动把数据隐式转换成了字符串。    对象如果直接通过隐式转换成字符串， 相当于直接调用了 `String()` 进行转换， 所以会看到 `[object Object]` 错误结果。    如果要输出对象的数据格式，可以通过 `JSON.stringify()` 转换成字符串。    案例：    alert(JSON.stringify(jsonObj));&lt;/script&gt;</code></pre><hr><h3 id="5-Bom中的顶级对象-window"><a href="#5-Bom中的顶级对象-window" class="headerlink" title="5.Bom中的顶级对象: window"></a>5.Bom中的顶级对象: window</h3><pre><code>&lt;script&gt;    console.log(window);    console.log(window.document == document); // true,document相当于属性&lt;/script&gt;</code></pre><hr><h3 id="6-localStorage-本地存储-重点"><a href="#6-localStorage-本地存储-重点" class="headerlink" title="6.localStorage 本地存储(重点)"></a>6.localStorage 本地存储(重点)</h3><pre><code>本地存储的学习： 本地存储是浏览器的行为  帮助我们存储数据使用的</code></pre><hr><p>学习的方法：<br>| 方法名 | 描述 | 参数 | 备注 |<br>| :-: | :-: | :-: | :-: |<br>| <code>setItem()</code> | 设置一条数据 | 两个参数：键名称，值 | 直接保存到浏览器，参数二自动隐式转换成字符串 |<br>| <code>getItem()</code> | 获取一条数据 | 一个参数 | 有返回值，返回字符串数据 |<br>| <code>removeItem()</code> | 移除一条数据 | 一个参数 | |<br>| <code>clear()</code>  | 清空所有数据 | 无需传参 | 了解 |</p><pre><code>1.setItem() 这个方法就是用来存储数据的//将对象数据存入本地存储中，会调用toString方法来处理，这样我们不能看到完整的数据案例：&lt;script&gt;    var obj = {        name: &#39;张三&#39;,        age: 20,        gender: &#39;女&#39;,        address: &#39;天河区大地商务中心&#39;    }    var obj1 = {        name: &#39;李四&#39;,        age: 20,        gender: &#39;女&#39;,        address: &#39;天河区大地商务中心&#39;    }    localStorage.setItem(&#39;student&#39;, JSON.stringify(obj))    console.log(typeof 对象名) //类型打印&lt;/script&gt;2.getItem() 获取本地存储的数据&lt;script&gt;    var res = localStorage.getItem(&#39;key键名&#39;)；    console.log(typeof res); // 取出是string    console.log(JSON.parse(res)); // 转换json对象&lt;/script&gt;3.删除本地数据（`removeItem(&#39;键&#39;)）&lt;script&gt;    // 注意： 每次只能删除一对    localStorage.removeItem(&#39;res&#39;);&lt;/script&gt;4.一次删除所有数据&lt;script&gt;    localStorage.clear();&lt;/script&gt;</code></pre><hr><h3 id="7-案例：发布新闻本地存储"><a href="#7-案例：发布新闻本地存储" class="headerlink" title="7.案例：发布新闻本地存储"></a>7.案例：发布新闻本地存储</h3><pre><code>&lt;style&gt;        /* 上面有样式 */&lt;/style&gt;&lt;div class=&quot;weibo&quot;&gt;    &lt;textarea class=&quot;weibo-text&quot;&gt;&lt;/textarea&gt;    &lt;button class=&quot;weibo-btn&quot;&gt;发布&lt;/button&gt;    &lt;ul class=&quot;weibo-list&quot;&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    // 获取元素    var wbTxt = document.querySelector(&#39;.weibo-text&#39;);    var wbBtn = document.querySelector(&#39;.weibo-btn&#39;);    var wbList = document.querySelector(&#39;.weibo-list&#39;);    ​​​​ // 每次刷新页面或者重新打开页面的时候都去本地存储中获取一次数据，将获取的数据渲染在页面上    ​ // wbData:是我自己定义的，因为在存储数据的时候，我使用就是这个键名    ​    var getData = JSON.parse(localStorage.getItem(        &#39;wbData&#39;));​​ // 我们在获取数据的时候，如果有数据： getData = [{content:&#39;哈哈哈&#39;,id:123456}]    ​​// 如果没有数据的时候： getData：null    ​​    if (getData) {        ​ // 定义个字符串用来拼接        ​        var strHtml = &#39;&#39;;​​ // 循环遍历        ​        for (var i = 0; i &lt; getData.length; i++) {            ​            strHtml += `​                    &lt;li&gt;​                        &lt;p&gt;${getData[i].content}&lt;/p&gt;​                        &lt;span data-id=${getData[i].id}&gt;删除&lt;/span&gt;​                    &lt;/li&gt;​                    `​        }​ // console.log(strHtml);        ​        wbList.innerHTML = strHtml;​    }    ​​​// 封装一个发布微博的函数    ​    function release() {        ​// 获取文本域中的内容        ​        var str = wbTxt.value.trim();​​ // 生成一个唯一标识        ​        var time = +new Date(); // 会生成一个13位数的数字        ​​// 做非空判断        ​        if (str == &#39;&#39;) {            ​            alert(&#39;请输入内容，不能为空&#39;);​            return;​        } else if (str.length &gt; 120) {            ​            alert(&#39;您的内容太多了，请重新输入&#39;);​            return;​        } else {            ​            var lis = wbList.children;​​            var newLi = document.createElement(&#39;li&#39;);​            newLi.innerHTML = `​                            &lt;p&gt;${str}&lt;/p&gt;​                            &lt;span data-id=${time}&gt;删除&lt;/span&gt;​                    `; // 将创建的元素添加到列表中            wbList.insertBefore(newLi, lis[0]);​​ // 将文本域中的内容清空            ​            wbTxt.value = &#39;&#39;;            ​​ // 如果有数据，将数据返回给newArr，如果没有数据创建一个空的数组            ​            var newArr = JSON.parse(localStorage.getItem(&#39;wbData&#39;)) || [];            newArr.unshift({                ​                content: str,                ​id: time​            })​ // if (newArr) {            ​ //     newArr.unshift(            ​ //         {            ​ //             content: str,            ​ //             id: time            ​ //         }            ​ //     )            ​​ // } else {            ​ //     newArr = [];            ​ //     newArr.push(            ​ //         {            ​ //             content: str,            ​ //             id: time            ​ //         }            ​ //     )            ​​ // }            ​​ // 将数据添加到本地存储中            ​ localStorage.setItem(&#39;wbData&#39;, JSON.stringify(newArr));​​        }​    }​​ // 点击发布按钮发布微博信息    ​    wbBtn.onclick = release;​​ // 按ctrl+enter键也能实现发布    ​    wbTxt.onkeydown = function (e) {        if (e.ctrlKey &amp;&amp; e.keyCode == 13) {            release();​        }​    }    // 删除操作    wbList.onclick = function (e) {        if (e.target.nodeName == &#39;SPAN&#39;) {            wbList.removeChild(e.target.parentNode);            var delData = JSON.parse(localStorage.getItem(&#39;wbData&#39;));            for (var i = 0; i &lt; delData.length; i++) {                if (delData[i].id == e.target.dataset.id) {                    delData.splice(i, 1); //i:当前这条数据的索引，1：删除一条                    localStorage.setItem(&#39;wbData&#39;, JSON.stringify(delData));                    return;                }            }        }    }&lt;/script&gt;</code></pre><hr><h3 id="7-BOM-其他对象window"><a href="#7-BOM-其他对象window" class="headerlink" title="7.BOM 其他对象window"></a>7.BOM 其他对象window</h3><pre><code>    1.屏幕对象:window.screen    2.浏览历史对象:window.history    3.浏览器信息对象:window.navigator    4.浏览器地址栏对象 URL:window.location</code></pre><hr><h3 id="8-location-URL对象"><a href="#8-location-URL对象" class="headerlink" title="8.location URL对象"></a>8.location URL对象</h3><table><thead><tr><th align="center">属性和方法</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">href</td><td align="center">设置或返回完整的 URL</td><td align="center">常用</td></tr><tr><td align="center">search</td><td align="center">设置或返回从问号(?)开始的 URL(查询部分)</td><td align="center">要获取页面参数时使用 , 便捷</td></tr><tr><td align="center">reload()</td><td align="center">刷新页面，重新加载当前文档</td><td align="center">true 参数传入 , 绕过缓存 , 强制刷新</td></tr></tbody></table><hr><pre><code>案例：&lt;script&gt;    // location.search: 可以获取url地址？ 后面的内容    location.reload();&lt;/script&gt;</code></pre><hr><h3 id="9-短路运算"><a href="#9-短路运算" class="headerlink" title="9.短路运算"></a>9.短路运算</h3><pre><code>    与(&amp;&amp;):找假 第一个为假不往下走    或(||):找真 有一个true就返回 (第一个不true 找第二个)</code></pre><hr><h2 id="第六天-1"><a href="#第六天-1" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-定时器"><a href="#1-定时器" class="headerlink" title="1.定时器"></a>1.定时器</h3><pre><code>&lt;script&gt;    // -调用 `setInterval()`    // 方法的时候， 定时器启动后有返回值， 返回定时器的编号， 一般用变量接收用于以后清除使用。    //     -    //     多次定时器启动后是一直运行， 如果不清除或者关掉页面， 定时器会一直保持运动。    // const timerId = setInterval(定时执行的函数地址, 毫秒时间);    // 案例：    var num = 0;    var res = setInterval(function () {        num++;        console.log(&#39;哈哈哈&#39; + num);    }, 1000)    console.log(res);&lt;/script&gt;</code></pre><hr><h3 id="2-延时器"><a href="#2-延时器" class="headerlink" title="2.延时器"></a>2.延时器</h3><pre><code>&lt;script&gt;    // 只执行一次,延迟执行    setTimeout(function () {        alert(&#39;hhha&#39;)    }, 100);&lt;/script&gt;</code></pre><hr><h3 id="3-清除多次定时器"><a href="#3-清除多次定时器" class="headerlink" title="3.清除多次定时器"></a>3.清除多次定时器</h3><pre><code>&lt;script&gt;    // clearInterval(定时器启动时候的编号);    // clearInterval(参数) 参数：定时器的id    document.querySelector(&#39;input&#39;).onclick = function () {        clearInterval(timeId)    }&lt;/script&gt;</code></pre><hr><h3 id="4-案例验证码定时器"><a href="#4-案例验证码定时器" class="headerlink" title="4.案例验证码定时器"></a>4.案例验证码定时器</h3><pre><code>&lt;style&gt;    .form {        width: 600px;        margin: 100px auto;    }    .row {        width: 100%;        display: flex;        border-top: 1px solid #0094ff;        border-bottom: 1px solid #0094ff;    }    .cols-1 {        flex: 1;    }    .cols-2 {        flex: 2;    }    .cell {        border-left: 1px solid #0094ff;        padding: 10px 6px;        line-height: 42px;        text-align: center;    }    .cell:last-child {        border-right: 1px solid #0094ff;    }    .text {        width: 268px;        height: 30px;        padding: 4px;    }    .btn {        height: 38px;        width: 104px;    }&lt;/style&gt;&lt;div class=&quot;form&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;cell cols-1&quot;&gt;请输入手机号码&lt;/div&gt;        &lt;div class=&quot;cell cols-2&quot;&gt;            &lt;input type=&quot;text&quot; class=&quot;text&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;cell cols-1&quot;&gt;            &lt;input type=&quot;button&quot; class=&quot;btn&quot; data-time=&quot;3&quot; value=&quot;获取验证码&quot; id=&quot;getCode&quot;&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 获取元素    var btn = document.querySelector(&#39;.btn&#39;);    // 给按钮注册点击事件    btn.onclick = function () {        // 让按钮变成禁用状态        btn.disabled = true;        // 获取倒计时的初始时间，在按钮的data-time上面        var time = btn.getAttribute(&#39;data-time&#39;);        // console.log(time);        // 将时间设置给按钮        btn.value = time + &#39;秒&#39;;        // 开启定时器，开始倒计时        var timeId = setInterval(function () {            // 让时间不断的减少            time--;            // 将这个时间设置给按钮的文本            btn.value = time + &#39;秒&#39;;            // 当时间减少到0的时候，定时器需要停止了。            if (time == 0) {                // 清除定时器                clearInterval(timeId);                // 让按钮可以被点击，按钮上的文本变成获取验证码                btn.disabled = false;                // 改变按钮的文本                btn.value = &#39;获取验证码&#39;;            }        }, 1000)    }&lt;/script&gt;</code></pre><hr><h3 id="5-单次定时器"><a href="#5-单次定时器" class="headerlink" title="5.单次定时器"></a>5.单次定时器</h3><pre><code>&lt;script&gt;    // 返回定时器的id    // const timerId = setTimeout(定时执行的函数地址, 毫秒时间);    // 案例：    // 隔一个时间点，函数只执行一次，后面就不在执行    // 返回：定时器id    var res = setTimeout(function () {        console.log(&#39;已经爆炸了&#39;);        // setTimeout(function(){},1000)    }, 3000)&lt;/script&gt;</code></pre><hr><h3 id="6-清除单次定时器"><a href="#6-清除单次定时器" class="headerlink" title="6.清除单次定时器"></a>6.清除单次定时器</h3><pre><code>&lt;script&gt;    // clearTimeout(定时器启动时候的编号);    // 案例：    //setTimeout()这个定时器也可以清除    // clearTimeout(定时器id);    document.querySelector(&#39;input&#39;).onclick = function () {        clearTimeout(res);    }&lt;/script&gt;</code></pre><hr><h3 id="7-load事件（加载）"><a href="#7-load事件（加载）" class="headerlink" title="7.load事件（加载）"></a>7.load事件（加载）</h3><pre><code>&lt;script&gt;    // 给图片注册一个load事件    document.querySelector(&#39;img&#39;).onload = function () {        // 必须等图片加载完成才做这个事情        console.log(&#39;图片已经加载完成，可以继续了&#39;);    }&lt;/script&gt;</code></pre><hr><h3 id="8-window中的load事件"><a href="#8-window中的load事件" class="headerlink" title="8.window中的load事件"></a>8.window中的load事件</h3><pre><code>&lt;script&gt;    // 1. 使用on的方式注册的事件， 后面的会覆盖前面的    window.onload = function () {    }    // 2. 这种方式可以避免同一类型的事件被覆盖    window.addEventListener(&#39;load&#39;, function () {    })&lt;/script&gt;</code></pre><hr><h3 id="9-获取元素的样式设值-元素的计算样式：行内，内嵌，外联）"><a href="#9-获取元素的样式设值-元素的计算样式：行内，内嵌，外联）" class="headerlink" title="9.获取元素的样式设值(元素的计算样式：行内，内嵌，外联）"></a>9.获取元素的样式设值(元素的计算样式：行内，内嵌，外联）</h3><pre><code>// 1.window.getComputedStyle();&lt;script&gt;    var text = document.querySelector(&#39;.text&#39;);    var res = window.getComputedStyle(box);    console.log(parseInt(res.width)); // 800px 转换800&lt;/script&gt;&lt;!-- 2.模拟投票（类似进度条） --&gt;&lt;style&gt;        .box {            width: 200px;            height: 50px;            background: purple;        }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;        // 获取元素        var box = document.querySelector(&#39;.box&#39;);        box.onclick = function () {            // 获取当前元素的宽度            var divWidth = parseInt(window.getComputedStyle(box).width);            // console.log(divWidth);            divWidth += 20;            box.style.width = divWidth + &#39;px&#39;;        }&lt;/script&gt;</code></pre><hr><h3 id="10-元素的自身样式属性"><a href="#10-元素的自身样式属性" class="headerlink" title="10.元素的自身样式属性"></a>10.元素的自身样式属性</h3><pre><code>&lt;script&gt;    // offset系列：    offsetParent: 离这个元素最近的非静态定位的元素    offsetHeight: height + border + padding    offsetWidth: width + border + padding    offsetLeft: 元素左边距离offsetParent左边的间距    offsetTop: 元素顶部距离offsetParent顶部的距离    // client系列    clientWidth: width + padding    clientHeight: height + padding    clientLeft: 左边框宽度    clientTop: 上边框宽度    // scroll系列    scrollWidth: 内容的宽度（ 包含超出元素的内容）    scrollHeight: 内容的高度    scrollTop: 内容滚动出去的距离    scrollLeft: 内容滚动出去的距离&lt;/script&gt;</code></pre><hr><h3 id="11-轮播图案例"><a href="#11-轮播图案例" class="headerlink" title="11.轮播图案例"></a>11.轮播图案例</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    .box {        width: 730px;        height: 454px;        padding: 8px;        border: 1px solid green;        margin: 100px auto;    }    .inner {        position: relative;        overflow: hidden;        height: 454px;    }    .imglist {        width: 700%;        position: absolute;        left: 0;        transition: all .4s;    }    .imglist img {        width: 730px;    }    li {        float: left;    }    .list {        position: absolute;        bottom: 20px;        left: 50%;        transform: translateX(-50%);    }    .list i {        width: 20px;        height: 20px;        border-radius: 50%;        background-color: #fff;        color: #333;        float: left;        font-style: normal;        line-height: 20px;        font-size: 14px;        text-align: center;        margin-right: 10px;        cursor: pointer;    }    .list i:last-child {        margin-right: 0;    }    .list i.current {        background-color: skyblue;        color: #fff;    }    .arrow {        position: absolute;        width: 100%;        top: 50%;        margin-top: -30px;    }    .arrow-left,    .arrow-right {        width: 30px;        height: 60px;        position: absolute;        font: 20px/60px &quot;consolas&quot;;        color: #fff;        background-color: rgba(0, 0, 0, .3);        text-align: center;        cursor: pointer;    }    .arrow-right {        right: 0;    }&lt;/style&gt;&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;    &lt;div class=&quot;inner&quot; id=&quot;inner&quot;&gt;        &lt;ul class=&quot;imglist&quot; id=&quot;imglist&quot;&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/1.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/2.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/3.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;        &lt;div class=&quot;list&quot;&gt;            &lt;i class=&quot;current&quot;&gt;1&lt;/i&gt;            &lt;i&gt;2&lt;/i&gt;            &lt;i&gt;3&lt;/i&gt;        &lt;/div&gt;        &lt;div class=&quot;arrow&quot;&gt;            &lt;span class=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt;            &lt;span class=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var dots = document.querySelectorAll(&#39;.list i&#39;);    var arrowLeft = document.querySelector(&#39;.arrow-left&#39;);    var arrowRight = document.querySelector(&#39;.arrow-right&#39;);    var imglist = document.querySelector(&#39;#imglist&#39;);    var box = document.querySelector(&#39;#box&#39;);    var imgWidth = document.querySelector(&#39;#imglist img&#39;).offsetWidth;    // 准备全局步长，整体控制动画速度    var speed = 100;    // 准备全局索引值，整体控制图片索引切换    var keyIndex = 0;    for (var i = 0; i &lt; dots.length; i++) {        dots[i].dataset.index = i;        dots[i].onclick = function () {            for (var i = 0; i &lt; dots.length; i++) {                dots[i].classList.remove(&quot;current&quot;);            }            this.classList.add(&quot;current&quot;);            // 同步索引值：把小圆点的索引值也赋值给全局的索引值            keyIndex = this.dataset.index;            var target = keyIndex * imgWidth * -1;            imglist.style.left = target + &quot;px&quot;;        }    }    // 2. 点击左箭头    // 给左箭头绑定点击事件    arrowLeft.onclick = function () {        // =========== 模块1：边界处理 =============        // 2.1 如果是&lt;边界索引&gt;，开分支判断处理        if (keyIndex === 0) {            // 2.1.1 把索引值改成&lt;另一个边界&gt;            keyIndex = imglist.children.length - 1;        } else {            keyIndex--;        }        console.log(keyIndex);        // =========== 模块2：换图处理 =============        // 2.2.1 计算换图的目标值        var target = keyIndex * imgWidth * -1;        // 2.2.2 调用动画函数实现换图效果        // animate(imglist, target, speed);        imglist.style.left = target + &quot;px&quot;;        // =========== 模块3：小圆点处理 =============        // 2.3.1 排除所有小圆点        for (var i = 0; i &lt; dots.length; i++) {            dots[i].classList.remove(&quot;current&quot;);        }        dots[keyIndex].classList.add(&quot;current&quot;);    };    // 3. 给右箭头绑定点击事件    arrowRight.onclick = function () {        moveNext();    };    function moveNext() {        // =========== 模块1：边界处理 =============        // 3.1 如果是&lt;边界索引&gt;，开分支判断处理        if (keyIndex === imglist.children.length - 1) {            // 3.1.1 把索引值改成&lt;另一个边界&gt;            keyIndex = 0;            // 3.1.2 把图片换成另一张相同的图片        } else {            // 3.1.3 索引值增加            keyIndex++;        }        console.log(keyIndex)        // =========== 模块2：换图处理 =============        // 3.2.1 计算换图的目标值        var target = keyIndex * imgWidth * -1;        // 3.2.2 调用动画函数实现换图效果        // animate(imglist, target, speed);        imglist.style.left = target + &quot;px&quot;;        // =========== 模块3：小圆点处理 =============        // 3.3.1 排除所有小圆点        for (var i = 0; i &lt; dots.length; i++) {            dots[i].classList.remove(&quot;current&quot;);        }        // 通过当前索引值确立对应的小圆点        dots[keyIndex].classList.add(&quot;current&quot;);    }    // 4. 自动播放的功能    var playTime = 2000;    var timer = setInterval(function () {        moveNext();    }, playTime);    box.onmouseover = function () {        clearInterval(timer);    };    box.onmouseout = function () {        timer = setInterval(function () {            moveNext();        }, playTime);    }&lt;/script&gt;</code></pre><hr><h3 id="手风琴案例"><a href="#手风琴案例" class="headerlink" title="手风琴案例"></a>手风琴案例</h3><pre><code>&lt;style&gt;    * {        margin: 0;        padding: 0;    }    /* 去掉li标签自带的样式 点 */    ul {        list-style: none;    }    .wrap {        width: 1000px;        margin: 50px auto;    }    .slider {        width: 1000px;        height: 400px;        border: 1px solid red;        overflow: hidden;    }    .slider li {        width: 200px;        height: 400px;        float: left;        cursor: pointer;        /* 过渡属性 */        transition: all 0.4s;    }&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;ul id=&quot;slider&quot; class=&quot;slider&quot;&gt;        &lt;li&gt;            &lt;img src=&quot;./images/mi1.jpg&quot; alt=&quot;&quot; /&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;./images/mi2.jpg&quot; alt=&quot;&quot; /&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;./images/mi3.jpg&quot; alt=&quot;&quot; /&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;./images/mi4.jpg&quot; alt=&quot;&quot; /&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;img src=&quot;./images/mi5.jpg&quot; alt=&quot;&quot; /&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    // 1.获取所有的li元素    var lis = document.querySelectorAll(&#39;.slider li&#39;);    // 获取ul的宽度   一会要计算用    var ul = document.querySelector(&#39;.slider&#39;);    var ulWidth = parseInt(window.getComputedStyle(ul).width);    // console.log(ulWidth);    // 将ul的宽度评分给所有的li    for (var i = 0; i &lt; lis.length; i++) {        //将ul的宽度平分给每个li元素        lis[i].style.width = ulWidth / lis.length + &#39;px&#39;;    }    // 给每个里注册一个鼠标移入事件  mouseenter    // 先设置一个初始鼠标移入的li的宽度    var liWidth = 800;    for (var j = 0; j &lt; lis.length; j++) {        lis[j].onmouseenter = function () {            // 将当前的这个li的宽度变宽，其他的变窄            // 排他思想            for (var k = 0; k &lt; lis.length; k++) {                lis[k].style.width = (ulWidth - liWidth) / (lis.length - 1) + &#39;px&#39;;            }            this.style.width = liWidth + &#39;px&#39;;        }    }    // 给每个li注册一个鼠标离开事件    for (var v = 0; v &lt; lis.length; v++) {        lis[v].onmouseleave = function () {            for (var r = 0; r &lt; lis.length; r++) {                lis[r].style.width = ulWidth / lis.length + &#39;px&#39;;            }        }    }&lt;/script&gt;</code></pre><hr><h3 id="12-旋转木马案例"><a href="#12-旋转木马案例" class="headerlink" title="12.旋转木马案例"></a>12.旋转木马案例</h3><pre><code>&lt;style&gt;    /*初始化  reset*/    * {        margin: 0;        padding: 0    }    ul {        list-style: none    }    .wrap {        width: 1200px;        margin: 100px auto;    }    .slider {        height: 500px;        position: relative;    }    .slider li {        position: absolute;        left: 200px;        top: 0;        /* CSS3 过渡属性 */        transition: all .4s;    }    .slider li img {        width: 100%;    }    .prev,    .next {        width: 76px;        height: 112px;        position: absolute;        top: 50%;        margin-top: -56px;        background: url(images/prev.png) no-repeat;        z-index: 99;    }    .next {        right: 0;        background-image: url(images/next.png);    }    /* 旋转木马布局核心代码 */    .slider .zuo3 {        width: 400px;        top: 20px;        left: 50px;        opacity: 0.2;        z-index: 2;    }    .slider .zuo2 {        width: 600px;        top: 70px;        left: 0px;        opacity: 0.8;        z-index: 3;    }    .slider .zhong {        width: 800px;        top: 100px;        left: 200px;        opacity: 1;        z-index: 4;    }    .slider .you2 {        width: 600px;        top: 70px;        left: 600px;        opacity: 0.8;        z-index: 3;    }    .slider .you3 {        width: 400px;        top: 20px;        left: 750px;        opacity: 0.2;        z-index: 2;    }&lt;/style&gt;&lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt;    &lt;div class=&quot;slider&quot; id=&quot;slider&quot;&gt;        &lt;ul&gt;            &lt;li class=&quot;&quot;&gt;                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic1.jpg&quot; /&gt;&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;&quot;&gt;                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic2.jpg&quot; /&gt;&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;&quot;&gt;                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic3.jpg&quot; /&gt;&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;&quot;&gt;                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic4.jpg&quot; /&gt;&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;&quot;&gt;                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic5.jpg&quot; /&gt;&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;div class=&quot;arrow&quot; id=&quot;arrow&quot;&gt;            &lt;a class=&quot;prev&quot; href=&quot;javascript:;&quot; id=&quot;arrLeft&quot;&gt;&lt;/a&gt;            &lt;a class=&quot;next&quot; href=&quot;javascript:;&quot; id=&quot;arrRight&quot;&gt;&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var arr = [&#39;zuo3&#39;, &#39;zuo2&#39;, &#39;zhong&#39;, &#39;you2&#39;, &#39;you3&#39;];    // 页面一加载就将这些类名设置给li元素    // 封装一个设置类名的函数    function setClassName(Elements, array) {        for (var i = 0; i &lt; Elements.length; i++) {            Elements[i].className = array[i];        }    }    // 获取所有的li    var lis = document.querySelectorAll(&#39;.slider li&#39;);    var arrLeft = document.querySelector(&#39;.prev&#39;);    var arrRight = document.querySelector(&#39;.next&#39;);    // 第一次进来页面调用一次方法    setClassName(lis, arr)    // 给左右的按钮注册点击事件    // 给右边的按钮注册点击事件    arrRight.onclick = function () {        arr.push(arr.shift());        // 将改变的数组中的类名以此设置给li元素        // for(var i=0;i&lt;lis.length;i++) {        //     lis[i].className = arr[i];        // }        setClassName(lis, arr);    }    // 给左边按钮注册点击事件    arrLeft.onclick = function () {        arr.unshift(arr.pop());        // 将改变之后的数组中的每一项设置给li元素        // for(var j=0;j&lt;lis.length;j++) {        //     lis[j].className = arr[j];        // }        setClassName(lis, arr);    }&lt;/script&gt;</code></pre><hr><h3 id="13-forEach使用"><a href="#13-forEach使用" class="headerlink" title="13.forEach使用"></a>13.forEach使用</h3><pre><code>&lt;!-- 案例: --&gt;&lt;script&gt;    var arr = [1, 2, 3, 4, 5, 6];    // for(var i=0;i&lt;arr.length;i++) {    //     console.log(arr[i]);    // }    // ES6中提供的一个循环变量的方法    // forEach(函数)    arr.forEach(function (item, index) {        // console.log(item);        // console.log(index);        console.log(item + &#39;------&#39; + index)    })&lt;/script&gt; </code></pre><hr><h3 id="14-存钱取钱案例："><a href="#14-存钱取钱案例：" class="headerlink" title="14.存钱取钱案例："></a>14.存钱取钱案例：</h3><pre><code>&lt;button class=&quot;setMoney&quot;&gt;存钱&lt;/button&gt;&lt;button class=&quot;getMoney&quot;&gt;取钱&lt;/button&gt;&lt;h3&gt;你的账户余额为：&lt;span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;script&gt;    var setMoney = document.querySelector(&#39;.setMoney&#39;);    var getMoney = document.querySelector(&#39;.getMoney&#39;);    var span = document.querySelector(&#39;span&#39;);    var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money : 0);    span.innerText = money;    setMoney.onclick = function () {        do {            var num = Number(prompt(&#39;请输入你要存储的money!&#39;));            if (num &lt; 0) {                alert(&#39;请输入正确金额&#39;);                return;            }        } while (!num)        var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money :            0);        money += num;        this.dataset.id = new Date().getTime();        var data = {            money,            id: this.dataset.id        }        localStorage.setItem(&#39;money&#39;, JSON.stringify(data));        span.innerText = money;    }    getMoney.onclick = function () {        do {            var num = Number(prompt(&#39;请输入你要取多少money!&#39;));            if (num &lt; 0) {                alert(&#39;请输入正确金额&#39;);                return;            }        } while (!num)        var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money :            0);        var sum = money - num;        if (sum &lt; 0) {            alert(&#39;你的余额已不足！&#39;);            return;        }        var data = {            money: sum,            id: setMoney.dataset.id        }        localStorage.setItem(&#39;money&#39;, JSON.stringify(data));        span.innerText = sum    }&lt;/script&gt;</code></pre><hr><h1 id="js高级课程"><a href="#js高级课程" class="headerlink" title="js高级课程"></a>js高级课程</h1><h2 id="第一天面向对象"><a href="#第一天面向对象" class="headerlink" title="第一天面向对象"></a>第一天面向对象</h2><h3 id="1-定义及让权-两种方法"><a href="#1-定义及让权-两种方法" class="headerlink" title="1.$定义及让权(两种方法)"></a>1.$定义及让权(两种方法)</h3><pre><code>&lt;script&gt;    // 1. jQuery     // 案例：    var $ = 10;    console.log($);    // 第一种：解决方法 $ 等价jQuery    jQuery(function () {        jQuery(&quot;#btn&quot;).click(function () {            console.log(&quot;大家好好听课，开心快乐的学会面向对象&quot;);        });    })    // 2. $.noConflict(); // 让权    // 案例：    var xy = $.noConflict(); //等价于让权利，把$权利让给了xy    var $ = 10;    console.log($);    // 第二种：解决方法 $ 等价jQuery    xy(function () {        xy(&quot;#btn&quot;).click(function () {            console.log(&quot;大家好好听课，开心快乐的学会面向对象&quot;);        });    })&lt;/script&gt;</code></pre><hr><h3 id="2-判断当前数据类型对象（当前对象-）"><a href="#2-判断当前数据类型对象（当前对象-）" class="headerlink" title="2.判断当前数据类型对象（当前对象 ）"></a>2.判断当前数据类型对象（当前对象 ）</h3><pre><code>&lt;script&gt;    var nul = null;    console.log(typeof nul);    Object.prototype.toString.call(nul); // 输出当前对象 &lt;/script&gt;</code></pre><hr><h3 id="3-js组成部分"><a href="#3-js组成部分" class="headerlink" title="3.js组成部分"></a>3.js组成部分</h3><pre><code>    1.ECMAScript 2.DOM（文档对象模型） 3.BOM(浏览器对象模型)</code></pre><hr><h3 id="4-js的数据类型"><a href="#4-js的数据类型" class="headerlink" title="4.js的数据类型"></a>4.js的数据类型</h3><pre><code>    基本数据类型和引用数据类型</code></pre><hr><h3 id="5-typeof-打印的都是字符串"><a href="#5-typeof-打印的都是字符串" class="headerlink" title="5.typeof 打印的都是字符串"></a>5.typeof 打印的都是字符串</h3><pre><code>&lt;script&gt;    var nul = null;    console.log(typeof nul);    Object.prototype.toString.call(nul);&lt;/script&gt;</code></pre><hr><h3 id="6-判断当前变量属于哪个对象"><a href="#6-判断当前变量属于哪个对象" class="headerlink" title="6.判断当前变量属于哪个对象"></a>6.判断当前变量属于哪个对象</h3><pre><code>&lt;script&gt;    Object.prototype.toString.call(nul);&lt;/script&gt;</code></pre><hr><h3 id="7-引用都是object对象-（typeof打印）"><a href="#7-引用都是object对象-（typeof打印）" class="headerlink" title="7.引用都是object对象 （typeof打印）"></a>7.引用都是object对象 （typeof打印）</h3><pre><code>&lt;script&gt;    var arr = [1, 2, 2]    console.log(typeof arr) // 输出object &lt;/script&gt;</code></pre><hr><h3 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h3><pre><code>    基本数据类型除了null 特例 返回object，其他都返回对应的数据类型    引用数据类型除了function() 返回function  其他都是object</code></pre><hr><h3 id="9-null-undefined-是true（隐式转换）"><a href="#9-null-undefined-是true（隐式转换）" class="headerlink" title="9.null == undefined 是true（隐式转换）"></a>9.null == undefined 是true（隐式转换）</h3><h3 id="10-NaN-翻译是-not-a-number"><a href="#10-NaN-翻译是-not-a-number" class="headerlink" title="10.NaN 翻译是 not a number"></a>10.NaN 翻译是 not a number</h3><pre><code>&lt;script&gt;    // 我们向isNaN传递一个参数，它的本意是通过Number()方法尝试转换参数的类型为Number,如果转换成功返回false，否则失败转返回true；    isNaN(123) // false    isNaN(&#39;123时间跳跃&#39;) // true&lt;/script&gt;</code></pre><hr><h3 id="11-号和"><a href="#11-号和" class="headerlink" title="11.== 号和 ==="></a>11.== 号和 ===</h3><pre><code>    == 只是比较值    === 比较值和类型</code></pre><hr><h3 id="12-amp-（或）-（与）"><a href="#12-amp-（或）-（与）" class="headerlink" title="12.&amp;（或） ||（与）"></a>12.&amp;（或） ||（与）</h3><pre><code>&lt;script&gt;    // 逻辑与 || 如果有一个为true， 结果都为真， 除非两个都为假， 结果才为假    // 2.1 只要有一个条件为true时， 结果就为true；    // 2.2 当两个条件都为false时， 结果才为false；    // 2.3 当一个条件为true时， 后面的条件不再判断    console.log(5 &amp;&amp; 4); // 当结果为真时，返回第二个为真的值4     console.log(0 &amp;&amp; 4); // 当结果为假时，返回第一个为假的值0     console.log(5 || 4); // 当结果为真时，返回第一个为真的值5     console.log(0 || 0); // 当结果为假时，返回第二个为假的值0     console.log((3 || 2) &amp;&amp; (5 || 0)); //5     var a = obj || &quot; &quot;; // 如果 obj 为空，a就赋值为 &quot; &quot; ；    var a = check() &amp;&amp; do(); // 如果check()返回为真，就执行do()，并将结果赋值给 a;    // 补充:    // 表达式a &amp;&amp; 表达式b: 计算表达式a（ 也可以是函数） 的运算结果，    // 如果为 True, 执行表达式b（ 或函数）， 并返回b的结果；    // 如果为 False， 返回a的结果；    // 表达式a || 表达式b: 计算表达式a（ 也可以是函数） 的运算结果，    // 如果为 Fasle, 执行表达式b（ 或函数）， 并返回b的结果；    // 如果为 True， 返回a的结果；&lt;/script&gt;</code></pre><hr><h3 id="13-引用类型比较的地址"><a href="#13-引用类型比较的地址" class="headerlink" title="13.引用类型比较的地址"></a>13.引用类型比较的地址</h3><pre><code>&lt;script&gt;    var arr1 = [1, 2, 3, 4, 5]    var arr2 = [1, 2, 3, 4, 5]    console.log(arr1 == arr2) // false    // 值类型和引用类型:    // 值类型传递的是指    // 引用类型传递的是地址&lt;/script&gt;</code></pre><hr><h3 id="14-数组"><a href="#14-数组" class="headerlink" title="14.数组"></a>14.数组</h3><pre><code>&lt;script&gt;    var arr = [] // 创建方式名字：字面量&lt;/script&gt;</code></pre><hr><h3 id="15-函数传参值和引用no区别"><a href="#15-函数传参值和引用no区别" class="headerlink" title="15.函数传参值和引用no区别"></a>15.函数传参值和引用no区别</h3><pre><code>    1.值类型传参 ，只改边方法内部，    2.引用类型传参，能改变全局变量，因为引用是地址，改变是同一地址</code></pre><hr><h3 id="16-创建空对象"><a href="#16-创建空对象" class="headerlink" title="16.创建空对象"></a>16.创建空对象</h3><pre><code>&lt;script&gt;    var obj ={};&lt;/script&gt;</code></pre><hr><h3 id="17-对象增加属性"><a href="#17-对象增加属性" class="headerlink" title="17.对象增加属性"></a>17.对象增加属性</h3><pre><code>&lt;script&gt;    // 1. 第一种    obj.name = &#39;dddd&#39;,        obj.age = 10    // 2. 第二种[]    obj[&#39;name&#39;] = &#39;xiaoming&#39;;    obj[&#39;sex&#39;] = 1;&lt;/script&gt;</code></pre><hr><h3 id="18-对象增加方法"><a href="#18-对象增加方法" class="headerlink" title="18.对象增加方法"></a>18.对象增加方法</h3><pre><code>&lt;script&gt;    // 1.第一种    obj.say = function () {}    obj.say();    // 2.通过中[]    obj[&#39;say&#39;] = function () {}    // 调用：    obj[&#39;say&#39;]();&lt;/script&gt;</code></pre><hr><h3 id="19-修改属性"><a href="#19-修改属性" class="headerlink" title="19.修改属性"></a>19.修改属性</h3><pre><code>&lt;script&gt;    // 对象属性总结： 有则改， 无则增    // 1. 第一种    obj.name = &#39;tt&#39;;    obj.age = 10;    // 2. 第二种    obj[&#39;name&#39;] = &#39;ppp&#39;;    obj[&#39;sex&#39;] = 8;    console.log(obj[&#39;name&#39;])&lt;/script&gt;</code></pre><hr><h3 id="20-删除属性"><a href="#20-删除属性" class="headerlink" title="20.删除属性"></a>20.删除属性</h3><pre><code>&lt;script&gt;    // 1. delete obj.name // 删除成功返回true    console.log(delete obj.name)    // 2. 第二种[]：    delete obj[&#39;name&#39;]&lt;/script&gt;</code></pre><hr><h3 id="21-语法处理数字key-查询"><a href="#21-语法处理数字key-查询" class="headerlink" title="21.[]语法处理数字key 查询"></a>21.[]语法处理数字key 查询</h3><pre><code>&lt;script&gt;    var per = {        1: &#39;小明&#39;,        201: 54    }    console.log(per[&#39;3&#39;]) // 也可以per[3] 只有数字的可以省略引号    console.log(obj[&quot;name&quot;]);&lt;/script&gt;</code></pre><hr><h3 id="22-in关键字的基本使用"><a href="#22-in关键字的基本使用" class="headerlink" title="22.in关键字的基本使用"></a>22.in关键字的基本使用</h3><pre><code>&lt;script&gt;    // in判断一个成员（ 属性或函数） 是否在对象中存在， 如果存在返回true， 反之返回false    // 1. 语法格式： key in obj: key必须是字符串    var a = &quot;name&quot;    console.log(a in obj); // 这样是可以的 输出true    // 案例：    var obj = {        name: &#39;jkjkkj&#39;,        age: 12    }    console.log(&quot;name&quot; in obj); // 返回true    //in遍历循环    for (var key in obj) {        alert(key); // name；        console.log(key, obj[key]);    }    // 案例：    var obj = {        name: &quot;xiaoqiang&quot;,        age: 18,        say: function () {            console.log(&quot;我是方法&quot;);        }    };    for (var key in obj) {        if (typeof obj[key] != &#39;function&#39;) {            console.log(key, obj[key]);        }    }&lt;/script&gt;</code></pre><hr><h3 id="23-判断一个数组存在的元素-方法两种"><a href="#23-判断一个数组存在的元素-方法两种" class="headerlink" title="23.判断一个数组存在的元素(方法两种:)"></a>23.判断一个数组存在的元素(方法两种:)</h3><pre><code>&lt;script&gt;    // 1. arr[key] == &quot;B&quot;;    // 2. indexOf();    // 1. 第一种    var arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];    // 第一种写法：for in    for (var key in arr) { //推 荐第一个方法        // 判断        if (arr[key] == &quot;B&quot;) { // 存在            console.log(&quot;存在&quot;);        }    }    // 2. 第二种    if (arr.indexOf(&quot;B&quot;) != -1) { //表 示存在        console.log(&quot;存在&quot;);    }&lt;/script&gt;</code></pre><hr><h3 id="24-delete关键字基本使用"><a href="#24-delete关键字基本使用" class="headerlink" title="24.delete关键字基本使用"></a>24.delete关键字基本使用</h3><pre><code>&lt;script&gt;    // 语法： delete 对象.成员 或 对象[成员]    // 作用： 删除对象的成员， 删除成功返回true， 反之返回false    // 1. 可以删除未定义var的变量    // 案例：    test9 = &quot;这是一个未使&quot;;    console.log(test);    console.log(delete test9); // true    // 2. 不可以删除 var声明的变量    var str = &quot;demo&quot;;    console.log(delete str); // false    console.log(str); // demo    // 3. 可以直接删除window上的属性    window.demo2 = &quot;demo001&quot;;    console.log(delete window.demo2); // true    console.log(window.demo2); // undefined&lt;/script&gt;</code></pre><hr><h3 id="25-for循环跳出"><a href="#25-for循环跳出" class="headerlink" title="25.for循环跳出"></a>25.for循环跳出</h3><pre><code>    1.break;    跳出整个for循环    2.continue; 跳出本次循环</code></pre><hr><h3 id="26-异常处理"><a href="#26-异常处理" class="headerlink" title="26.异常处理"></a>26.异常处理</h3><pre><code>&lt;script&gt;    // 1.try： 可能出错的代码块    // 2.catch： 处理try代码块中抛出的异常    // 3.throw： 抛出自定义的异常    // 4.finally： 无论上面的程序是否有错误， 都会执行性的代码块    // 案例：    var a = 123;    try {        console.log(a);        console.log(b);    } catch (e) {        // throw &quot;这是一个错误信息&quot;;        throw {            errorMsg: e, // 具体的错误信息            errorCode: 10001 // 错误码        }    } finally { // 加上finally是一个完整的结构        // 不管前面的代码有没有出错,都会执行        console.log(&quot;不管前面的代码有没有出错,都会执行这个代码块中的代码&quot;);    }&lt;/script&gt;</code></pre><hr><h2 id="第二天-1"><a href="#第二天-1" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-面向对象三大特性"><a href="#1-面向对象三大特性" class="headerlink" title="1.面向对象三大特性"></a>1.面向对象三大特性</h3><pre><code>    1.封装    2.多态 ：多种形态    3.继承(组合继承, 原型继承，原型链继承，call继承，经典继承，class继承)</code></pre><hr><h3 id="2-创建对象封装案例："><a href="#2-创建对象封装案例：" class="headerlink" title="2.创建对象封装案例："></a>2.创建对象封装案例：</h3><pre><code>&lt;script&gt;    var p = {        name: &quot;xiao song&quot;,        age: 10,        sex: 1,        eat: function () {            console.log(&quot;吃饭&quot;);        },        sleep: function () {            console.log(&quot;睡觉&quot;);        }    }    console.log(p.name); // 访问对象的属性    p.eat(); // 访问对象的方法&lt;/script&gt;</code></pre><hr><h3 id="3-获取dom元素"><a href="#3-获取dom元素" class="headerlink" title="3.获取dom元素"></a>3.获取dom元素</h3><pre><code>&lt;script&gt;    // 创建div元素： document.createElement(&quot;div&quot;);    // 获取元素对象： document.getElementById(&quot;div&quot;);    // 获取div标签： document.getElementsByTagName(&quot;div&quot;)[0];    // 访问元素的文本内容： div.innerText;    // 页面追加元素： document.body.appendChild(div);    // 页面删除子元素： document.body.removeChild(div);    // 案例：    document.getElementsByTagName(&quot;p&quot;);    document.getElementsByClassName(&quot;test&quot;);    document.getElementById(&quot;test&quot;);    oDiv.innerText = &quot;div&quot; + i;&lt;/script&gt;</code></pre><hr><h3 id="4-封装函数案例"><a href="#4-封装函数案例" class="headerlink" title="4.封装函数案例"></a>4.封装函数案例</h3><pre><code>&lt;script&gt;    var $ = {        setStype: function (eles, bgcolor) {            for (var i = 0; i &lt; eles.length; i++) {                eles[i].style.backgroundColor = bgcolor;                eles[i].style.border = &quot;1px solid #000&quot;;                eles[i].style.color = &quot;white&quot;;            }        },        getElementsByTagName: function (tagName) {            return document.getElementsByTagName(tagName);        },        getElementsByClassName: function (className) {            return document.getElementsByClassName(className);        }    }    var ps = $.getElementsByTagName(&quot;p&quot;)    $.setStype(ps, &quot;green&quot;);    var tests = $.getElementsByClassName(&quot;test&quot;);    $.setStype(tests, &quot;red&quot;);&lt;/script&gt;</code></pre><hr><h3 id="5-id处理成数组"><a href="#5-id处理成数组" class="headerlink" title="5.id处理成数组"></a>5.id处理成数组</h3><pre><code>&lt;script&gt;    getElementById: function (eleId) {        return [document.getElementById(eleId)];​    }&lt;/script&gt;</code></pre><hr><h3 id="6-创建对象-五种方式-1-5种"><a href="#6-创建对象-五种方式-1-5种" class="headerlink" title="6.创建对象 (五种方式+1 5种)"></a>6.创建对象 (五种方式+1 5种)</h3><pre><code>&lt;script&gt;    // 1.字面量创建对象 var obj={}    // 案例：    var book1 = {        name: &quot;JavaScript权威指南&quot;,        price: 100,        author: &quot;tim&quot;,        showInfo: function () {            console.log(this.name, this.price, this.author);        }    }    console.log(book1);    // 2.内置构造函数创建对象 var book2 = new Object();    // 案例：    var book2 = new Object();    book2.name = &quot;JS&quot;;    book2.price = 10;    book2.author = &quot;作者&quot;;    book2.showInfo = function () {        console.log(this.name, this.price, this.author);    }    book2.showInfo();    // 3.工厂模式创建对象（this）instanceof判断 --- function person(){}    // 这样有缺陷 console.log(book3 instanceof createBook); //结果false    // 3.1 案例：    function createBook(name, price, author) {        var book = new Object();        book.name = name;        book.price = price;        book.author = author;        book.showInfo = function () {            console.log(this.name, this.price, this.author);        }        return book;    }    var book3 = createBook(&quot;bookName1&quot;, 10, &quot;author1&quot;);    var book4 = createBook(&quot;bookName2&quot;, 10, &quot;author2&quot;);    console.log(book3);    console.log(book4);    // 4. 自定义构造函数方式--- function Person(name, age) {}    // 4.1 解决是：采用（this）: 在全局作用下this 指向window，new之后指向这个对象    1. 在函数内部默认会创建一个空对象    var obj = new Object();    // 4.2 默认把创建好的对象赋值给this this = obj;    // 4.3 默认设置this的原型对象为当前构造函数的原型对象    // 4.4 通过this添加属性和方法     // 4.5. 默认会把内部创建的对象返回    return this;    function CreatePerson(name, age, sex) {        this.name = name;        this.age = age;        this.sex = sex; // 默认的返回值return this    }    var p = new createPerson(&quot;Neld&quot;, 10, 1);    var p2 = new createPerson(&quot;Song&quot;, 12, 0);    console.log(p instanceof createPerson); // 是true    // 5.Object.create() 原型链方式创建    // 优势：好处可以创建一个没有原型链的对象，优势：提高检索的速度    // 5.1:    var per = {        name: &#39;小刘&#39;,        age: 45    }    var obj = Object.create(per);    console.log(obj);    // 5.2:    var nul = Object.create(null);    nul.name = &quot;测试成功&quot;;    console.log(nul);    // 6.assign:将多个对象合并到一个对象中    var obj = {        name: &quot;zs&quot;,        age: 18    }    console.log(Object.assign(obj, {        info: &quot;信息内容&quot;    }, {        adderss: &quot;地址&quot;    }, {        name: &quot;lw&quot;    })) // 如果后面的对象和前面重名了，就直接修改了前面的对象名称    重复的属性后面的会直接覆盖前面的    // 6.1合并新对象        let result1 = Object.assign({}, obj1, obj2);&lt;/script&gt;</code></pre><hr><h3 id="7-构造函数创建对象的返回值"><a href="#7-构造函数创建对象的返回值" class="headerlink" title="7.构造函数创建对象的返回值"></a>7.构造函数创建对象的返回值</h3><pre><code>    1. 如果返回值类型的数据，无效 ，仍然返回创建好的对象（this），不做任何修改         2. 如果返回引用类型的数据，有效，则返回指定的数据，不再返回this。 返回指定的对象</code></pre><hr><h3 id="8-回调函数"><a href="#8-回调函数" class="headerlink" title="8.回调函数"></a>8.回调函数</h3><pre><code>&lt;script&gt;    // 函数如果作为参数来使用我们一般叫做回调函数    // 1. 匿名函数调用    // 案例1：    function f1(fn) {        console.log(&quot;我是第一个函数&quot;);        fn();    }    f1(function () {        console.log(&quot;我是一个 匿名函数&quot;);    });    // 2. 命名函数调用命名函数    function f1(fn) {        console.log(&quot;我是第一个函数&quot;);        fn();    }    function f2() {        console.log(&#39;我是一份命名函数&#39;);    }    f1(f2);&lt;/script&gt;</code></pre><hr><h3 id="9-高阶函数"><a href="#9-高阶函数" class="headerlink" title="9.高阶函数"></a>9.高阶函数</h3><pre><code>&lt;script&gt;    // 函数如果作为返回值来使用----我们叫做高阶函数（return 可以跟任意数据类型，当然也可以跟函数------函数是上帝，可以造万物）    function f1() {        console.log(&quot;我是第一个函数&quot;);        return function () {            console.log(&#39;内部函数体&#39;)        }    }    var yunxing = f1();    console.log(yunxing());&lt;/script&gt;</code></pre><hr><h3 id="10-constructor判断对象构造器"><a href="#10-constructor判断对象构造器" class="headerlink" title="10.constructor判断对象构造器"></a>10.constructor判断对象构造器</h3><pre><code>&lt;script&gt;    // 使用constructor属性可以获取到创建对象使用的构造器函数对象， 所以我们可以通过判断构造器的类型来得知创建的对象的类型-- - constructor和instanceof一样的都是找父类 是返回true    // 案例：    function Person(name) {        this.name = name;    }    function Dog(name) {        this.name = name;    }    var p = new Person(&quot;p&quot;);    var d = new Dog(&quot;d&quot;);    console.log(p.constructor); // 打印得到Person函数对象    console.log(d.constructor); // 打印得到Dog函数对象    if (p.constructor == Person) {        console.log(&quot;是Person对象&quot;);    }    if (d.constructor == Dog) {        console.log(&quot;是Dog对象&quot;);    }&lt;/script&gt;</code></pre><hr><h3 id="11-instanceof关键词"><a href="#11-instanceof关键词" class="headerlink" title="11.instanceof关键词"></a>11.instanceof关键词</h3><pre><code>&lt;script&gt;    //instanceof关键字可以直接用来判断对象的类型，如果是指定的类型，返回true，反之返回false。---找父类    // 案例：    function Person(name, age) { // 构造函数---构造器        this.name = name;        this.age = age;        this.sayHi = function () {            console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);        }    }    var per1 = new Person(&quot;zs&quot;, 18);    console.log(per1 instanceof Person); // true&lt;/script&gt;</code></pre><hr><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="1-this回顾"><a href="#1-this回顾" class="headerlink" title="1.this回顾"></a>1.this回顾</h3><h3 id="2-查看原型"><a href="#2-查看原型" class="headerlink" title="2.查看原型"></a>2.查看原型</h3><pre><code>&lt;script&gt;    console.dir(对象);&lt;/script&gt;</code></pre><hr><h3 id="3-原型三句话"><a href="#3-原型三句话" class="headerlink" title="3.原型三句话"></a>3.原型三句话</h3><pre><code>    1.每一个构造函数都有一个prototype属性，指向它自己原型的对象    2.每一个实例化对象都有一个__proto__属性,指向它所属类的原型对象    3.每一个原型对象都有一个constructor属性，指向构造函数本身</code></pre><hr><h3 id="4-获取原型三个方法"><a href="#4-获取原型三个方法" class="headerlink" title="4.获取原型三个方法"></a>4.获取原型三个方法</h3><pre><code>&lt;script&gt;    // 1、 构造函数.prototype    // 2、 实例化对象.__proto__    // 3、 Object.getPrototypeOf(实例化对象)    // 1. Person.prototype 2. 实例化对象.__proto__ 注意(两条线) 3. Object.getPrototypeOf(实例化 对象)    // 案例：    function Person(name, age) {        this.name = name; // 属性        this.age = age; // 属性    }    // 方法放在原型上    Person.prototype.sayH = function () {        console.log(&#39;我是原型上的方法&#39;);    }    var per1 = new Person(&quot;lw&quot;, 18);    console.log(per1);    console.log(Person.prototype == per1.__proto__);    console.log(Person.prototype == Object.getPrototypeOf(per1));    console.log(per1.__proto__ == Object.getPrototypeOf(per1));&lt;/script&gt;</code></pre><hr><h3 id="5-this的重新认识-创建对象补充"><a href="#5-this的重新认识-创建对象补充" class="headerlink" title="5.this的重新认识(创建对象补充)"></a>5.this的重新认识(创建对象补充)</h3><pre><code>&lt;script&gt;    // call或者apply方法修改this的指向, 借用对象的属性    // 案例:        function Person(name, age) {            // var obj = new Object();            // this = obj;            // obj.name = name            // ob.__proto__ = Person.prototype;            this.name = name;            this.age = age;            // return this        }    // 实例化对象    var per1 = new Person(&quot;ZS&quot;, 18);    console.log(per1);&lt;/script&gt;</code></pre><hr><h3 id="6-将定义的方法添加到对象中"><a href="#6-将定义的方法添加到对象中" class="headerlink" title="6.将定义的方法添加到对象中"></a>6.将定义的方法添加到对象中</h3><pre><code>&lt;script&gt;    function demo() {        console.log(this);    }    var obj = {        name: &quot;zs&quot;    };    obj.demo = demo; // 有则改，无则增    obj.demo();&lt;/script&gt;</code></pre><hr><h3 id="7-函数共享-引入原型对象"><a href="#7-函数共享-引入原型对象" class="headerlink" title="7.函数共享(引入原型对象)"></a>7.函数共享(引入原型对象)</h3><pre><code>&lt;script&gt;    function Person(name, age) {        this.name = name; // 属性        this.age = age; // 属性        // this.sayHi = function() {这样不能共享        //     console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);        // };    }    // 原型的两大特点：数据共享，继承  原型prototype    Person.prototype.sayHi = function () { // 一般来说方法都放在原型上        console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);    }    // 实例化对象    var per1 = new Person(&quot;lw&quot;, 18);    console.log(per1);    // 看原型的方法    console.dir(per1)    per1.sayHi();    // 实例化对象    var per2 = new Person(&quot;zs&quot;, 16);    console.log(per2);    per2.sayHi();&lt;/script&gt;</code></pre><hr><h3 id="8-多个方法放在原型里（原型中改变父类指向）"><a href="#8-多个方法放在原型里（原型中改变父类指向）" class="headerlink" title="8.多个方法放在原型里（原型中改变父类指向）"></a>8.多个方法放在原型里（原型中改变父类指向）</h3><pre><code>&lt;script&gt;    // 注意: constructor: Person, // 这句改变了指向    // 案例：（ 如果对象这样定义）    function Person(name, age) {        this.name = name;        this.age = age;    }    Person.prototype = {        constructor: Person, //解决只需这行        sayHi: function () {            console.log(&quot;改变指向&quot;);        }    }    var per = new Person(&#39;XIAOO&#39;, 1);    console.log(per.constructor);&lt;/script&gt; </code></pre><hr><h3 id="9-hasOwnProperty和in属性操作-（私有属性和公有属性）判断"><a href="#9-hasOwnProperty和in属性操作-（私有属性和公有属性）判断" class="headerlink" title="9.hasOwnProperty和in属性操作 （私有属性和公有属性）判断"></a>9.hasOwnProperty和in属性操作 （私有属性和公有属性）判断</h3><pre><code>&lt;script&gt;    // 案例1.（in） 公有和私有    // 检测私有属性    console.log(&quot;name&quot; in per1); // true    console.log(&quot;age&quot; in per1); // true    // 检测公用属性    console.log(&quot;sayHi&quot; in per1);    console.log(&quot;play&quot; in per1);    // 案例2.（hasOwnProperty）只找私有    // 私有的属性    console.log(per1.hasOwnProperty(&quot;name&quot;));    console.log(per1.hasOwnProperty(&quot;age&quot;));    // 检测不到原型上的方法    console.log(per1.hasOwnProperty(&quot;sayHi&quot;));    console.log(per1.hasOwnProperty(&quot;play&quot;));    // 需求1： 检测对象中是否存在某个指定的属性(该属性只在实例对象上) hasOwnProperty 有返回true    // 需求2: 检测对象中是否存在指定的某个属性(该属性只存在原型对象上) onlyPrototypePro    // 案例：    // 函数写出需求    function onlyPrototypePro(key, obj) { // key 属性，obj对象        return key in obj &amp;&amp; !obj.hasOwnProperty(key); // 剩下的就是公有属性和方法    }    console.log(isPublic(&quot;sayHi&quot;, per1));&lt;/script&gt;</code></pre><hr><h3 id="10-isPrototypeOf和instanceof"><a href="#10-isPrototypeOf和instanceof" class="headerlink" title="10.isPrototypeOf和instanceof"></a>10.isPrototypeOf和instanceof</h3><pre><code>&lt;script&gt;    // 1. isPrototypeOf： 判断某个对象是否是指定对象的原型对象, 如果是返回true， 反之返回false    console.log(Person.prototype.isPrototypeOf(per));    // 2. instanceof--找父类    console.log(per1 instanceof Person);&lt;/script&gt;</code></pre><hr><h3 id="11-混入式继承-浅拷贝"><a href="#11-混入式继承-浅拷贝" class="headerlink" title="11.混入式继承(浅拷贝)"></a>11.混入式继承(浅拷贝)</h3><pre><code>&lt;script&gt;    // 案例：    var obj1 = {        name: &quot;zs&quot;,        age: 18,        car: {            name: &quot;mini&quot;        }    }    var obj2 = {};    for (var key in obj1) {        obj2[key] = obj1[key];    }    obj1.car.name = &quot;bus&quot;;    console.log(obj1);    console.log(obj2);&lt;/script&gt;</code></pre><hr><h3 id="12-原型式继承（原型式继承跟混入式继承都存在数据共享问题。）"><a href="#12-原型式继承（原型式继承跟混入式继承都存在数据共享问题。）" class="headerlink" title="12.原型式继承（原型式继承跟混入式继承都存在数据共享问题。）"></a>12.原型式继承（原型式继承跟混入式继承都存在数据共享问题。）</h3><pre><code>&lt;script&gt;    Person.prototype = Animal.prototype; // 原型式继承        // 案例：    // 定义一个Animal    function Animal() {    }    // 原型加方法    Animal.prototype.sayHI = function () {        console.log(&quot;我是原型身上的方法&quot;);    }    //定义一个Person    function Person() {    }    // 原型式继承    Person.prototype = Animal.prototype; // 原型式继承    Animal.prototype.say = function () {        console.log(&quot;我是新加的方法&quot;);    }    var per1 = new Person();    console.log(per1);    var ani = new Animal();    console.log(ani);&lt;/script&gt;</code></pre><hr><h3 id="13-原型封装方法-原型增加方法"><a href="#13-原型封装方法-原型增加方法" class="headerlink" title="13.原型封装方法(原型增加方法)"></a>13.原型封装方法(原型增加方法)</h3><pre><code>&lt;script&gt;    // 缺陷： 在原型上封装我们要使用的方法， 这样就不会影响到被人使用Array, 导致检索时间太长。    // 案例：    var arr1 = [1, 2, 3];    var arr2 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;];    //增加原型方法    Array.prototype.getLength = function () {        return this.length;    }    console.log(arr1.getLength());    console.dir(arr1)&lt;/script&gt;</code></pre><hr><h3 id="14-原型封装方法-原型增加方法-升级版（安全扩展）j解决缺陷"><a href="#14-原型封装方法-原型增加方法-升级版（安全扩展）j解决缺陷" class="headerlink" title="14.原型封装方法(原型增加方法)升级版（安全扩展）j解决缺陷"></a>14.原型封装方法(原型增加方法)升级版（安全扩展）j解决缺陷</h3><pre><code>&lt;script&gt;    案例：    function MyArray() {    }    MyArray.prototype = new Array(); // 我们继承这个new Array()    MyArray.prototype.getLength = function () {        return this.length;    }    // 实例化对象    var arr1 = new MyArray();    arr1.push(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;);    console.log(arr1.getLength());&lt;/script&gt;    </code></pre><hr><h3 id="15-原型对象Object"><a href="#15-原型对象Object" class="headerlink" title="15.原型对象Object"></a>15.原型对象Object</h3><pre><code>&lt;script&gt;    console.log(Person.prototype.__proto__.constructor); // 指向原型对象    console.log(Object.prototype.__proto__);&lt;/script&gt;</code></pre><hr><h2 id="第四天-1"><a href="#第四天-1" class="headerlink" title="第四天"></a>第四天</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><h3 id="2-Object-create方法的基本使用"><a href="#2-Object-create方法的基本使用" class="headerlink" title="2.Object.create方法的基本使用"></a>2.Object.create方法的基本使用</h3><pre><code>&lt;script&gt;    // 在Object的构造函数上存在一个create方法， 该方法的作用是用来创建对象的。    // 该方法可以接收的参数有一下两种    // 1. null    // 创建一个空对象， 这个空对象中连最基本的原型对象都没有的    // 2. 对象    // 创建传递进来的对象， 并设置该对象的原型对象为当前的参数&lt;/script&gt;</code></pre><hr><h3 id="3-call方法和apply方法的基本使用-借用其他对象方法"><a href="#3-call方法和apply方法的基本使用-借用其他对象方法" class="headerlink" title="3.call方法和apply方法的基本使用(借用其他对象方法)"></a>3.call方法和apply方法的基本使用(借用其他对象方法)</h3><pre><code>&lt;script&gt;    // 语法：     // 1. 对象1.方法.call(对象2) // 此时方法不代括号()    // 2. 对象1.方法.apply(对象2) // 此时方法不代括号()    // 个人用法: 借用对象.函数不带括号.call(被借用对象2)    // 作用: 借用其他对象的方法, call() 和apply() 可以改变this指向，    // 看call() 和apply() 里面传递的第一个参数， 第一个参数是谁 this就指向谁    // 两个不同： apply传参数值是[]    // 案例：    var obj1 = {        name: &quot;zs&quot;,        dog: function () {            console.log(this.name + &quot;借用张三家的dog&quot;);        },        add: function (a, b) {            return a + b;        }    }    var obj2 = {        name: &quot;lw&quot; // 隔壁老王    }    //借用对象.函数不带括号.call(被借用对象2)    console.log(obj1.add.call(obj2, 2, 6)); // 借用方法    console.log(obj1.add.apply(obj2, [2, 6])); // 借用方法&lt;/script&gt;</code></pre><hr><h3 id="4-借用其他对象属性变量"><a href="#4-借用其他对象属性变量" class="headerlink" title="4.借用其他对象属性变量"></a>4.借用其他对象属性变量</h3><pre><code>&lt;script&gt;    // 关键词： window.Person.call(this, name, age)    // 案例：    function Person(name, age) {        this.name = name;        this.age = age;    };    Person.prototype.fun1 = function () {        console.log(&quot;name:&quot;, this.name, &quot;age:&quot;, this.age);    };    function Sub(color, age, name) {        window.Person.call(this, name, age); // 主要是这句        this.color = color;    };    var sub = new Sub(&quot;红色&quot;, 18, &quot;小明&quot;);    console.log(sub);&lt;/script&gt;</code></pre><hr><h3 id="5-五种继承方式-（五种继承）-1-class继承-（6种）"><a href="#5-五种继承方式-（五种继承）-1-class继承-（6种）" class="headerlink" title="5.五种继承方式 （五种继承）+1 class继承 （6种）"></a>5.五种继承方式 （五种继承）+1 class继承 （6种）</h3><pre><code>&lt;script&gt;    // 1. 混入式继承， 浅拷贝存在共享(for key in obj)    // 概念： 对于非基本类型数据， 浅拷贝只是拷贝了内存地址， 子类属性指向父类属性的内存地址， 而子类修改后父类也会被修改    // 浅拷贝存在数据共享问题， 修改其中一个另外一个也被修改了（ 后面课有深拷贝） 搜索 深拷贝    // 案例浅拷贝：    var obj1 = {        name: &quot;zs&quot;,        age: 18,        like: [&quot;Java&quot;, &quot;H5&quot;, &quot;Ui&quot;],        wife: {            name: &quot;翠花&quot;,            age: 18        }    }    var obj2 = {}; // 隔壁老王    for (var key in obj1) {        obj2[key] = obj1[key];    }    console.log(obj2);    obj2.wife.name = &quot;如花&quot;;    console.log(obj1);    // 2. 原型式继承， 存在共享（ 问题是只能继承父类对象原型上的成员， 但无法继承父类对象中的成员。） Student.prototype = Person.prototype    // 案例：    function Animal() {        this.color = &quot;red&quot;;    }    Animal.prototype.weight = 100;    function Person() {}    Person.prototype = Animal.prototype;    var p = new Person();    console.log(p);    // 3. 原型链继承，存在问题    // 3.1 共享的问题 3.2 子类无法向父类传参 Student.prototype = new Person()    // 案例：    function Person(name, age, sex) {        this.name = name;        this.age = age;        this.sex = sex;    }    Person.prototype.play = function () {        console.log(&quot;我是原型上的方法&quot;);    }    function Student(score) {        this.score = score;    }    // 原型链继承 Student.prototype = new Person()//这种写法叫做原型链继承    Student.prototype = new Person(&quot;小明&quot;, 19, &quot;男&quot;);    var stu1 = new Student(100);    console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score);    // stu1.name = &quot;zs&quot;;    （子类无法向父类传参）    // 4.借用构造函数继承， 解决子类向父类传参方式， 不能调用父类方法 使用call() 继承（ window.Person.call(this, 参数, age, sex);）    // 案例：    function Person(name, age, sex) {        this.name = name;        this.age = age;        this.sex = sex;    }    Person.prototype.sayHi = function () {        console.log(&quot;链上添加方法&quot;);    }    function Animal(color, name, age, sex) {        // 借用其他对象中的构造函数        window.Person.call(this, name, age, sex);        this.color = color;    }    var per = new Person()    var ani = new Animal(&quot;红色&quot;, &quot;小刘&quot;, 55, &quot;男&quot;);    console.log(per);    console.log(ani);    // ani.sayHi(); 不能调用方法            // 5. 组合继承（借用构造函数继承和原型链继承） 工作中用这种（ Student.prototype = new Person();）    // 案例：    function Person(name, sex, age) {        this.name = name;        this.sex = sex;        this.age = age;    };    Person.prototype.sayHi = function () {        console.log(&quot;天气糟糕!&quot;);    };    // 组合继承，1.原型链方式加call()借用构造函数    function Student(score, name, sex, age) {        window.Person.call(this, name, sex, age);        this.score = score;    }    Student.prototype = new Person();    var stu = new Student(&#39;20&#39;, &#39;小刘&#39;, &#39;男&#39;, 51);    stu.name = &quot;张&quot;    stu.sayHi();    console.log(stu);    console.log(stu.__proto__);&lt;/script&gt;</code></pre><hr><h3 id="6-原型链解析"><a href="#6-原型链解析" class="headerlink" title="6.原型链解析"></a>6.原型链解析</h3><pre><code>&lt;script&gt;    // 案例：    // 完整版的原型图    function Person(name, age) {        this.name = name;        this.age = age;    }    // 实例化对象    var per = new Person();    // 测试--找到构造函数的父类 Person(只要是函数都是Function)    console.log(Person.constructor); // 找父类 Function    console.log(Function.prototype); // 找原型，或者找妻子 f()    console.log(Person.__proto__); // 找妈妈 f()    // 测试扩展主线----函数是上帝，可以自己造自己    console.log(Function.constructor); // Function    // 测试空函数父类是谁    console.log(Person.__proto__.constructor); // Function    // 换个思想 把对象当成函数来看    console.log(Object.__proto__.constructor); // Function    console.log(Function.prototype.__proto__ == Object.prototype); // true    console.log(Object.__proto__); // f()&lt;/script&gt;</code></pre><hr><h3 id="7-圆括号语法（-语法）"><a href="#7-圆括号语法（-语法）" class="headerlink" title="7.圆括号语法（()语法）"></a>7.圆括号语法（()语法）</h3><pre><code>&lt;script&gt;    // 圆括号语法(工作里面给我们的数据全部是json格式) - 跟对象是一样的就是键值对多了一对双引号(100).add(100)    // 案例：    console.log(({        &quot;name&quot;: &quot;zs&quot;    }));    Number.prototype.add = function (num) {        return this + num;    };    console.log((100).add(100)); // 圆括号语法，直接拿数组调用方法记得要加()圆括号语法&lt;/script&gt;</code></pre><hr><h3 id="8-is-4个特例"><a href="#8-is-4个特例" class="headerlink" title="8.is(4个特例)"></a>8.is(4个特例)</h3><pre><code>&lt;script&gt;    // is：判断两个参数是否相等， 等同于 === ，注意下面两种特殊的判断即    console.log(0 === -0); // true    console.log(Object.is(0, -0)); // false    console.log(NaN === NaN); // false    console.log(Object.is(NaN, NaN)); // true    // 总结：特殊案例记下：转换为布尔为false: 0 &quot;&quot; undefined null NaN&lt;/script&gt;</code></pre><hr><h3 id="9-Api方法-Object静态成员"><a href="#9-Api方法-Object静态成员" class="headerlink" title="9.Api方法 Object静态成员"></a>9.Api方法 Object静态成员</h3><pre><code>&lt;script&gt;    // 1. getOwnPropertyDescriptor 访问属性（ 增、 删、 改、 查属性）    console.log(Object.getOwnPropertyDescriptor(obj, &quot;name&quot;));    // configurable： 属性可配置型， false， 当前属性不能被删除， 可修改， 并且后面不能再改变该描述对象    // enumerable： 可枚举性， false， 当前属性不是被循环遍历到    // value： 当前属性的值    // writable： 可写性， false， 当前属性的值不能被修改    // 2. getOwnPropertyDescriptors ** ：获取所有属性的描述对象    // 案例：     console.log(Object.getOwnPropertyDescriptors(obj));    // 3. defineProperties 一次定义多个属性的可操作性（ configurable | enumerable | value | writable）    // 案例：    Object.defineProperties(obj, {        name: {            configurable: false        },        age: {            configurable: true        }    })    console.log(delete obj.name); // name属性已被删除    console.log(delete obj.age);    console.log(obj);    // 4. defineProperty： 定义当前指定属性的可操作性（ configurable | enumerable | value | writable）    // 案例：    Object.defineProperty(obj, &quot;name&quot;, {        configurable: false //当前属性不能被删除    });    console.log(delete obj.name);    console.log(obj);    // 5. keys: 获取当前对象所有属性的名称， 不可枚举的属性除外    // 案例：    var obj = {        name: &quot;zs&quot;,        age: 18,        sex: &quot;男&quot;    };    // keys：获取当前对象所有key属性的名称，不可枚举的属性除外(获取可以枚举的属性)    Object.defineProperty(obj, &quot;name&quot;, {        enumerable: false // 不可枚举    });    for (var key in obj) {        console.log(obj[key]); // 遍历后都是可枚举的    }    console.log(Object.keys(obj)); // 这个等价上面的for循环    // 6. getOwnPropertyNames： 获取当前对象所有属性的名称， 包括不可枚举的属性    // 案例：     console.log(Object.getOwnPropertyNames(obj));    // 7. isExtensible： 检查当前对象是否可扩展， false， 不能添加属性，    console.log(Object.isExtensible(obj)); // true,如果是false就不能添加属性    // 8. isSealed：： 检查当前对象是否是被密封的， true， 不能添加和删除属性    console.log(Object.isFrozen(obj)); // false,如果设置为true这对象就不能删除和修改，和添加    // 9. isFrozen： 检查当前对象是否是被冻结的， true， 不能添加， 删除和修改属性    console.log(Object.isFrozen(obj)); // false,如果设置为true这对象就不能删除和修改，和添加    // 10. preventExtensions： 阻止当前对象的可扩展性， 就是添加不了属性了    // 案例:    Object.preventExtensions(obj); // (不能添加,能修改，能删除)    obj.color = &quot;pink&quot;;    obj.age = 88;    console.log(delete obj.name);    console.log(obj);    // 11. seal： 密封当前对象、 添加删除不了， 可以修改    // 案例：    Object.seal(obj); //（删除 --no添加--no，只可以修改）    obj.color = &quot;pink&quot;;    obj.age = 88;    console.log(delete obj.name);    console.log(obj);    // 12. freeze: 冻结当前对象、 不能删除、 不能修改、 不能删除    // 案例：    Object.freeze(obj); //（添加 --no，删除--no 修改--no）    obj.color = &quot;pink&quot;;    obj.age = 88;    console.log(delete obj.name);    console.log(obj);    // 13. entries： 获取到所有成员， 以数组形式返回    // 案例：    var obj2 = {        name: &quot;lw&quot;,        age: 88,        sex: 1,        fun: function () {            console.log(&quot;我是方法&quot;);        }    }    console.log(obj2);    console.log(Object.entries(obj2));    // 14. hasOwnProperty： 判断当前实例对象中是否存在指定的属性, 如果存在返回true， 反之返回false（ 只是判断私有属性）    // 案例：    function Person(name, age) {        this.name = name;        this.age = age;    }    // 实例化对象    var per = new Person(&quot;zs&quot;, 18);    console.log(per.hasOwnProperty(&quot;name&quot;)); // true (in是判断私有和公有)    // 15. isPrototypeOf： 判断当前对象是否在指定对象的原型链中, 如果是返回true， 反之返回false；    // 案例：     console.log(Person.prototype.isPrototypeOf(per)); // true    // 16. propertyIsEnumerable: 属性是否可以枚举（ 循环遍历）, 如果可以枚举返回的是true， 反之返回false    // 案例：     console.log(per.propertyIsEnumerable(&quot;name&quot;)); // true    console.log(per.propertyIsEnumerable(&quot;constructor&quot;)); // false    // 17. valueOf(): 基本包装类型： 返回对应的值 | 日期转时间戳（ 微毫秒）（ 重点）    // 引用类型： 返回this， 对象本身    // 日期类型： 返回时间戳    // 案例: 1. 返回对应的值    var str = new String(&quot;demo&quot;);    console.log(str.valueOf(str));    // 17.2 返回对象本身    var obj = {        name: &quot;zs&quot;,        age: 18    };    console.log(obj.valueOf());    // 17.3 日期类型： 返回时间戳    var now = new Date();    console.log(now.valueOf());    // 18. toString()（ 重点） 转字符串    // 返回数据特定的格式的字符串    // 基本类型： 返回对应值的字符串    // 如果是数字类型， 可以传递一个参数指定转换成上面进制的数字字符串 二进制、 八进制、 16 进制    // 引用类型： 返回[object Object] 格式的字符串， object为对象的类型， Object为对象对应的构造函数    // 案例1：    console.log((100).toString());    console.log((100).toString(2));    console.log((100).toString(8));    console.log((100).toString(16));    // 案例数组中toString() 不一样：    var arr = [1, 2, 3, 45, &#39;eee&#39;, 7];    console.log(arr.toString()); // 1,2,3,45,eee,7    //借用Object    console.log(Object.prototype.toString.call(arr)); // 借用Object方法  [object Array]    var str11 = arr.toString();    console.log(&quot;hhh:&quot; + str11); // hhh:1,2,3,45,eee,7    //比较这两个方法    console.dir(arr);    console.log(Object.prototype.toString() == Array.prototype.toString()); // false&lt;/script&gt;</code></pre><hr><h3 id="10-判断当前对象是否是数组类型-判断数组类型-重点-兼容-isArray"><a href="#10-判断当前对象是否是数组类型-判断数组类型-重点-兼容-isArray" class="headerlink" title="10.判断当前对象是否是数组类型(判断数组类型) 重点 兼容  isArray()"></a>10.判断当前对象是否是数组类型(判断数组类型) 重点 兼容  isArray()</h3><pre><code>&lt;script&gt;    // 注意： 封装一个方法， 让所有浏览器兼容, Array.isArray有些浏览器兼容， 有些不兼容    // 处理兼容问题，这个函数来判断你是否是数组    // 案例:        function isArray(arr) { // 处理兼容问题，这个函数来判断你是否是数组            // 判断            if (Array.isArray) {                return Array.isArray(arr);            } else {                return Object.prototype.toString.call(arr) == &quot;[object Array]&quot;            }        }    console.log(isArray({}));    console.log(isArray([1, 2, 3, 4, 5]));    // 19. toLocaleString() 将当前日期生成系统格式（本地时间格式）（重点）返回的是string类型    var d = new Date();    console.log(d.toLocaleString()); // 2019/3/10 下午4:23:54    // 20. arguments是伪数组（重点）    // 案例：    function fun() {        var sum = 0;        for (var i = 0; i &lt; arguments.length; i++) {            sum += arguments[i];        }        return sum;    }    var result = fun(10, 20, 30, 40, 50);    console.log(result);    // 21. eval() 函数 json数据处理（ 重点） 1. JSON.parse() 2. JSON    // .stringify() 3. eval() 两种 1. 处理json加（） 语法 2. eval() 转换之后立即执行,    // 可以实现 eval() 和函数几乎是一样， 都是把字符串转换成js能运行的代码 eval() 和函数的区别就是: 函数必须要调用， eval() 可以直接执行    // 案例：    var jsonObj = &#39;{&quot;name&quot;:&quot;xiaoliu&quot;,&quot;age&quot;:18}&#39;;    console.log(eval(jsonObj)); // 报错 Unexpected token &#39;:&#39;    // 解决方案：加()语法    var jsonObj = &#39;({&quot;name&quot;:&quot;xiaoliu&quot;,&quot;age&quot;:18})&#39;; // 此处加()解决    console.log(eval(jsonObj)); // 成功&lt;/script&gt;</code></pre><hr><h2 id="第五天-2"><a href="#第五天-2" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-函数创建2种"><a href="#1-函数创建2种" class="headerlink" title="1.函数创建2种"></a>1.函数创建2种</h3><pre><code>&lt;script&gt;    // 1. 第一种创建函数    function fun() {        console.log(&quot;我是命名函数，我是有名字的函数&quot;);    }    fun();    // 2. 匿名函数    var fun2 = function () {        console.log(&quot;匿名函数或者叫做函数表达式&quot;);    };    fun2();    // 传递形参    var fun4 = new Function(&quot;a&quot;, &quot;b&quot;, &quot;console.log(a+b)&quot;);    console.log(fun4); // 查看方法体    fun4(5, 6)&lt;/script&gt;</code></pre><hr><h3 id="2-Function构造函数创建对象"><a href="#2-Function构造函数创建对象" class="headerlink" title="2.Function构造函数创建对象"></a>2.Function构造函数创建对象</h3><pre><code>&lt;script&gt;    // 1. 创建函数无参数的函数对象：    var fun2 = new Function();    fun2();    // 2. 定义一个有函数体的函数对象    var fun2 = new Function(&quot;console.log(&#39;hello h5&#39;);&quot;);    fun2(); // hello h5&lt;/script&gt;</code></pre><hr><h3 id="3-this指向（重点）this对象"><a href="#3-this指向（重点）this对象" class="headerlink" title="3.this指向（重点）this对象"></a>3.this指向（重点）this对象</h3><pre><code>&lt;script&gt;    // 总结： 函数中的参数 arguments， this length    // 1、函数作为普通函数执行的时候， this指向window *    // 2、函数作为对象的方法调用， this指向调用方法的对象(看点， 点前面是谁this就指向谁) *    // 3、使用new 构造函数， this指向我们新创建的实例对象 *    // 4、上下文调用(call、 apply)， this指向第一个参数（ call() 和apply() 第一个参数是谁this就指向谁）    // 1. 普通调用 fun() this指向调用函数的对象-- - window    // 2. 对象调用 obj.fun() this指向调用函数的对象-- - obj    // 3. 使用new关键字调用 new Fun() this指向函数内部创建的新对象    // 4. call或者apply调用 this指向call或者apply方法的第一个参数&lt;/script&gt;</code></pre><hr><h3 id="4-检测类型4个-类型检查-判断类型-（4种）"><a href="#4-检测类型4个-类型检查-判断类型-（4种）" class="headerlink" title="4.检测类型4个 类型检查 判断类型 （4种）"></a>4.检测类型4个 类型检查 判断类型 （4种）</h3><pre><code>&lt;script&gt;    // 1. typeof: 主要用来判断基本类型    // 案例：    onsole.log(typeof &quot;abc&quot;); // &quot;string&quot;    console.log(typeof 123); // &quot;number&quot;    console.log(typeof true); // &quot;boolean&quot;    console.log(typeof null); // &quot;object&quot;    console.log(typeof Function); // &quot;function&quot;    console.log(typeof {        name: &quot;Neld&quot;,        age: 10    }); // &quot;object&quot;    // 2. constructor: 可以用来判断创建对象的构造器的类型    function Person() {}    var p = new Person();    console.log(p.constructor == Person); // true    // 3. instanceof: 判断指定构造函数的原型对象是否在当前实例对象的原型链上    function Person() {}    var p = new Person();    console.log(p instanceof Person); // true    console.log(p instanceof Object); // true    // 4. Object.prototype.toString(): // 获取数据类型对应的字符串    console.log(Object.prototype.toString.call(&quot;Neld&quot;)); // [object String]    console.log(Object.prototype.toString.call(10)); // [object Number]    console.log(Object.prototype.toString.call(p)); // [object Object]    console.log(Object.prototype.toString.call([])); // [object Array]&lt;/script&gt;</code></pre><hr><h3 id="5-class语法"><a href="#5-class语法" class="headerlink" title="5.class语法"></a>5.class语法</h3><pre><code>&lt;script&gt;    // 案例：    class Person {        constructor(name, age) {            this.name = name;            this.age = age;        }        sayHi() {            console.log(&quot;普通方法&quot;);        }        static hobby() {            console.log(&quot;静态方法&quot;);        }    }    let per = new Person(&#39;下课&#39;, 45);    per.sayHi();    Person.hobby();&lt;/script&gt;</code></pre><hr><h3 id="6-class继承-（前面课总结5种继承）"><a href="#6-class继承-（前面课总结5种继承）" class="headerlink" title="6.class继承 （前面课总结5种继承）"></a>6.class继承 （前面课总结5种继承）</h3><pre><code>&lt;script&gt;    // 案例：    class Animal {        constructor(name, age) {            this.name = name;            this.age = age;        }        // 一般方法都放在原型上        play() {            console.log(&quot;我是Animal原型上的方法&quot;);        }    }    // ES6的继承    class Person extends Animal {        constructor(name, age) {            super(name, age);        }        // 自己原型上也可以添加方法        say() {            console.log(&quot;我是Person原型的方法&quot;);        }    }    // 实例化    var per1 = new Person(&quot;zs&quot;, 18);    console.log(per1);    console.log(per1.name);&lt;/script&gt;</code></pre><hr><h3 id="7-作用域安全问题有三种-代码的健壮性处理-容错机制-（重点）"><a href="#7-作用域安全问题有三种-代码的健壮性处理-容错机制-（重点）" class="headerlink" title="7.作用域安全问题有三种 代码的健壮性处理 容错机制 （重点）"></a>7.作用域安全问题有三种 代码的健壮性处理 容错机制 （重点）</h3><pre><code>&lt;script&gt;    // 处理结果三种方法：    // 1.    if (this == window) { // (严格模式this不指向window)有点小问题不推荐        return new Person(); // 容错机制     }    // 2. 利用 instanceof    if (!(this instanceof Person)) {        return new Person(); // 容错机制    }    // 3. target没有使用new返回undefined-- --new.target == undefined    if (!new.target) {        // throw &quot;没有使用new创建&quot;        return new Person(); // 容错机制    }    // 案例1：（ 严格模式thi不指向window）    function Person(name, age) {        if (this == window) {            return new Person(); // 容错机制         }        this.name = name;        this.age = age;    }    let per = Person(&#39;下课&#39;, 45); // 没有return 就返回undefined    console.log(per);&lt;/script&gt;</code></pre><hr><h3 id="8-对象深拷贝（封装一个深拷贝函数）-（重点）"><a href="#8-对象深拷贝（封装一个深拷贝函数）-（重点）" class="headerlink" title="8.对象深拷贝（封装一个深拷贝函数） （重点）"></a>8.对象深拷贝（封装一个深拷贝函数） （重点）</h3><pre><code>&lt;script&gt;    // 深拷贝： 他会一层一层拷贝， 每一层都会进入拷贝， 实现了数据独立问题， 不会存在数据共享了    // 案例：    var souce = {        name: &#39;xiao&#39;,        age: 15,        arr: [45, 16, 18],        wife: {            name: &quot;小青&quot;,            age: 15        },        color: &#39;红色&#39;,        width: 89    };    var new2 = {};    deepCopy(souce, new2);    console.log(new2);    function deepCopy(oldObj, newObj) {        // 拷贝循环        for (let key in oldObj) {            // 去掉公有 判断只获取私有属性            if (oldObj.hasOwnProperty(key)) { // 为了拿到私有属性                // 接着处理不同的对象 数组对象和引用对象分开 判断对象typeof  引用对象都是Object                if (typeof oldObj[key] == &#39;object&#39;) {                    // 获取引用的对象，引用对象需要新增                    newObj[key] = Array.isArray(oldObj[key]) ? [] : {}                    deepCopy(oldObj[key], newObj[key]);                } else {                    // 表示拷贝的是值类型                    newObj[key] = oldObj[key];                }            }        }    }&lt;/script&gt;</code></pre><hr><h3 id="9-入口函数封住id"><a href="#9-入口函数封住id" class="headerlink" title="9.入口函数封住id"></a>9.入口函数封住id</h3><pre><code>&lt;script&gt;    window.onload = function () {        etById(&quot;aaqq&quot;);    }    function getById(id) {        return document.getElementById(id);    }&lt;/script&gt;</code></pre><hr><h2 id="第六天-2"><a href="#第六天-2" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-函数几种定义（自定义函数）-匿名函数"><a href="#1-函数几种定义（自定义函数）-匿名函数" class="headerlink" title="1.函数几种定义（自定义函数） 匿名函数"></a>1.函数几种定义（自定义函数） 匿名函数</h3><pre><code>&lt;script&gt;    // 1. 命名函数定义    function fun1() {        console.log(&quot;命名函数&quot;);    }    fun1();    // 2. 匿名函数表达式    var fun2 = function () {        console.log(&quot;匿名函数表达式&quot;);    }    fun2();    // 3. 命名函数表达式    var fun3 = function f4() {        console.log(&quot;命名函数表达式&quot;);        console.log(f4);    }    fun3();    // 4. 创建函数对象的方式    var fun5 = new Function();    fun5();    // 案例：    var fun5 = new Function(&quot;var i=0; if(!i){ console.log(&#39;999&#39;);} &quot;);    console.log(fun1.name); // fun1    console.log(fun2.name); // fun2    console.log(fun3.name); // f4    console.log(fun5.name);&lt;/script&gt;</code></pre><hr><h3 id="2-数组去重函数-（重点）"><a href="#2-数组去重函数-（重点）" class="headerlink" title="2.数组去重函数  （重点）"></a>2.数组去重函数  （重点）</h3><pre><code>&lt;script&gt;    // 1. 去重案例：    var arr = [1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 6, 7, 7, 7, 7, 8];    function distinctArray(arr) {        // 先定义要给数组，存放我筛选之后的数据        var newArray = [];        for (var i = 0; i &lt; arr.length; i++) {            // 判断 indexOf检测数据里面的元素是否存在，如果存在返回对应的索引值，如果不存在返回 -1；            if (newArray.indexOf(arr[i]) == -1) { // 表示的是不存在                newArray.push(arr[i]);            }        }        return newArray;    }    //  调用函数    var result = distinctArray(arr);    console.log(result);    // 2. es6语法 - 去重案例    var arr = [1, 1, 2, 2, 3, 6, 4, 6]    var data = new Set(arr);    var arr1 = Array.from(data);    console.log(arr1);    // 3. es6写法    // 数组去重    let arr = [10, 2, 30, 10, 5, 40, 1, 2];    console.log(new Set(arr));    let arr2 = [...new Set(arr)];    console.log(arr2);&lt;/script&gt;</code></pre><hr><h3 id="3-数组求最大值最小值"><a href="#3-数组求最大值最小值" class="headerlink" title="3.数组求最大值最小值"></a>3.数组求最大值最小值</h3><pre><code>&lt;script&gt;    var arr = [1, 5, 1, 21, 33, 56, 89];    function max(arr) {        // 定义一个最大值        var temp = arr[0];        for (var i = 0; i &lt; arr.length; i++) {            if (temp &lt; arr[i]) {                temp = arr[i];            }        }        return temp;    }    console.log(max(arr));    function min(arr) {        // 定义一个最小值        var temp = arr[0];        for (var i = 0; i &lt; arr.length; i++) {            if (temp &gt; arr[i]) {                temp = arr[i];            }        }        return temp;    }    console.log(min(arr)); // 定义最小值&lt;/script&gt;</code></pre><hr><h3 id="4-匿名函数6种-立即执行函数-自执行函数（自定义函数）-匿名函数"><a href="#4-匿名函数6种-立即执行函数-自执行函数（自定义函数）-匿名函数" class="headerlink" title="4.匿名函数6种 立即执行函数,自执行函数（自定义函数） 匿名函数"></a>4.匿名函数6种 立即执行函数,自执行函数（自定义函数） 匿名函数</h3><pre><code>&lt;script&gt;    // 第一种方式    (function () {        console.log(&#39;第一种方式&#39;);    })();    // 第二种方式    (function () {        console.log(&#39;第二种方式&#39;);    }());    // 第三种写法    ! function () {        console.log(&#39;第三种方式&#39;);    }();    // 第四种写法    + function () {        console.log(&#39;第四种写法&#39;);    }();    // 第五种写法     - function () {        console.log(&#39;第五种写法&#39;);    }();    // 第六种写法    ~ function () {        console.log(&#39;第六种写法&#39;);    }();&lt;/script&gt;</code></pre><hr><h3 id="5-操作增删改查-封装函数-对象增删改查"><a href="#5-操作增删改查-封装函数-对象增删改查" class="headerlink" title="5.操作增删改查(封装函数) 对象增删改查"></a>5.操作增删改查(封装函数) 对象增删改查</h3><pre><code>&lt;script&gt;    // --删除splice(下标， 删几个) 查下标indexOf    // 案例：    var books = [{        name: &quot;活着&quot;,        price: 27.7,        press: &quot;作家出版社&quot;    }, {        name: &quot;流浪地球&quot;,        price: 37.6,        press: &quot;中国华侨出版社&quot;    }, {        name: &quot;罗生门&quot;,        price: 36.3,        press: &quot;开明出版社&quot;    }, {        name: &quot;三体&quot;,        price: 51.5,        press: &quot;重庆出版社&quot;    }];    // 函数封装    function getBookByName(name) {        for (var i = 0; i &lt; books.length; i++) {            if (books[i].name == name) {                return books[i];            }        }        return &quot;查无此书&quot;;    }    console.log(getBookByName(&quot;三体&quot;));    // 添加封装    function addBook(newBook) {        books.push(newBook);    }    addBook({        name: &quot;JS从三分钟入门&quot;,        price: 10,        press: &quot;二十四期出版社&quot;    });    //需求3：将罗生门这本书的价格修改为40    function updateBookByName(name, newBook) {        var book = getBookByName(name); // 先调用我们前面查询的方法        var i = books.indexOf(book); // 拿到这本书的索引值并且修改这本书        books.splice(i, 1, newBook);    }    updateBookByName(&quot;三体&quot;, {        name: &quot;一只特立独行的猪&quot;,        price: 50,        press: &quot;王小波&quot;    });    // 需求4：将三体这本书从书单中删除    function deleteBookByName(name) {        var book = getBookByName(name);        var i = books.indexOf(book); // 此时就是获取你这个元素索引        books.splice(i, 1);    }    deleteBookByName(&quot;流浪地球&quot;);    console.log(books);&lt;/script&gt;</code></pre><hr><h3 id="6-函数封装到对象-重点"><a href="#6-函数封装到对象-重点" class="headerlink" title="6.函数封装到对象(重点)"></a>6.函数封装到对象(重点)</h3><pre><code>&lt;script&gt;    // 案例：    var books = [{        name: &quot;活着&quot;,        price: 27.7,        press: &quot;作家出版社&quot;    }, {        name: &quot;流浪地球&quot;,        price: 37.6,        press: &quot;中国华侨出版社&quot;    }, {        name: &quot;罗生门&quot;,        price: 36.3,        press: &quot;开明出版社&quot;    }, {        name: &quot;三体&quot;,        price: 51.5,        press: &quot;重庆出版社&quot;    }];    function BookManager(books) { // 构造函数        this.books = books;    }    // 方法都放在原型上,books前面加this， getBookByName加this    BookManager.prototype = {        constructor: BookManager,        getBookByName: function (name) {            for (var i = 0; i &lt; this.books.length; i++) {                if (this.books[i].name == name) {                    return this.books[i];                }            }            return &quot;查无此书&quot;;        },        addBook: function (newBook) {            this.books.push(newBook);        },        updateBookByName: function (name, newBook) {            var book = this.getBookByName(name); // 先调用我们前面查询的方法            var i = this.books.indexOf(book); // 拿到这本书的索引值并且修改这本书            this.books.splice(i, 1, newBook);        },        deleteBookByName: function (name) {            var book = this.getBookByName(name);            var i = this.books.indexOf(book); // 此时就是获取你这个元素索引            this.books.splice(i, 1);        }    }    // 实例化对象    var manager = new BookManager(books);&lt;/script&gt;</code></pre><hr><h3 id="7-with-使用（echarc中用）"><a href="#7-with-使用（echarc中用）" class="headerlink" title="7.with 使用（echarc中用）"></a>7.with 使用（echarc中用）</h3><pre><code>&lt;script&gt;    // 案例：    var a = {        name: &quot;zs&quot;,        b: {            age: 10,            c: {                color: &quot;red&quot;,                des: &quot;description&quot;            }        }    }    with(a.b.c) {        console.log(color);        console.log(des);    }&lt;/script&gt;</code></pre><hr><h3 id="8-自执行函数方式-立即执行函数"><a href="#8-自执行函数方式-立即执行函数" class="headerlink" title="8.自执行函数方式(立即执行函数)"></a>8.自执行函数方式(立即执行函数)</h3><pre><code>&lt;script&gt;    // 案例：    // 1. 匿名函数    var div = document.getElementById(&quot;div1&quot;);    (function (style) {        div.style.backgroundColor = &quot;pink&quot;;        style.width = &quot;300px&quot;;        style.height = &quot;300px&quot;;        style.border = &quot;1px solid #000&quot;;    })(div.style)    // 2. 普通函数    function setStyle(style) {        div.style.backgroundColor = &quot;pink&quot;;        style.width = &quot;300px&quot;;        style.height = &quot;300px&quot;;        style.border = &quot;1px solid #000&quot;;    }    setStyle(div.style);&lt;/script&gt;</code></pre><hr><h3 id="9-严格模式（慎用，启用后之前代码重写）"><a href="#9-严格模式（慎用，启用后之前代码重写）" class="headerlink" title="9.严格模式（慎用，启用后之前代码重写）"></a>9.严格模式（慎用，启用后之前代码重写）</h3><pre><code>&lt;script&gt;    // 1. 不允许使用未声明的变量    &quot;use strict&quot;;    num = 10;    console.log(num);    // 2. 严格模式定义在脚本开头， 会对整个脚本执行严格模式    function fun() {        num = 100;        console.log(num);    }    fun();    // 3. 如果严格模式定义在函数头部， 那么只在当前函数中使用严格模式， 对函数外部的代码没有影响。    function fun() {        &quot;use strict&quot;;        age = 18;        console.log(age);    }    fun();    // 4. 在严格模式下， 试图删除不可删除的属性时， 会抛出异常    delete Object.prototype;    function fun(a, a, b) {        &quot;use strict&quot;;        return a + a + b;    }    var result = fun(1, 2, 3);    // 5. 禁止八进制数字语法    &quot;use strict&quot;;    var sum = 015 + // 语法错误        197 +        142;    console.log(sum);    // 6.禁止this指向全局对象，当this指向全局对象时，自动转为undefined    function fun() {        &quot;use strict&quot;;        console.log(this);    }    fun();&lt;/script&gt;</code></pre><hr><h3 id="10-块级作用域（函数作用域）"><a href="#10-块级作用域（函数作用域）" class="headerlink" title="10.块级作用域（函数作用域）"></a>10.块级作用域（函数作用域）</h3><pre><code>概念：js没有块级作用域的，如果在一对大括号{}里面定义的变量，外面访问不了，那么此时就形成了块级作用域，如果能访问就没有块级作用域（left 和函数除外）</code></pre><hr><h3 id="11-域解析试题"><a href="#11-域解析试题" class="headerlink" title="11.域解析试题"></a>11.域解析试题</h3><pre><code>&lt;script&gt;    var a;    var b;    var c;    console.log(a, b, c); // undefined undefined undefined    a = 10,        b = 20,        c = 30;    function f(a) { // 形参就是局部的        var b;        console.log(a, b, c); // 10 undefined 30        b = a = c = 100;        console.log(a, b, c); // 100 100 100  c是全局的，修改了c全局被修改了    }    f(10, 20);    console.log(a, b, c); // 10,20,100&lt;/script&gt;</code></pre><hr><h2 id="第七天-1"><a href="#第七天-1" class="headerlink" title="第七天"></a>第七天</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><pre><code>&lt;script&gt;    // 闭包： 首先是函数套函数， 子函数调用了父函数的变量或参数， 并且子函数被外界所引用。 此时这变量就被缓存了。    // 优势：缓存数据，想办法把数据缓存下来    // 缺点：内存泄漏    // 典型闭包案例    // 闭包可以缓存数据    // 案例经典1：    function fun1() {        var a = 10;        function fun2() {            return a;        }        return fun2;    }    var result = fun1();    console.log(result);    console.log(result());    // 案例2(优化后)：    function fun1() {        var a = 10;        return function () {            return a;        }    }    var result = fun1();    console.log(result);    console.log(result());    // 案例3(优化后)：    function fun1() {        var a = 10;        var b = 20;        return function () {            return [a, b];        }    }    // 调用这个函数    var result = fun1();    var a = result()[0];    var b = result()[1];    console.log(a, b);    // 案例4：    function fun1() {        var a = 10;        var b = 20;        return [            function () {                return a;            },            function () {                return b;            }        ]    }    var result = fun1();    var a = result[0]();    var b = result[1]();    console.log(a, b);    // 案例五 变成对象 {}：    function fun1() {        var a = 10;        var b = 20;        return { // return 后面可以跟任意数据类型当然也可以跟对象            getA: function () {                return a;            },            getB: function () {                return b;            }        }    }    var result = fun1();    var a = result.getA();    var b = result.getB();    console.log(a, b);    // 案例六: 工作或者面试的写法    function fun1() {        var a = 10;        var b = 20;        function getA() {            return a;        }        function getB() {            return b;        }        return { // return 后面可以跟任意数据类型当然也可以跟对象            getA: getA,            getB: getB        }    }    var result = fun1();    var a = result.getA();    var b = result.getB();    console.log(a, b);    // 优化后：    var modual = (function fun1() {        var a = 10;        var b = 20;        function getA() {            return a;        }        function getB() {            return b;        }        return { // return 后面可以跟任意数据类型当然也可以跟对象            getA: getA,            getB: getB        }    })();    var a = modual.getA();    var b = modual.getB();    console.log(a, b);&lt;/script&gt;</code></pre><hr><h3 id="2-闭包案例（面试时）（重点）定时输出0-9-延迟执行"><a href="#2-闭包案例（面试时）（重点）定时输出0-9-延迟执行" class="headerlink" title="2.闭包案例（面试时）（重点）定时输出0-9(延迟执行)"></a>2.闭包案例（面试时）（重点）定时输出0-9(延迟执行)</h3><pre><code>&lt;script&gt;    // 案例：    for (var i = 0; i &lt; 10; i++) {        function fun() {            return function (i) {                console.log(i);            }        }        setTimeout(fun(), 1000, i); //　延迟1秒后执行,只是执行一次    }&lt;/script&gt;</code></pre><hr><h3 id="3-闭包-点击事件-（案例）"><a href="#3-闭包-点击事件-（案例）" class="headerlink" title="3.闭包+点击事件 （案例）"></a>3.闭包+点击事件 （案例）</h3><pre><code>&lt;!-- 解析：点击是异步，for已执行完打印是9，用()()匿名函数先执行 --&gt;&lt;!-- 案例： --&gt;&lt;div&gt;我是div1&lt;/div&gt;&lt;div&gt;我是div2&lt;/div&gt;&lt;div&gt;我是div3&lt;/div&gt;&lt;div&gt;我是div4&lt;/div&gt;&lt;div&gt;我是div5&lt;/div&gt;&lt;div&gt;我是div6&lt;/div&gt;&lt;div&gt;我是div7&lt;/div&gt;&lt;div&gt;我是div8&lt;/div&gt;&lt;div&gt;我是div9&lt;/div&gt;&lt;div&gt;我是div10&lt;/div&gt;&lt;script&gt;    // 需求:点击每个div显示对应的div的顺序（闭包+点击事件）函数套函数    // 获取元素    var divs = document.getElementsByTagName(&quot;div&quot;); //　伪数组，集合    for (var i = 0; i &lt; divs.length; i++) { //　闭包能缓存数据        divs[i].onclick = (function (j) {            return function () {                console.log(&quot;我是第&quot; + (j + 1) + &quot;div&quot;);            }        })(i)    }&lt;/script&gt;</code></pre><hr><h3 id="4-对象初始化"><a href="#4-对象初始化" class="headerlink" title="4.对象初始化"></a>4.对象初始化</h3><pre><code>&lt;script&gt;    // 案例：    var obj = {        name: &#39;默认&#39;,        age: &quot;默认&quot;,        showName: function () {            console.log(&quot;姓名:&quot; + this.name);        },        showAge: function () {            console.log(&quot;年龄:&quot; + this.age);        },        // 初始化        init: function (name, age) {            this.name = name;            this.age = age;        }    }    obj.init(&quot;zs&quot;, 18);    console.log(obj.name);    console.log(obj.age);    // 2. 如果这个对象只使用一次    ({        name: &#39;默认&#39;,        age: &quot;默认&quot;,        showName: function () {            console.log(&quot;姓名:&quot; + this.name);        },        showAge: function () {            console.log(&quot;年龄:&quot; + this.age);        },        // 初始化        init: function (name, age) {            this.name = name;            this.age = age;            this.showName();            this.showAge();        }    }).init(&quot;zs&quot;, 18);&lt;/script&gt;</code></pre><hr><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><pre><code>&lt;script&gt;    // 单例模式： 对于我们js来说就是单个实例， 某一个模块是一个独立的实例, 下划线定义的变量不可改变    // 案例：    function Person() {        if (Person._instance) {            console.log(&#39;之前已经创建过,直接返回之前创建的对象&#39;);            return Person._instance;        }        Person._instance = this;        console.log(&quot;创建了对象&quot;);    }    var per1 = new Person();    var per2 = new Person();    console.log(per1 === per2); // true    console.log(per1 === per2); // true&lt;/script&gt;</code></pre><hr><h3 id="4-发布订阅–观察者模式"><a href="#4-发布订阅–观察者模式" class="headerlink" title="4.发布订阅–观察者模式"></a>4.发布订阅–观察者模式</h3><pre><code>&lt;script&gt;    // 案例：    // 发布者    var Rose = {        eat: function () {            console.log(&quot;我饿了，我想吃大餐&quot;);            Jack.jack_eat(); // 有联系方式了            Tom.tom_eat();        }    };    // 观察者：订阅者    var Jack = {        jack_eat: function () {            console.log(&quot;邀请，下课我们一起吃大龙虾---Jack&quot;);        }    };    // 观察者，订阅者    var Tom = {        tom_eat: function () {            console.log(&quot;女神，我们一起去吃麻辣烫啊，---TOM&quot;);        }    }    Rose.eat();&lt;/script&gt;</code></pre><hr><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h3><pre><code>&lt;script&gt;    function MakePhone() { // 1、相当于开了工厂    }    // 2、设置构造函数的原型对象(设置共同的属性或方法)--我们在原型上添加了方法    MakePhone.prototype = {        constructor: MakePhone, //修改指向        logDes: function () {            console.log(&quot;广告语:&quot; + this.des);        },        callPhone: function () {            console.log(&quot;打电话的方法&quot;);        }    }    // 3、生产车间(在构造函数上提供一个静态的工厂方法)    MakePhone.factory = function (type) {        // 设置子构造函数的原型对象，指向父构造函数的原型对象，为了拿到里面的方法        // MakePhone[type]==表示的就是子构造函数        MakePhone[type].prototype = MakePhone.prototype;        // 实例化对象        var obj = new MakePhone[type]();        // 返回        return obj;    };    // 4、建立合作关系(定制合作伙伴)，在构造函数身上提供静态方法    MakePhone.iphone = function () {        this.des = &quot;最贵的手机，最垃圾的系统!&quot;;    };    MakePhone.oppo = function () {        this.des = &quot;充电两小时，通话五分钟&quot;;    };    MakePhone.xiaoMi = function () {        this.des = &quot;小米可以吃，不像锤子&quot;;    };    // 实例化对象--获取产品--生成产品，调用工厂函数，传递参数    var iphone1 = MakePhone.factory(&quot;iphone&quot;);    var iphone2 = MakePhone.factory(&quot;iphone&quot;);    var oppo1 = MakePhone.factory(&quot;oppo&quot;);    // 调用属性和方法    iphone1.callPhone();    iphone2.callPhone();    // 广告的方法    iphone1.logDes();    oppo1.logDes();&lt;/script&gt;</code></pre><hr><h3 id="6-命名空间模式"><a href="#6-命名空间模式" class="headerlink" title="6.命名空间模式"></a>6.命名空间模式</h3><pre><code>&lt;script&gt;    //约定:命名空间的名字一般是项目的名称或者简写,一般都是大写；现在几乎不用了，现在用的都是模块化开发。--了解        var MOMO = {};    // 1、定义变量    MOMO.a = 10;    MOMO.b = 20;    // 2、定义对象    MOMO.obj = {        name: &quot;zs&quot;,        age: 18    };    // 3、函数    MOMO.fun = function () {        console.log(&quot;我是函数&quot;);    }    // 构造函数    MOMO.Person = function () {        this.name = &quot;命名空间模式&quot;;    }    console.log(new MOMO.Person());&lt;/script&gt;</code></pre><hr><h3 id="7-单线程和多线程（同步异步）"><a href="#7-单线程和多线程（同步异步）" class="headerlink" title="7.单线程和多线程（同步异步）"></a>7.单线程和多线程（同步异步）</h3><pre><code>&lt;script&gt;    // JS是单线程    // 1. 同步    // 单程    var start = new Date();    for (var i = 0; i &lt; 100000000; i++) {        // 判断        if (i === 99999999) {            console.log(&quot;no&quot;);        }    }    while (1 === 1) {    }    // 2. 异步：    setTimeout(function () {        console.log(1);    }, 50);    setTimeout(function () {        console.log(2);    }, 10);    setTimeout(function () {        console.log(3);    }, 30);    for (var i = 0; i &lt; 100000000; i++) {    }    console.log(6);&lt;/script&gt;</code></pre><hr><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><h3 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h3><pre><code>&lt;script&gt;    // . 除了换行以外所有的任意的字符    // \ 转义    // \n 换行    // \d 表示的是0-9之间任意的一个数字 0 1 2 3 4 5....    // \D 表示除了0-9之外的任意的字符    // \w 表示的是数字、字母和下划线    // \W 除了数字、字母和下划线    // \s 空白符 （是存在的但是眼睛看不到   空格 tab键）    // \S 除了空白符之外的字符&lt;/script&gt;</code></pre><hr><h3 id="2-限定符"><a href="#2-限定符" class="headerlink" title="2.限定符"></a>2.限定符</h3><pre><code>&lt;script&gt;    // [.] 除了换行以外的字符    // [a-z]    // [0-9]    // [A-Z]    // [^0-9]    // |    // $ 以什么结束        // {5} 可以出现5次    // {2,} 最少2次    // {2,5} 最少2次，最多5次&lt;/script&gt;</code></pre><hr><h3 id="3-表示的是范围"><a href="#3-表示的是范围" class="headerlink" title="3.[] 表示的是范围"></a>3.[] 表示的是范围</h3><pre><code>&lt;script&gt;    // [0-9] 表示的是0-9之间任意的一个数字     // [a-z] 表示的是 小写字母a-z之间的任意的一个字符    // [A-Z] 表示的是大写字母A-Z之间的任意的一个字符    // [0-9a-z] 表示的是任意0-9之间的数组或者小写a-z任意的一个字符    // [0-9a-zA-Z] 表示的是任意0-9之间的数,或者a-z之间的小写字母或者A-Z之间的任意的一个大写字母    // []还有其他一个意义，去除元字符的本身的意义 [.]---表示的就是一个点    // | 或者     // [0-9]|[a-z]|[A-Z]  举例 &quot;0123abcA&quot;--true    // ()----分组--为了提高优先级      // [0-9]|([a-z])|[A-Z]--优先匹配 a-z之间的任意的一个字母然后在匹配数组和大写字母    // ([0-9])([a-z])([A-Z])---三组    // ^ 以什么开始 （还有一个意义取反）    // ^[0-9][a-z] 必须以数字开头    // [^0-9] 除了0-9以外的所有的字符    // $ 以什么结束  [0-9][a-z]$ 必须要求以小写字母结束 &quot;123abc&quot; true&lt;/script&gt;</code></pre><hr><h3 id="4-限定符"><a href="#4-限定符" class="headerlink" title="4.限定符"></a>4.限定符</h3><pre><code>&lt;script&gt;    // {} 也是表示范围    // {5} 表示连续出现了5次    // {2,} 表示最少出现2次    // {2,6} 表示出现了2次到6次    // ？ ---表示的是出现了0次或者1次    // * ---表示出现了0次或者多次    // + ---表示出现了1次或者多次&lt;/script&gt;</code></pre><hr><h3 id="5-身份证号码验证"><a href="#5-身份证号码验证" class="headerlink" title="5.身份证号码验证"></a>5.身份证号码验证</h3><pre><code>    1.([1-9][0-9]{14})|([1-9][0-9]{16}[0-9xX])---15位或者18位的身份证号码    2.优化 ？出现了0次或者1次    ([1-9][0-9]{14})([0-9]{2}[0-9xX])?</code></pre><hr><h3 id="6-手机号码验证-的正则表达式"><a href="#6-手机号码验证-的正则表达式" class="headerlink" title="6.手机号码验证 的正则表达式"></a>6.手机号码验证 的正则表达式</h3><pre><code>&lt;script&gt;    案例:    1、手机号码的正则表达式 直接复制笔记上的手机号码    130 131 132 133 134 135 136 137 138 139    143 147    150 151 152 153 154 155 156 157 158 159    170 171 173 176 177    180 181 182 183 184 185 186 187 188 189    1. ([1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})    2. [1]\d{10}&lt;/script&gt;</code></pre><hr><h3 id="7-邮箱的正则"><a href="#7-邮箱的正则" class="headerlink" title="7.邮箱的正则"></a>7.邮箱的正则</h3><pre><code>案例:    d2113_3.-fd@wolfcode.com.cn    [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}    [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.]com|cn+){1,2}</code></pre><hr><h3 id="8-正则表达式的创建"><a href="#8-正则表达式的创建" class="headerlink" title="8.正则表达式的创建"></a>8.正则表达式的创建</h3><pre><code>&lt;script&gt;    // 正则里面有一个方法， 验证正则是否匹配这个字符的 test, 如果匹配成功返回true否则返回flase    // 1. 通过构造函数方式创建正则    var reg = new RegExp(/\d{5}/);    // 定义一个字符串    var str = &quot;我的电话号码是10086&quot;;    // 正则里面有一个方法，验证正则是否匹配这个字符的 test,如果匹配成功返回true否则返回flase    var flag = reg.test(str);    console.log(flag);    // 2. 字面量的方式创建    var reg = /\d{1,5}/;    var flag1 = reg.test(&quot;我们的幸运数字是888&quot;);    console.log(flag1);&lt;/script&gt;</code></pre><hr><h3 id="9-正则表达式案例"><a href="#9-正则表达式案例" class="headerlink" title="9.正则表达式案例"></a>9.正则表达式案例</h3><pre><code>&lt;script&gt;    console.log(/./.test(&quot;除了回车换行以为的任意字符&quot;)); // true    console.log(/.*/.test(&quot;0个到多个&quot;)); // true    console.log(/.+/.test(&quot;1个到多个&quot;)); // true    console.log(/.?/.test(&quot;哈呵&quot;)); // true    console.log(/[0-9]/.test(&quot;9527&quot;)); // true    console.log(/[a-z]/.test(&quot;what&quot;)); // true    console.log(/[A-Z]/.test(&quot;Are&quot;)); // true    console.log(/[a-zA-Z]/.test(&quot;干啥子&quot;)); // false    console.log(/[0-9a-zA-Z]/.test(&quot;9ebg&quot;)); // true    console.log(/b|(ara)/.test(&quot;abra&quot;)); // true    console.log(/[a-z]{2,3}/.test(&quot;arfsf&quot;)); // true    console.log(&quot;=============================&gt;&quot;);    console.log(/\d/.test(&quot;998&quot;)); // true    console.log(/\d*/.test(&quot;998&quot;)); // true    console.log(/\d+/.test(&quot;998&quot;)); // true    console.log(/\d{0,}/.test(&quot;998&quot;)); // true    console.log(/\d{2,3}/.test(&quot;998&quot;)); // true    console.log(/\D/.test(&quot;eat&quot;)); // true    console.log(/\s/.test(&quot;  &quot;)); // true    console.log(/\S/.test(&quot;嘎嘎&quot;)); // true    console.log(/\w/.test(&quot;_&quot;)); // true    console.log(/\W/.test(&quot;_&quot;)); // false&lt;/script&gt;</code></pre><hr><h3 id="10-验证密码强度"><a href="#10-验证密码强度" class="headerlink" title="10.验证密码强度"></a>10.验证密码强度</h3><pre><code>&lt;!-- 案例: --&gt;&lt;style&gt;    #dv {        width: 300px;        height: 200px;        position: absolute;        left: 300px;        top: 100px;    }    .strengthLv0 {        height: 6px;        width: 120px;        border: 1px solid #ccc;        padding: 2px;    }    .strengthLv1 {        background: red;        height: 6px;        width: 40px;        border: 1px solid #ccc;        padding: 2px;    }    .strengthLv2 {        background: green;        height: 6px;        width: 80px;        border: 1px solid #ccc;        padding: 2px;    }    .strengthLv3 {        background: blue;        height: 6px;        width: 120px;        border: 1px solid #ccc;        padding: 2px;    }&lt;/style&gt;&lt;div id=&quot;dv&quot;&gt;    &lt;label for=&quot;pwd&quot;&gt;密码&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;pwd&quot; maxlength=&quot;16&quot;&gt;    &lt;!--课外话题--&gt;    &lt;div&gt;        &lt;em&gt;密码强度：&lt;/em&gt;        &lt;em id=&quot;strength&quot;&gt;&lt;/em&gt;        &lt;div id=&quot;strengthLevel&quot; class=&quot;strengthLv0&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // document.getElementById(&quot;pwd&quot;)    my$(&quot;pwd&quot;).onkeyup = function () {        // 获取文本框里面内容，根据你输入的不同的级别来显示不同的颜色        // 判断密码的长度        if (this.value.length &gt;= 6) {            // 调用级别函数            var lvl = getLvl(this.value);            // 判断            if (lvl == 1) {                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv1&quot;;            } else if (lvl == 2) {                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv2&quot;;            } else if (lvl == 3) {                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv3&quot;;            }        } else {            my$(&quot;strengthLevel&quot;).className = &quot;strengthLv0&quot;;        }    }    // 封装函数判断级别,给我密码，我来显示级别    function getLvl(pwd) { // 参数 pwd        // 默认的是0 级别        var lvl = 0; //默认值        // 密码中是否有数字        if (/[0-9]/.test(pwd)) {            lvl++; // 此时表示1级        }        // 两两组合        if (/[a-zA-Z]/.test(pwd)) {            lvl++; // 表示2级        }        // 三个组合        if (/[^0-9a-zA-Z_]/.test(pwd)) {            lvl++; // 表示3级        }        return lvl; // 1 2 3    }&lt;/script&gt;</code></pre><hr><h3 id="11-表单验证案例"><a href="#11-表单验证案例" class="headerlink" title="11.表单验证案例"></a>11.表单验证案例</h3><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0px;        padding: 0px;    }    body {        background: #ccc;    }    label,    input,    span {        display: inline-block;    }    label {        width: 40px;    }    span {        color: red;        margin-left: 40px;        width: 100%;    }    .container {        margin: 100px auto;        width: 280px;        padding: 50px;        line-height: 40px;        border: 1px solid #999;        background: #efefef;    }&lt;/style&gt;&lt;div class=&quot;container&quot; id&gt;    &lt;label for=&quot;qq&quot;&gt;Q Q:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;qq&quot;&gt;    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;    &lt;label for=&quot;phone&quot;&gt;手机:&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;phone&quot;&gt;    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;    &lt;label for=&quot;email&quot;&gt;邮箱:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;email&quot;&gt;    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;    &lt;label for=&quot;telephone&quot;&gt;座机:&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;telephone&quot;&gt;    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;    &lt;label for=&quot;name&quot;&gt;姓名:&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;&lt;/div&gt;&lt;script&gt;    function getId(id) {        return document.getElementById(id);    };    function getHint(eleId, reg, str) {        eleId.onblur = function () { // 失去焦点事件            if (reg.test(this.value)) {                this.nextElementSibling.nextElementSibling.innerText = &#39;正确&#39;;                this.nextElementSibling.nextElementSibling.style.color = &#39;green&#39;;            } else {                this.nextElementSibling.nextElementSibling.innerText = str;                this.nextElementSibling.nextElementSibling.style.color = &#39;red&#39;;            }        }    };    getHint(getId(&#39;qq&#39;), /^[1-9]\d{5,10}$/, &quot;qq号码要求1开头，纯数字6到11位&quot;);    getHint(getId(&#39;phone&#39;), /^[1-9]\d{10}$/, &quot;手机号要求1开头，纯数字11位&quot;);    getHint(getId(&#39;email&#39;), /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/, &quot;输入有误,按邮箱规则输入&quot;);    getHint(getId(&#39;telephone&#39;), /^\d{3,4}[-]\d{7,8}$/, &quot;区号要3-4位,号码要7到8位&quot;);    getHint(getId(&#39;name&#39;), /^[\u4e00-\u9fa5]{2,5}$/, &quot;要纯中文，字符长度2-5&quot;);&lt;/script&gt;</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> WebAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScriptES6语法学习笔记</title>
      <link href="/2019/12/25/javascriptes6-yu-fa-xue-xi-bi-ji/"/>
      <url>/2019/12/25/javascriptes6-yu-fa-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScriptES6"><a href="#JavaScriptES6" class="headerlink" title="JavaScriptES6"></a>JavaScriptES6</h1><h2 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数:"></a>ES6箭头函数:</h2><pre><code>例:let fn = val =&gt; val;此语法等同于:let fn = function(val){    return val;}</code></pre><pre><code>箭头函数:* 简化函数的声明;* 参数超过1个时必须加();* 函数体超过1行时,必须加{},并自己写return.</code></pre><pre><code>箭头函数的作用:* 简化回调函数;* 箭头函数中的this是函数声明时所在的对象.</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记</title>
      <link href="/2019/12/25/javascript-xue-xi-bi-ji/"/>
      <url>/2019/12/25/javascript-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="作用分区"><a href="#作用分区" class="headerlink" title="作用分区:"></a>作用分区:</h2><pre><code>Html:呈现网页的内容  --相当于定义一个人(有鼻子有眼)Css:用于设置网页的样式  --相当于进行化妆</code></pre><hr><h2 id="JS作用"><a href="#JS作用" class="headerlink" title="JS作用:"></a>JS作用:</h2><table><thead><tr><th align="center">JS作用</th></tr></thead><tbody><tr><td align="center">/<em>…</em>/:用于注释说明</td></tr><tr><td align="center">1.用于校检用户输入的表单数据</td></tr><tr><td align="center">2.用于与用户进行交互提示</td></tr><tr><td align="center">3.Ajax异步加载技术</td></tr><tr><td align="center">4.实现瀑布流,无需刷新,加载数据</td></tr></tbody></table><hr><h2 id="Html中使用JS的方法"><a href="#Html中使用JS的方法" class="headerlink" title="Html中使用JS的方法:"></a>Html中使用JS的方法:</h2><pre><code>1.直接在head标签中定义Script标签来定义JS例:&lt;script&gt;    alert(&#39;今天是你学习JS的第一天&#39;)&lt;/script&gt;2.可以在Html标签中直接使用JS事件属性设置JS例:① body里面给一个div&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;② 给div里一个点击事件&lt;div id=&quot;red&quot; onclick=&quot;alert(&#39;别瞎点&#39;)&quot;&gt;&lt;/div&gt;3.使用Script标签引入外部的JS文件① 新建一个.JS文件② 在任意一个位置引入&lt;script src=&quot;./memeda.js&quot;&gt;&lt;/script&gt;4.在超链接href属性中使用javascript标识符定义JS5.&lt;a href=&quot;javascript:alert(&#39;清除缓存成功&#39;)&quot;&gt;&lt;/a&gt;</code></pre><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h2><pre><code>单行注释: //多行注释: /**/文档注释:/**  */注:文档注释多用于函数以及对象或者文件功能的说明</code></pre><hr><h2 id="指令分隔符"><a href="#指令分隔符" class="headerlink" title="指令分隔符:"></a>指令分隔符:</h2><pre><code>定义:用于标志我们所写代码的结束1.使用分号作为指令分隔符例:alert(&#39;测试&#39;);2.使用换行符作为指令分隔符.</code></pre><hr><h2 id="JS的内容"><a href="#JS的内容" class="headerlink" title="JS的内容:"></a>JS的内容:</h2><pre><code>客户端浏览的JS;1.ECMAScript的核心语法结构(如何使用JS,如何定义JS的变量);2.包含Dom对象;3.包含Bom对象.</code></pre><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h2><pre><code>var uname = &#39;孙悟空&#39;; uname为变量名,整句意思为把孙悟空这个值赋给uname这个变量;console.log(变量名);  打印变量</code></pre><hr><h3 id="常用的变量类型"><a href="#常用的变量类型" class="headerlink" title="常用的变量类型:"></a>常用的变量类型:</h3><table><thead><tr><th align="center">常用变量类型</th></tr></thead><tbody><tr><td align="center">typeof:显示变量类型</td></tr><tr><td align="center">Number:数值类型</td></tr><tr><td align="center">Boolean:布尔类型</td></tr><tr><td align="center">String:字符串类型</td></tr><tr><td align="center">Function:函数类型</td></tr><tr><td align="center">Object:对象类型</td></tr><tr><td align="center">Undefined:未定义</td></tr></tbody></table><hr><pre><code>例:var num = 100;  //定义一个数值类型变量console.log(typeof num);  //打印num变量的类型</code></pre><hr><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则:"></a>变量命名规则:</h3><pre><code>首字符必须是英文字母,下划线,$;后跟任意长度的数字,字母,下划线,$;严格区分大小写;不允许使用JS的关键字和保留字;命名尽量有意义.驼峰命名法:变量名如果是由多个单词组成,第一个单词的首字母小写,其他单词的首字母进行大写;例:var className = &quot;一班&quot;;</code></pre><hr><h2 id="进制"><a href="#进制" class="headerlink" title="进制:"></a>进制:</h2><pre><code>在JS中无论以任何进制声明的数值类型变量,进行输出时,都是十进制.</code></pre><table><thead><tr><th align="center">常用变量类型</th><th align="center">组成</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">十进制</td><td align="center">0 1 2 3 4 5 6 7 8 9</td><td align="center">逢十进一</td></tr><tr><td align="center">二进制</td><td align="center">0 1</td><td align="center">逢二进一</td></tr><tr><td align="center">八进制</td><td align="center">0 1 2 3 4 5 6 7</td><td align="center">逢八进一</td></tr><tr><td align="center">十六进制</td><td align="center">0 1 2 3 4 5 6 7 8 9 a b c d e f</td><td align="center">逢十六进一</td></tr></tbody></table><hr><pre><code>二进制:0b开头二进制转十进制:从右到左,依次乘2的幂数,进行累加.例:0b10 --&gt; 0*2(上标0)+1*2(上标1)=0+2=20b110 --&gt; 0*2(上标0)+1*2(上标1)+1*2(上标2)=0+2+4=6八进制:0开头例:010 --&gt; 0*8(上标0)+1*8(上标1)=0+8=8十六进制:0x开头例:0x10 --&gt; 0*16(上标0)+1*16(上标1)=0+16=16</code></pre><hr><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符:"></a>比较运算符:</h2><pre><code>NaN:特点:NaN与任何一个数进行运算返回的结果都是NaN.NaN不与任何一个数相等.Number:包含了数值类型对象的相关信息.Boolean:布尔值表示真假.true:真;false:假;例:var bool = true;</code></pre><hr><h2 id="其他类型变量"><a href="#其他类型变量" class="headerlink" title="其他类型变量:"></a>其他类型变量:</h2><pre><code>使用function关键字定义函数.例:function makeBaby(){    console.log(&#39;...&#39;);}</code></pre><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串:"></a>字符串:</h3><pre><code>var str = &#39;&#39;;</code></pre><hr><h3 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h3><pre><code>object例:var obj = new Object();</code></pre><hr><h3 id="未定义"><a href="#未定义" class="headerlink" title="未定义"></a>未定义</h3><pre><code>undefined</code></pre><hr><h2 id="变量类型转换"><a href="#变量类型转换" class="headerlink" title="变量类型转换"></a>变量类型转换</h2><table><thead><tr><th align="center">变量类型转换</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">强制类型转换</td><td align="center">调用特定的函数为类型</td></tr><tr><td align="center">自动类型转换</td><td align="center">根据程序执行的环境发生自动类型转换,某个瞬间充当了某种类型,但是本身变量的类型是没有发生变化的</td></tr></tbody></table><hr><pre><code>强制类型转换:1.其他类型变量转为数值类型;任何一个数对n进行求余操作,结果有n种,最小值为0,最大值为n-1.</code></pre><hr><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级:"></a>运算符的优先级:</h2><pre><code>var a = 3;var c = a++ + ++aconsole.log(a);console.log(c);c = 3 + 4 --&gt; 7</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接:"></a>链接:</h2><pre><code>var a = 100 + 100 + &#39;100&#39;;console.log(a); --&gt; 200100console.log(typeof a); --&gt; string</code></pre><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><pre><code>var a = 3;var b = 4;if((a = 4) || (b = 5)){    a++;    b++;}console.log(a); --&gt; 5console.log(b); --&gt; 5</code></pre><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>函数的组成:函数名+函数体</code></pre><h3 id="函数的结构"><a href="#函数的结构" class="headerlink" title="函数的结构"></a>函数的结构</h3><pre><code>function 函数体(){    //函数体}</code></pre><hr><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用:"></a>函数的调用:</h3><pre><code>函数名();</code></pre><hr><h3 id="函数的命名规范"><a href="#函数的命名规范" class="headerlink" title="函数的命名规范:"></a>函数的命名规范:</h3><table><thead><tr><th align="center">函数的命名规范</th></tr></thead><tbody><tr><td align="center">1.首字符必须是字母,下划线,或是$;</td></tr><tr><td align="center">2.后跟任意长度的数字,字母,下划线,$;</td></tr><tr><td align="center">3.严格区分大小写;</td></tr><tr><td align="center">4.不能使用系统的关键字和保留字;</td></tr><tr><td align="center">5.命名尽量有意义;</td></tr><tr><td align="center">6.使用驼峰命名法</td></tr></tbody></table><hr><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><pre><code>将匿名函数赋值给变量例:var memeda = function(){    console.log(&#39;...&#39;);}console.log(memeda);</code></pre><pre><code>使用new function 构造函数定义函数.</code></pre><hr><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链:"></a>作用域链:</h2><pre><code>函数内部变量在进行查询时,遵守的规则:1.首先从函数自身所在的作用域进行查找;2.如果没有向父级或者是先辈作用域进行查找;3.如果没有最终的就是undefined.</code></pre><hr><h2 id="局部变量影响全部变量的方式"><a href="#局部变量影响全部变量的方式" class="headerlink" title="局部变量影响全部变量的方式:"></a>局部变量影响全部变量的方式:</h2><pre><code>1.在函数的内部不使用var关键字定义变量;(此时变量为全局变量);2.使用return关键字将局部变量的值返回到函数的外部使用对应的变量进行接收.</code></pre><hr><h2 id="函数类型划分"><a href="#函数类型划分" class="headerlink" title="函数类型划分:"></a>函数类型划分:</h2><pre><code>1.有参数的函数,无参数的函数;2.匿名函数,回调函数,立即执行函数;3.闭包函数,递归函数.</code></pre><hr><h2 id="循环使用场景"><a href="#循环使用场景" class="headerlink" title="循环使用场景:"></a>循环使用场景:</h2><pre><code>for:适合遍历数组,字符串等;for in:适合遍历对象;while:与for使用场景差不多,唯一不同的是遍历的条件必须满足;do while:至少执行一遍的循环,遍历数组和字符串也是很方便.</code></pre><hr><h2 id="undefined不是Null"><a href="#undefined不是Null" class="headerlink" title="undefined不是Null"></a>undefined不是Null</h2><pre><code>在Javascript中,Null用于对象,Undefined用于变量,属性和方法;对象只有被定义才有可能为Null,否则为Undefined.</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/2019/12/25/c-yu-yan-xue-xi-bi-ji/"/>
      <url>/2019/12/25/c-yu-yan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h2><pre><code>C语言是一种通用的,面向过程式的计算机程序设计语言,1972年,为了移植于开发UNIX操作系统,丹尼斯里奇在贝尔电话实验室设计开发了C语言.</code></pre><hr><h2 id="涵义"><a href="#涵义" class="headerlink" title="涵义:"></a>涵义:</h2><table><thead><tr><th align="center">涵义</th></tr></thead><tbody><tr><td align="center">/<em>…</em>/:用于注释说明</td></tr><tr><td align="center">printf():用于格式化输出到屏幕,printf()函数在’stdio.h’头文件中声明</td></tr><tr><td align="center">stdio.h:头文件(标准输入输出头文件),#include是一个预处理命令,用来引入头文件,当编译器遇到printf()函数时,如果没有找到stdio.h头文件,会发生编译错误</td></tr><tr><td align="center">return 0:语句用于表示退出程序</td></tr><tr><td align="center">int:标识符,定义整数型</td></tr><tr><td align="center">main:C语言入口函数</td></tr></tbody></table><hr><h2 id="a-和-a区别"><a href="#a-和-a区别" class="headerlink" title="a++和++a区别:"></a>a++和++a区别:</h2><table><thead><tr><th align="center">a++</th><th align="center">++a</th></tr></thead><tbody><tr><td align="center">a = 10 c = a++ 结果为c=10;a=11,此为先赋值后运算</td><td align="center">a = 10 c = ++a 结果为c=11;a=10,此为先运算后赋值</td></tr></tbody></table><hr><h2 id="C语言关键字"><a href="#C语言关键字" class="headerlink" title="C语言关键字:"></a>C语言关键字:</h2><table><thead><tr><th align="center">C语言关键字</th><th align="center">C语言关键字</th><th align="center">C语言关键字</th></tr></thead><tbody><tr><td align="center">auto:声明自动变量</td><td align="center">break:跳出当前循环,一般与switch连用</td><td align="center">case:开关语句分支.与switch连用</td></tr><tr><td align="center">char:声明字符型变量或函数返回值类型</td><td align="center">const:声明只读变量</td><td align="center">continue:结束当前循环,开始下一轮循环</td></tr><tr><td align="center">default:开关语句中的’其他分支’,一般与switch连用,用于描述其他情况</td><td align="center">do:循环语句的循环体</td><td align="center">double:声明双精度浮点型变量或函数返回值类型</td></tr><tr><td align="center">else:条件语句否定分支(与if连用)</td><td align="center">enum:声明枚举变量</td><td align="center">extern:声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td align="center">float:声明浮点型变量或函数返回值类型</td><td align="center">for:一种循环语句</td><td align="center">goto:无条件跳转语句</td></tr><tr><td align="center">if:条件语句</td><td align="center">int:声明整型变量或函数</td><td align="center">long:声明长整型变量或函数返回值类型</td></tr><tr><td align="center">register:声明寄存器变量</td><td align="center">return:子程序返回语句(可以带参数,也可以不带参数)</td><td align="center">short:声明短整型变量或函数</td></tr><tr><td align="center">signed:声明有符号类型或变量长度</td><td align="center">static:声明静态变量</td><td align="center">struct:声明结构体类型</td></tr><tr><td align="center">switch:用于开关语句(与case连用)</td><td align="center">typedef:用以给数据类型取别名</td><td align="center">unsigned:声明无符号类型变量或函数</td></tr><tr><td align="center">union:声明共用体类型</td><td align="center">void:声明函数无返回值或无参数,声明无类型指针</td><td align="center">while:循环语句的循环条件</td></tr></tbody></table><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th align="center">数据类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1.基本类型:</td><td align="center">它们是算数类型,包括两种类型:整数类型和浮点类型</td></tr><tr><td align="center">2.枚举类型:</td><td align="center">它们也是算数类型,是被用来定义在程序中只能赋予其一定的离散整数值的变量</td></tr><tr><td align="center">3.void类型:</td><td align="center">类型说明符,void表明没有可用的值</td></tr><tr><td align="center">4.派生类型:</td><td align="center">它们包括:指针类型,数组类型,结构类型,共用体类型和函数类型</td></tr></tbody></table><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th align="center">类型</th><th align="center">存储大小</th><th align="center">值范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1字节</td><td align="center">-128到127或0到255</td></tr><tr><td align="center">unsigned char</td><td align="center">1字节</td><td align="center">0到255</td></tr><tr><td align="center">signed char</td><td align="center">1字节</td><td align="center">-128到127</td></tr><tr><td align="center">int</td><td align="center">2到4字节</td><td align="center">-32,768到32,768或-2,147,483,648到2,147,483,647</td></tr><tr><td align="center">unsogned int</td><td align="center">2到4字节</td><td align="center">0到65,535或0到4,294,967,295</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td align="center">-32,768到32,767</td></tr><tr><td align="center">unsigned short</td><td align="center">2字节</td><td align="center">0到65,535</td></tr><tr><td align="center">long</td><td align="center">4字节</td><td align="center">-2,147,483,648到2,147,483,647</td></tr><tr><td align="center">unsigned long</td><td align="center">4字节</td><td align="center">0到4,294,967,295</td></tr></tbody></table><hr><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><table><thead><tr><th align="center">类型</th><th align="center">存储大小</th><th align="center">值范围</th><th align="center">精度</th></tr></thead><tbody><tr><td align="center">float</td><td align="center">4字节</td><td align="center">1.2E-38到3.4E+38</td><td align="center">6位小数</td></tr><tr><td align="center">double</td><td align="center">8字节</td><td align="center">2.3E-308到1.7E+308</td><td align="center">15位小数</td></tr><tr><td align="center">long double</td><td align="center">16字节</td><td align="center">3.4E-4932到1.1E+4932</td><td align="center">19位小数</td></tr></tbody></table><h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><pre><code>void类型指定没有可用的值1.函数返回为空C语言有各种函数都不返回值,或者您可以说它们返回为空,不返回值的函数的返回类型为空,例如:void exit(in status);2.函数参数为空C语言中有各种函数不接受任何参数,不带参数的函数可以接收一个void,例如:int rand(void);3.指针指向void类型为void\*的指针代表对象的地址,而不是类型,例如,内存分配函数void\* malloc(size-t size);返回指向void的指针,可以转换为任何数据类型</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">通常是一个字节(八位),这是一个整数类型</td></tr><tr><td align="center">int</td><td align="center">对机器而言,整数的最自然的大小</td></tr><tr><td align="center">float</td><td align="center">单精度浮点值.格式:1位符号,8位指数,23位小数</td></tr><tr><td align="center">double</td><td align="center">双精度浮点值.格式:1位符号,11位指数,52位小数</td></tr><tr><td align="center">void</td><td align="center">表示类型的缺失</td></tr></tbody></table><hr><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><pre><code>1.一种是需要建立存储空间的,例:int a 在声明时就已经建立了存储空间.2.不需要建立存储空间的,通过使用extern关键字声明变量名而不是定义它.注:除非有extern关键字,否则都是变量的定义,extern int 1; //声明,而不是定义;int i; //声明,也是定义</code></pre><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><table><thead><tr><th align="center">左值</th><th align="center">右值</th></tr></thead><tbody><tr><td align="center">指向内存位置的表达式被成为左值表达式,左值可以出现在赋值号的左边或右边</td><td align="center">术语右值指的是存储在内存中某些地址的数值,右值是不能对其进行赋值的表达式,也就是说,右值可以出现在赋值号的右边,但不能出现在赋值号的左边</td></tr></tbody></table><pre><code>注:变量是左值,因此可以出现在赋值号的左边,数值型的字面值是右值,因此不能被赋值,不能出现在赋值号的左边例:int g = 20; //此表达式对,成立.10 = 20; //此表达式为错,不成立.</code></pre><hr><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><pre><code>常量是固定值,在程序执行期间不会改变;常量可以是任何的基础数据类型,比如整数常量,浮点常量字符常量或字符串字面值,也有枚举常量;常量就像是常规的变量,只不过常量的值在定以后不能修改.</code></pre><p>例:</p><table><thead><tr><th align="center">常量</th></tr></thead><tbody><tr><td align="center">85 十进制</td></tr><tr><td align="center">0213 八进制</td></tr><tr><td align="center">0x4b 十六进制</td></tr><tr><td align="center">30 整数</td></tr><tr><td align="center">30u 无符号整数</td></tr><tr><td align="center">30l 长整数</td></tr><tr><td align="center">30ul 无符号长整数</td></tr></tbody></table><hr><h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><pre><code>由整数部分,小数点,小数部分和指数部分组成.例:3.14159</code></pre><hr><h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><pre><code>字符常量括在单引号中;例:&#39;x&#39;可以存储在char类型的简单变量中例:printf(&quot;%d\n&quot;,x)</code></pre><hr><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table><thead><tr><th align="center">转义序列</th><th align="center">含义</th><th align="center">转义序列</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">\字符</td><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">&#39;</td><td align="center">‘字符</td><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">&quot;</td><td align="center">“字符</td><td align="center">\t</td><td align="center">水平制表符</td></tr><tr><td align="center">?</td><td align="center">?字符</td><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">\a</td><td align="center">警报铃声</td><td align="center">\ooo</td><td align="center">一到三位的八进制数</td></tr><tr><td align="center">\b</td><td align="center">退格键</td><td align="center">\f</td><td align="center">换页符</td></tr></tbody></table><hr><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><pre><code>字符串字面值或常量是括在双引号中的,一个字符串包含类似于字符常量的字符,普通的字符,转义序列和通用的字符.你可以使用空格做分隔符,把一个很长的字符串常量进行分行.例:&quot;Hello,World&quot;&quot;Hello,\ dear&quot;&quot;Hello,&quot;&quot;d&quot;&quot;ear&quot;</code></pre><hr><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><pre><code>1.使用#define预处理器2.使用const关键字例:#define LENGTH 10 //定义一个常量,把10赋值给常量const type variable = value;</code></pre><hr><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">两个数相加</td><td align="center">A+B将得到30</td></tr><tr><td align="center">-</td><td align="center">从第一个操作数中减去第二个操作数</td><td align="center">A-B将得到-10</td></tr><tr><td align="center">*</td><td align="center">两个操作数相乘</td><td align="center">A*B将得到200</td></tr><tr><td align="center">/</td><td align="center">分子除以分母</td><td align="center">B/A将得到2</td></tr><tr><td align="center">%</td><td align="center">取模运算符,整除后的余数</td><td align="center">B%A将得到0</td></tr><tr><td align="center">++</td><td align="center">自增运算符,整数值增加1</td><td align="center">A++将得到11</td></tr><tr><td align="center">–</td><td align="center">自减运算符,整数值减少1</td><td align="center">A–将得到9</td></tr></tbody></table><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个操作数的值是否相等,如相等则条件为真</td><td align="center">(A==B)为假</td></tr><tr><td align="center">!=</td><td align="center">检查两个操作数的值是否相等,如不相等则条件为真</td><td align="center">(A!=B)为真</td></tr><tr><td align="center">&gt;</td><td align="center">检查左操作数的值是否大于右操作数的值,如果是则条件为真</td><td align="center">(A&gt;B为假)</td></tr><tr><td align="center">&lt;</td><td align="center">检查左操作数的值是否小于右操作数的值,如果是则条件为真</td><td align="center">(A&lt;B为真)</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左操作数的值是否大于或等于右操作数的值,如果是则条件为真</td><td align="center">(A&gt;=B为假)</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左操作数的值是否小于或等于右操作数的值,如果是则条件为真</td><td align="center">(A&lt;=B为真)</td></tr></tbody></table><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与运算符,如果两个操作数非零,则条件为真</td><td align="center">(A&amp;&amp;B)为假</td></tr><tr><td align="center">||</td><td align="center">逻辑或运算符,如果两个操作数中有任意一个非零,则条件为真</td><td align="center">(A||B)为真</td></tr><tr><td align="center">!</td><td align="center">逻辑非运算符,用来逆转操作数的逻辑状态</td><td align="center">如果条件为真,则逻辑非运算符将使其为假</td></tr></tbody></table><hr><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">把右边操作数赋给左边操作数</td><td align="center">C=A+B,将A+B的值赋给C</td></tr><tr><td align="center">+=</td><td align="center">加且赋值运算符,把右边操作数加上左边操作数赋给左边操作数</td><td align="center">C+=A相当于C=C+A</td></tr><tr><td align="center">-=</td><td align="center">减且赋值运算符,把右边操作数减去左边操作数赋给左边操作数</td><td align="center">C-=A相当于C=C-A</td></tr><tr><td align="center">*=</td><td align="center">乘且赋值运算符,把右边操作数乘左边操作数赋给左边操作数</td><td align="center">C<em>=A相当于C=C</em>A</td></tr><tr><td align="center">/=</td><td align="center">除且赋值运算符,把左边操作数除以右边操作数赋给左边操作数</td><td align="center">C/=A相当于C=C/A</td></tr><tr><td align="center">%=</td><td align="center">求模且赋值运算符,求两个操作数的模赋值给左边操作数</td><td align="center">C%=A相当于C=C%A</td></tr></tbody></table><hr><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><table><thead><tr><th align="center">占位符①</th><th align="center">占位符②</th><th align="center">占位符③</th></tr></thead><tbody><tr><td align="center">%d,%i 代表十进制整数</td><td align="center">%f 代表浮点</td><td align="center">%s 代表字符串</td></tr><tr><td align="center">%c 代表char</td><td align="center">%p 代表指针</td><td align="center">%fL 代表长log</td></tr><tr><td align="center">%e 代表科学计数</td><td align="center">%g 代表小数</td><td align="center">%a,%A 代表读入一个浮点值(仅C99可用)</td></tr><tr><td align="center">%c 代表读入一个字符</td><td align="center">%u 代表无符号十进制整数</td><td align="center">% n 代表等价字符</td></tr><tr><td align="center">%o 代表八进制整数</td><td align="center">%x,%X 代表十六禁止整数</td><td align="center">%f,%F,%e,%E,%g,%G 代表实数</td></tr></tbody></table><hr><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><pre><code>栈:有效的是局部变量(在方法和语句块内部定义的变量),当方法和语句块一结束.空间马上释放.堆:存放的是成员变量(也叫属性,在方法外,在类里定义的变量),随着对象而产生,随着对象销毁而销毁.数据段:存放的是类变量(也叫静态变量,和成员变量相比多加上关键字staic),常驻内存,创建好之后不会消失.代码段:是存了程序代码的数据,在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等.</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作学习笔记</title>
      <link href="/2019/12/24/linux-ji-ben-cao-zuo-xue-xi-bi-ji/"/>
      <url>/2019/12/24/linux-ji-ben-cao-zuo-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别:"></a>运行级别:</h2><table><thead><tr><th align="center">命令模式</th></tr></thead><tbody><tr><td align="center">级别0:系统停机状态,系统默认不能设置为0,否则不能正常启动</td></tr><tr><td align="center">级别1:单用户工作状态,root权限用于系统维护,禁止远程登录</td></tr><tr><td align="center">级别2:多用户状态(没有NFS)</td></tr><tr><td align="center">级别3:完全的多用户状态,(有NFS),登录后进入控制台命令行模式</td></tr><tr><td align="center">级别4:系统未使用,保留</td></tr><tr><td align="center">级别5:X11控制台,登陆后进入图形GUI模式</td></tr><tr><td align="center">级别6:系统正常关闭并重启,默认不能设为6,否则不能正常启动</td></tr></tbody></table><hr><h2 id="登录方式"><a href="#登录方式" class="headerlink" title="登录方式:"></a>登录方式:</h2><table><thead><tr><th align="center">登录方式</th></tr></thead><tbody><tr><td align="center">①:命令行登录</td></tr><tr><td align="center">②:ssh登录</td></tr><tr><td align="center">③:图形界面登录</td></tr></tbody></table><hr><h3 id="切换"><a href="#切换" class="headerlink" title="切换:"></a>切换:</h3><table><thead><tr><th align="center">切换方式</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+F1-F6切换界面</td></tr><tr><td align="center">Ctrl+Alt+F1返回图形界面</td></tr></tbody></table><hr><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作:"></a>常用操作:</h2><h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录:"></a>安装目录:</h3><p>软件安装目录一般为:</p><pre><code>/usr/local/新建一个文件夹</code></pre><p>相对路径:从当前路径,不写根;<br>例:</p><pre><code>cd usr/</code></pre><p>绝对路径:从根开始;<br>例:</p><pre><code>cd /usr/</code></pre><hr><h3 id="用户"><a href="#用户" class="headerlink" title="用户:"></a>用户:</h3><table><thead><tr><th align="center">超级用户</th><th align="center">普通用户</th></tr></thead><tbody><tr><td align="center">#</td><td align="center">$</td></tr></tbody></table><hr><h3 id="关机重启正确步骤"><a href="#关机重启正确步骤" class="headerlink" title="关机重启正确步骤:"></a>关机重启正确步骤:</h3><p>步骤①:先执行数据同步</p><pre><code>sync</code></pre><p>步骤②:关机正确命令</p><pre><code>shutdown -h now</code></pre><p>步骤③:重启正确命令</p><pre><code>shutdown -r now</code></pre><hr><h3 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接:"></a>硬链接与软链接:</h3><h4 id="硬链接-不常用"><a href="#硬链接-不常用" class="headerlink" title="硬链接(不常用):"></a>硬链接(不常用):</h4><pre><code>源文件和硬链接拥有相同的Inode号和Black块,可以看成同一个文件,如果修改任意一个文件,另一个内容都可以改变;删除任意一个文件,另一个都可以正常使用,除非两个都删除.</code></pre><pre><code>缺点:硬链接不能跨分区,不能链接目录.</code></pre><pre><code>ln /root/abc /tmp/abc-h</code></pre><h4 id="软链接-常用"><a href="#软链接-常用" class="headerlink" title="软链接(常用):"></a>软链接(常用):</h4><pre><code>软链接有自己独立的Inode号和Block块,但是Block块不记录,只写入源文件的文件名和Inode号,不论源文件多大,软链接大小不变.软链接是最大权限777,但是访问还是要受源文件权限限制;修改任意一个文件,另一个都可以改变;删除软链接,源文件不变;但是删除源文件,软链接无法访问;软链接可以跨分区,可以链接目录,特征明显.</code></pre><pre><code>ln -s 源文件 目标文件(文件名都必须写绝对路径)</code></pre><hr><h3 id="权限"><a href="#权限" class="headerlink" title="权限:"></a>权限:</h3><table><thead><tr><th align="center">文件权限</th></tr></thead><tbody><tr><td align="center">所有者</td></tr><tr><td align="center">所属组</td></tr><tr><td align="center">其他人</td></tr></tbody></table><hr><table><thead><tr><th align="center">文件权限</th></tr></thead><tbody><tr><td align="center">‘r’:读,数字代表为4</td></tr><tr><td align="center">‘w’:写,数字代表为2</td></tr><tr><td align="center">‘x’:执行,数字代表为1</td></tr></tbody></table><hr><table><thead><tr><th align="center">常用文件权限</th></tr></thead><tbody><tr><td align="center">‘644’:代表所有者是读,写权限,而所属组和其他人是只读权限</td></tr><tr><td align="center">‘755’:代表所有者是读,写,执行权限,所属组和其他人是读和执行权限(最常用权限)</td></tr><tr><td align="center">‘777’:最大权限,在实际的生产服务器中,要尽力避免赋予这样的权限</td></tr></tbody></table><hr><pre><code>注:目录最大权限不是执行权限,而是写权限,因为目录不能被执行,文件的最大权限是执行权限.</code></pre><hr><table><thead><tr><th align="center">本地访问</th><th align="center">网络访问</th></tr></thead><tbody><tr><td align="center">本地权限生效</td><td align="center">网络权限和本地权限同时生效</td></tr></tbody></table><hr><h4 id="权限第一位代表方式"><a href="#权限第一位代表方式" class="headerlink" title="权限第一位代表方式:"></a>权限第一位代表方式:</h4><table><thead><tr><th align="center">权限第一位表示</th><th align="center">权限第一位表示</th></tr></thead><tbody><tr><td align="center">‘-‘:普通文件</td><td align="center">‘b’:块设备文件,存储设备文件,如硬盘,光盘,U盘等</td></tr><tr><td align="center">‘c’:字符设备文件,输入设备文件,如鼠标,键盘等</td><td align="center">‘d’:目录文件</td></tr><tr><td align="center">‘p’:管道符文件</td><td align="center">‘c’:软链接文件</td></tr></tbody></table><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h2><pre><code>ll -ha 长格式显示所有文件ll -hd 查看目录本身ll -hi 查看Inode节点号cd ~ 进入当前用户家目录cd - 进入上次目录cd .. 进入上一级目录cd . 进入当前目录rm -rf 文件名或目录名 递归强制删除文件或目录rm -rf /目录/* 删除目录里的任意内容tree 目录树安装tree命令:sudo apt-get install treetouch 文件名 创建文件注:如果文件存在,则修改文件时间为当前时间,如果文件不存在,则创建这个文件touch -d &quot;20xx-xx-xx xx:xx:xx&quot; 文件名 修改文件时间cat 文件名 查看文件内容(从头到尾,有极限)more 文件名 查看文件内容(按百分比,可查看全部)head -行数 文件名 查看文件前n行tail -行数 文件名 查看文件后n行监听文件实时改动:tail -f 文件名cp 文件名 目录 复制文件到目录例:cp abc /tmp/ 把abc文件复制到tmp目录里cp -r 123 /tmp 把123这个目录复制到tmp目录里注:&#39;-r&#39;代表目录,此时复制的文件跟源文件不一样(包括时间,Inode节点号)cp -a abc /tmp/bcd 把abc复制到tmp目录里并改名为bcd注:这种方法复制的文件跟源文件一样(包括时间,Inode节点号)mv 123 /tmp/ 把123文件剪切进tmp目录里注:mv不用加参数别名:aliasalias ser=&#39;service network restart&#39; 命名快捷命令&#39;ser&#39;,并链接到&#39;service network restart&#39;命令上,此时命令为临时生效,重启后失效注:如需永久生效,可把上方命令加进root目录下的&#39;.bashrc&#39;文件内注:root里,只对当前用户生效,如需所有用户生效,可把上方命令放入etc目录下文件内df -h 查询分区使用情况chmod 权限 文件名例:chmod 755 abcuseradd 用户名 建立新用户注:建立完用户后,应立即使用&#39;passwd&#39;命令修改新用户密码.否则用户不能登录usermod -l 新用户名 旧用户名 修改用户名groupadd 组名 新建用户组groupmod -n 新组名 旧组名 修改组名chown 所有者 文件名 更改文件所有者chown 所有者:所属组 文件名 既更改文件所有者,又更改文件所属组把用户加进另一个组(常用):usermod -a -G 组名 用户名id -gn 显示组idid 显示id搜索:1.locate    优点:占用资源少,按数据库查找    updatedb 此命令强制更新数据库(在locate命令搜索不到的时候用)例:locate abc2.find    此命令通过查找全盘来进行例:find / -name abc 从根目录开始查找abc文件3.grep    此命令按字符串进行查找例:grep &quot;123&quot; abc 从abc里搜索带有123字符的数据</code></pre><hr><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符:"></a>通配符:</h3><table><thead><tr><th align="center">通配符</th></tr></thead><tbody><tr><td align="center">‘*’:任意内容</td></tr><tr><td align="center">‘?’:任意一个内容(一定要有一个才可以)</td></tr><tr><td align="center">‘[]’:中括号内任意一个内容</td></tr></tbody></table><hr><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式:"></a>正则表达式:</h3><pre><code>&#39;*&#39;:前一个字符重复任意多次;&#39;?&#39;:前一个字符重复0次或1次;例:egrep &quot;a1?2&quot; abc 在abc文件中查找a 1个1,a 没有1;&#39;[]&#39;:中括号内任意一个内容;&#39;^&#39;:行首;例:egrep &quot;^123&quot; abc 在abc文件中查找123开头的字符;&#39;$&#39;:行尾;例:egrep &quot;123$&quot; abc 在abc文件中查找123结尾的字符;</code></pre><hr><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符:"></a>管道符:</h3><pre><code>&#39;|&#39;例:ll /etc/ | grep abc 从etc目录下搜索abc所有例:netstat -tuln | grep 80 查看运行端口80的服务</code></pre><hr><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩:"></a>压缩:</h3><pre><code>tar -zcvf 文件名.tar.gz 需要压缩文件的路径</code></pre><hr><h3 id="解压"><a href="#解压" class="headerlink" title="解压:"></a>解压:</h3><pre><code>tar -zxvf 压缩包名</code></pre><h4 id="解压到指定位置"><a href="#解压到指定位置" class="headerlink" title="解压到指定位置:"></a>解压到指定位置:</h4><pre><code>tar -zxvf 压缩包名 -C 解压路径</code></pre><h4 id="只查看不解压"><a href="#只查看不解压" class="headerlink" title="只查看不解压:"></a>只查看不解压:</h4><pre><code>tar -ztvf 压缩包名注:&#39;t&#39;为测试意思</code></pre><hr><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载:"></a>挂载:</h3><pre><code>fdisk -l 查看分区列表mount 查询挂载了哪些设备mount 设备名 挂载点例:mount /dev/sdc1/ /mnt/usb/把dev目录下的sdc1硬件挂载进mnt目录下的usb挂载点内</code></pre><h4 id="卸载挂载"><a href="#卸载挂载" class="headerlink" title="卸载挂载"></a>卸载挂载</h4><pre><code>umount /mnt/usb/</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本命令学习笔记</title>
      <link href="/2019/12/24/git-ji-ben-ming-ling-xue-xi-bi-ji/"/>
      <url>/2019/12/24/git-ji-ben-ming-ling-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h2><pre><code>分布式版本控制系统</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h2><h3 id="在-Linux-上安装"><a href="#在-Linux-上安装" class="headerlink" title="在 Linux 上安装:"></a>在 Linux 上安装:</h3><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。</p><pre><code>$ sudo yum install git</code></pre><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p><pre><code>$ sudo apt-get install git</code></pre><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建:"></a>创建:</h2><p>创建空目录:</p><pre><code>mkdir 目录名</code></pre><p>打开目录:</p><pre><code>cd 目录名</code></pre><p>把目录变成Git可管理的仓库:</p><pre><code>git init</code></pre><p>提交用户名:</p><pre><code>$ git config --global user.name &quot;用户名&quot;</code></pre><p>提交邮箱:</p><pre><code>$ git config --global user.email &quot;邮箱&quot;</code></pre><p>建立本机SSH协议秘钥:</p><pre><code>ssh-keygen -t rsa -C &#39;邮箱&#39;</code></pre><p>建立与远程库的链接(建议用ssh协议):</p><pre><code>git remote add 需要设置的库名 远程库的链接</code></pre><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h2><h3 id="将文件提交到暂存区"><a href="#将文件提交到暂存区" class="headerlink" title="将文件提交到暂存区:"></a>将文件提交到暂存区:</h3><pre><code>git add 文件名</code></pre><hr><h3 id="将暂存区文件提交到本地版本库"><a href="#将暂存区文件提交到本地版本库" class="headerlink" title="将暂存区文件提交到本地版本库:"></a>将暂存区文件提交到本地版本库:</h3><pre><code>git commit -m &quot;说明&quot;</code></pre><hr><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态:"></a>查看工作区状态:</h3><pre><code>git status</code></pre><hr><h3 id="回退"><a href="#回退" class="headerlink" title="回退:"></a>回退:</h3><pre><code>git checkout --hard HEAD^</code></pre><p>此处(HEAD^为上个版本,可换为版本ID号)</p><h4 id="将暂存区还未提交的改动撤销"><a href="#将暂存区还未提交的改动撤销" class="headerlink" title="将暂存区还未提交的改动撤销:"></a>将暂存区还未提交的改动撤销:</h4><pre><code>git reset HEAD 文件名</code></pre><h4 id="将提交到版本库里的文件替换回暂存区-参考版本回退"><a href="#将提交到版本库里的文件替换回暂存区-参考版本回退" class="headerlink" title="将提交到版本库里的文件替换回暂存区(参考版本回退):"></a>将提交到版本库里的文件替换回暂存区(参考版本回退):</h4><pre><code>git checkout -- 文件名</code></pre><hr><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史:"></a>查看提交历史:</h3><pre><code>git reflog</code></pre><hr><h3 id="丢弃工作区"><a href="#丢弃工作区" class="headerlink" title="丢弃工作区:"></a>丢弃工作区:</h3><pre><code>git checkout -- 文件名</code></pre><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h3><h4 id="步骤①"><a href="#步骤①" class="headerlink" title="步骤①:"></a>步骤①:</h4><pre><code>rm 文件名</code></pre><h4 id="步骤②"><a href="#步骤②" class="headerlink" title="步骤②:"></a>步骤②:</h4><pre><code>git rm 文件名</code></pre><h4 id="步骤③"><a href="#步骤③" class="headerlink" title="步骤③:"></a>步骤③:</h4><pre><code>git commit -m &quot;说明&quot;</code></pre><hr><h3 id="误删除一个文件-恢复操作"><a href="#误删除一个文件-恢复操作" class="headerlink" title="误删除一个文件,恢复操作:"></a>误删除一个文件,恢复操作:</h3><pre><code>git reset HEAD 文件名</code></pre><p>或者</p><pre><code>git checkout -- 文件名</code></pre><hr><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作:"></a>分支操作:</h3><h4 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支:"></a>创建并切换分支:</h4><pre><code>git checkout -b 分支名</code></pre><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支:"></a>切换分支:</h4><pre><code>git checkout 分支名</code></pre><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支:"></a>查看分支:</h4><pre><code>git branch</code></pre><h5 id="查看远程分支-此命令实际是查看所有分支"><a href="#查看远程分支-此命令实际是查看所有分支" class="headerlink" title="查看远程分支(此命令实际是查看所有分支):"></a>查看远程分支(此命令实际是查看所有分支):</h5><pre><code>git branch -a</code></pre><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支:"></a>删除分支:</h4><pre><code>git branch -d 分支名</code></pre><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支:"></a>删除远程分支:</h5><pre><code>git push -d 库名 分支名</code></pre><h4 id="修改分支名称"><a href="#修改分支名称" class="headerlink" title="修改分支名称:"></a>修改分支名称:</h4><h5 id="修改本地分支名称"><a href="#修改本地分支名称" class="headerlink" title="修改本地分支名称:"></a>修改本地分支名称:</h5><pre><code>git branch -m 当前分支名 需要修改的分支名</code></pre><h5 id="修改远程分支名称"><a href="#修改远程分支名称" class="headerlink" title="修改远程分支名称:"></a>修改远程分支名称:</h5><pre><code>第一步:先删除远程分支第二步:更改本地分支名第三步:上传本地分支到远程库</code></pre><h4 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支:"></a>合并某分支到当前分支:</h4><pre><code>git merge 分支名</code></pre><p>也可用’rebase’变基操作.</p><h4 id="查看分支合并情况"><a href="#查看分支合并情况" class="headerlink" title="查看分支合并情况:"></a>查看分支合并情况:</h4><pre><code>git log --graph</code></pre><h4 id="隐藏工作区"><a href="#隐藏工作区" class="headerlink" title="隐藏工作区:"></a>隐藏工作区:</h4><pre><code>git stash</code></pre><h4 id="显示工作区"><a href="#显示工作区" class="headerlink" title="显示工作区:"></a>显示工作区:</h4><pre><code>git stash list</code></pre><h4 id="恢复工作区"><a href="#恢复工作区" class="headerlink" title="恢复工作区:"></a>恢复工作区:</h4><pre><code>git stash pop</code></pre><h4 id="恢复工作区后复制一个特定的提交到当前分支"><a href="#恢复工作区后复制一个特定的提交到当前分支" class="headerlink" title="恢复工作区后复制一个特定的提交到当前分支:"></a>恢复工作区后复制一个特定的提交到当前分支:</h4><pre><code>git cherry-pick 版本ID号</code></pre><hr><h3 id="抓取和提交以及克隆"><a href="#抓取和提交以及克隆" class="headerlink" title="抓取和提交以及克隆:"></a>抓取和提交以及克隆:</h3><h4 id="抓取"><a href="#抓取" class="headerlink" title="抓取:"></a>抓取:</h4><pre><code>git pull 库名 分支名</code></pre><p>每次抓取完成后都要对比信息是否正确:</p><pre><code>git diff</code></pre><h4 id="提交"><a href="#提交" class="headerlink" title="提交:"></a>提交:</h4><h5 id="向远程推送分支内容"><a href="#向远程推送分支内容" class="headerlink" title="向远程推送分支内容:"></a>向远程推送分支内容:</h5><pre><code>git push 库名 分支名</code></pre><h5 id="推送本地分支到远程分支"><a href="#推送本地分支到远程分支" class="headerlink" title="推送本地分支到远程分支:"></a>推送本地分支到远程分支:</h5><pre><code>git push 库名 本地分支名:远程分支名</code></pre><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆:"></a>克隆:</h4><pre><code>git clone git链接</code></pre><h4 id="远程库"><a href="#远程库" class="headerlink" title="远程库:"></a>远程库:</h4><h5 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库:"></a>查看远程库:</h5><pre><code>git remote -v</code></pre><h5 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库:"></a>删除远程库:</h5><pre><code>git remote rm 库名</code></pre><hr><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><h4 id="如何打标签"><a href="#如何打标签" class="headerlink" title="如何打标签:"></a>如何打标签:</h4><p>先切换到需要打标签的分支上;</p><pre><code>git checkout 分支名</code></pre><p>打标签:</p><pre><code>git tag 标签内容</code></pre><p>给历史内容打标签:</p><pre><code>git log 标签内容 ID号</code></pre><p>创建有说明的标签:</p><pre><code>git tag -a 标签内容 -m &quot;说明&quot; ID号</code></pre><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签:"></a>查看标签:</h4><pre><code>git tag</code></pre><h4 id="查看标签说明"><a href="#查看标签说明" class="headerlink" title="查看标签说明:"></a>查看标签说明:</h4><pre><code>git show 标签名</code></pre><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签:"></a>删除标签:</h4><pre><code>git tag -d 标签名</code></pre><h4 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签:"></a>推送标签:</h4><pre><code>git push 库名 标签名</code></pre><h5 id="一次性推送未推送到远程的标签"><a href="#一次性推送未推送到远程的标签" class="headerlink" title="一次性推送未推送到远程的标签:"></a>一次性推送未推送到远程的标签:</h5><pre><code>git push 库名 --tags</code></pre><h4 id="远程删除标签"><a href="#远程删除标签" class="headerlink" title="远程删除标签"></a>远程删除标签</h4><p>第一步:必须先删除本地标签;</p><pre><code>git tag -d 标签名</code></pre><p>第二步:再删除远程标签;</p><pre><code>git push 库名 :refs/tags/标签名</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim基本命令学习笔记</title>
      <link href="/2019/12/24/vim-ji-ben-ming-ling-xue-xi-bi-ji/"/>
      <url>/2019/12/24/vim-ji-ben-ming-ling-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h2><pre><code>Vim是从Vi发展出来的一个文件编辑器</code></pre><hr><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式:"></a>三种模式:</h2><table><thead><tr><th align="center">命令模式</th><th align="center">输入模式</th><th align="center">底线命令模式</th></tr></thead><tbody><tr><td align="center">此状态下敲击键盘会被Vim识别为命令,而非代码</td><td align="center">命令模式下按I进入输入模式</td><td align="center">命令模式下按:(英文冒号)进入底线命令模式</td></tr></tbody></table><hr><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标:"></a>移动光标:</h2><pre><code>h:左移;j:下移;k:上移;l:右移如:向下移十行:10j;向上移十行:10k;向下移一页:pgDn;向上移一页:pgUp;向下移半页:Ctrl+d;向上移半页:Ctrl+u;移动到本行首字符:Home;移动到本行尾字符:End;移动到最上方一行(当前屏幕):H;移动到最中间一行(当前屏幕):M;移动到最后一行(当前屏幕):L;移动到最上方一行(全部代码最上方):gg;移动到最下方一行(全部代码最下方):G;向下移动n行:n&lt;Enter&gt;(回车键);或nG;</code></pre><hr><h2 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换:"></a>搜索替换:</h2><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索:"></a>搜索:</h3><pre><code>向光标之下查询:/需要查询的字符;向下重复查询:n;向光标之上查询:?需要查询的字符;向上重复查询:N;</code></pre><h3 id="替换"><a href="#替换" class="headerlink" title="替换:"></a>替换:</h3><pre><code>替换当前行:&#39;:s/需要替换的字符/替换的字符/g&#39;替换多行:&#39;:n1,n2s/需要替换的字符/替换的字符/g&#39;例:在5-10行里查找到Word,并替换为Excal:5,10/Word/Excal/g从第1行到最后一行里查找到Word,并替换为Excal:1,$s/Word/Excal/g</code></pre><hr><h2 id="删除及复制以及粘贴"><a href="#删除及复制以及粘贴" class="headerlink" title="删除及复制以及粘贴:"></a>删除及复制以及粘贴:</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h3><pre><code>向后删除一个字符:x;向前删除一个字符:X;连续向后删除n个字符:nx;删除光标所在一行:dd;删除光标下n行:ndd;删除光标到本行最后一个字符:d$;重复删除:c;例:向下删除10行:10cj;向上删除10行:10ck;</code></pre><h3 id="复制"><a href="#复制" class="headerlink" title="复制:"></a>复制:</h3><pre><code>复制光标一行:yy;复制光标下n行:nyy;</code></pre><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴:"></a>粘贴:</h3><pre><code>粘贴复制的数据到光标下一行:p;粘贴复制的数据到光标上一行:P;</code></pre><hr><h2 id="合并"><a href="#合并" class="headerlink" title="合并:"></a>合并:</h2><pre><code>合并行:n1,n2 j例:合并2-5行:2,5 j</code></pre><hr><h2 id="编辑按钮"><a href="#编辑按钮" class="headerlink" title="编辑按钮:"></a>编辑按钮:</h2><table><thead><tr><th align="center">编辑按钮①</th><th align="center">编辑按钮②</th></tr></thead><tbody><tr><td align="center">i:从当前光标插入</td><td align="center">I:从当前行的第一个字符开始插入(行首插入)</td></tr><tr><td align="center">a:从光标所在的下一个字符插入</td><td align="center">A:从当前所在行的最后一个字符开始插入(行尾插入)</td></tr><tr><td align="center">o:从光标所在的下一行插入新的一行</td><td align="center">O:从光标所在的上一行插入新的一行</td></tr></tbody></table><hr><h2 id="存储和离开"><a href="#存储和离开" class="headerlink" title="存储和离开:"></a>存储和离开:</h2><pre><code>写入不退出:&#39;:w&#39;;离开:&#39;:q&#39;;存储离开:&#39;:wq&#39;;强制:&#39;!&#39;</code></pre><hr><h2 id="行号"><a href="#行号" class="headerlink" title="行号:"></a>行号:</h2><pre><code>开启行号:set nu取消行号:set nonu</code></pre><hr><h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠:"></a>代码折叠:</h2><pre><code>打开折叠:zR;关闭折叠:zM;删除折叠:zE;例:折叠5-10行代码:zf10G</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习笔记</title>
      <link href="/2019/12/23/markdown-xue-xi-bi-ji/"/>
      <url>/2019/12/23/markdown-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h1><pre><code>轻量级标记语言.理解:比如Html需写120个字符,但用MarkDown只需要写30字符.用途:主要用于写项目文档.</code></pre><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题:"></a>标题:</h2><table><thead><tr><th align="center">一级标题</th><th align="center">二级标题</th></tr></thead><tbody><tr><td align="center">======</td><td align="center">——</td></tr></tbody></table><hr><h3 id="多种写法"><a href="#多种写法" class="headerlink" title="多种写法:"></a>多种写法:</h3><table><thead><tr><th align="center">一级标题</th><th align="center">二级标题</th><th align="center">三级标题</th><th align="center">四级标题</th><th align="center">五级标题</th><th align="center">六级标题</th></tr></thead><tbody><tr><td align="center">#</td><td align="center">##</td><td align="center">###</td><td align="center">####</td><td align="center">#####</td><td align="center">######</td></tr></tbody></table><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体:"></a>字体:</h2><h3 id="三种字体写法"><a href="#三种字体写法" class="headerlink" title="三种字体写法:"></a>三种字体写法:</h3><table><thead><tr><th align="center">斜体</th><th align="center">粗体</th><th align="center">粗斜体</th></tr></thead><tbody><tr><td align="center">* 斜体 *</td><td align="center">** 粗体 **</td><td align="center"><strong>*  粗斜体  *</strong></td></tr><tr><td align="center">_ 斜体 _</td><td align="center">__ 粗体 __</td><td align="center"><strong>_ 粗斜体 _</strong></td></tr></tbody></table><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线:"></a>分割线:</h2><pre><code>可用三个以上的星号(*)或者减号(-)或者下划线(_)来建立分割线;</code></pre><table><thead><tr><th align="center">第一种</th><th align="center">第二种</th><th align="center">第三种</th></tr></thead><tbody><tr><td align="center">***</td><td align="center">—</td><td align="center">___</td></tr></tbody></table><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线:"></a>删除线:</h2><pre><code>文字两端加两个波浪线;~~MarkDown~~</code></pre><h3 id="例"><a href="#例" class="headerlink" title="例:"></a>例:</h3><p><del>MarkDown</del></p><hr><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线:"></a>下划线:</h2><pre><code>不可直接表示,需借用Html标签&lt;u&gt;&lt;/u&gt;表示.&lt;u&gt;MarkDown&lt;/u&gt;</code></pre><h3 id="例-1"><a href="#例-1" class="headerlink" title="例:"></a>例:</h3><p><u>MarkDown</u></p><hr><h2 id="角标"><a href="#角标" class="headerlink" title="角标:"></a>角标:</h2><pre><code>小茗Ub生活网[^小茗Ub生活网]</code></pre><h3 id="例-2"><a href="#例-2" class="headerlink" title="例:"></a>例:</h3><p>小茗Ub生活网[^小茗Ub生活网]</p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表:"></a>列表:</h2><table><thead><tr><th align="center">有序列表</th><th align="center">无序列表</th></tr></thead><tbody><tr><td align="center">1.第一项</td><td align="center">* 第一项</td></tr><tr><td align="center">2.第二项</td><td align="center">* 第二项</td></tr><tr><td align="center">3.第三项</td><td align="center">* 第三项</td></tr></tbody></table><h3 id="例-3"><a href="#例-3" class="headerlink" title="例:"></a>例:</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表:"></a>有序列表:</h4><p>1.第一项</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表:"></a>无序列表:</h4><ul><li>第一项</li></ul><hr><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套:"></a>列表嵌套:</h2><table><thead><tr><th align="center">有序列表</th></tr></thead><tbody><tr><td align="center">1.第一项(此项后加四个空格,即为列表嵌套) * 嵌套第一项</td></tr><tr><td align="center">2.第二项(此项后加四个空格,即为列表嵌套) - 嵌套第二项</td></tr><tr><td align="center">3.第三项(此项后加四个空格,即为列表嵌套) - 嵌套第三项</td></tr></tbody></table><h3 id="例-4"><a href="#例-4" class="headerlink" title="例:"></a>例:</h3><p>1.第一项</p><ul><li>嵌套第一项</li></ul><hr><h2 id="区块"><a href="#区块" class="headerlink" title="区块:"></a>区块:</h2><pre><code>&gt; 最外层&gt; &gt; 第一层&gt; &gt; &gt; 第二层&gt; &gt; &gt; &gt; 第三层</code></pre><h3 id="例-5"><a href="#例-5" class="headerlink" title="例:"></a>例:</h3><blockquote><p>最外层</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote></blockquote><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><pre><code>需用&#39;&#39;括起来.</code></pre><hr><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块:"></a>代码区块:</h2><pre><code>需用上下三个```符号把代码包起来</code></pre><h3 id="例-6"><a href="#例-6" class="headerlink" title="例:"></a>例:</h3><pre><code>&lt;u&gt;&lt;/u&gt;</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接:"></a>链接:</h2><table><thead><tr><th align="center">链接①</th><th align="center">链接②</th></tr></thead><tbody><tr><td align="center"><a href="链接">名称</a></td><td align="center">&lt;链接&gt;</td></tr></tbody></table><p>链接③:</p><pre><code>[名称][随便给一个值][值]:链接</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片:"></a>图片:</h2><pre><code>![给一个值](图片地址)</code></pre><h3 id="例-7"><a href="#例-7" class="headerlink" title="例:"></a>例:</h3><p><img src="https://www.xmubshw.com/down/logo.png" alt="xm"></p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格:"></a>表格:</h2><pre><code>|左|中|右||:-|:-:|-:||左|中|右|</code></pre><h3 id="例-因为浏览器兼容问题-可能表格样式会显示不全-但书写格式是标准的"><a href="#例-因为浏览器兼容问题-可能表格样式会显示不全-但书写格式是标准的" class="headerlink" title="例(因为浏览器兼容问题,可能表格样式会显示不全,但书写格式是标准的):"></a>例(因为浏览器兼容问题,可能表格样式会显示不全,但书写格式是标准的):</h3><table><thead><tr><th align="left">左</th><th align="center">中</th><th align="right">右</th></tr></thead><tbody><tr><td align="left">左</td><td align="center">中</td><td align="right">右</td></tr></tbody></table><hr><h2 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标:"></a>上标和下标:</h2><pre><code>可用Html标签&lt;sup&gt;文字&lt;/sup&gt;为上标&lt;sub&gt;文字&lt;/sub&gt;为下标</code></pre><h3 id="例-8"><a href="#例-8" class="headerlink" title="例:"></a>例:</h3><table><thead><tr><th align="center">上标</th><th align="center">下标</th></tr></thead><tbody><tr><td align="center">益达<sup>Tm</sup></td><td align="center">Ho<sub>2</sub></td></tr></tbody></table><hr><h2 id="正常显示普通符号"><a href="#正常显示普通符号" class="headerlink" title="正常显示普通符号:"></a>正常显示普通符号:</h2><pre><code>使用反斜杠(\)转义特殊字符\* 正常显示星号(*) \*</code></pre><h3 id="例-9"><a href="#例-9" class="headerlink" title="例:"></a>例:</h3><p>* 正常显示星号 *</p><hr><h2 id="自动生成目录"><a href="#自动生成目录" class="headerlink" title="自动生成目录:"></a>自动生成目录:</h2><pre><code>使用[toc],放在MarkDown文档最上方,会自动生成目录</code></pre><hr><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号:"></a>常用符号:</h2><table><thead><tr><th align="center">常用符号①</th><th align="center">常用符号②</th><th align="center">常用符号③</th></tr></thead><tbody><tr><td align="center">(反斜杠)</td><td align="center">`(反引号)</td><td align="center">*(星号)</td></tr><tr><td align="center">_(下划线)</td><td align="center">{}(花括号)</td><td align="center">[] (方括号)</td></tr><tr><td align="center">()(小括号)</td><td align="center">#(#号)</td><td align="center">+(加号)</td></tr><tr><td align="center">-(减号)</td><td align="center">.(英文句号)</td><td align="center">!(感叹号)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
