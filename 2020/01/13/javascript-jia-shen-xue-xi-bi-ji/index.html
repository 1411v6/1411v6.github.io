<!DOCTYPE HTML>
<html lang="zh">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaScript加深学习笔记, 小茗Blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaScript加深学习笔记 | 小茗Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="小茗Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小茗Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小茗Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/1411v6" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/1411v6" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://www.xmubshw.com/clients/hexo/JavaScriptJiaShenimg.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaScript加深学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/tags/ES6/">
                                <span class="chip bg-color">ES6</span>
                            </a>
                        
                            <a href="/tags/WebAPI/">
                                <span class="chip bg-color">WebAPI</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaScript/" class="post-category">
                                JavaScript
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2020-01-13
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2020-07-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    33.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    158 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JavaScript加深学习笔记"><a href="#JavaScript加深学习笔记" class="headerlink" title="JavaScript加深学习笔记"></a>JavaScript加深学习笔记</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="1-其他数据类型转换为Boolean（-）"><a href="#1-其他数据类型转换为Boolean（-）" class="headerlink" title="1.其他数据类型转换为Boolean（!!）"></a>1.其他数据类型转换为Boolean（!!）</h3><pre><code>    在谷歌打印台(!!)号 输入(!![{name:&#39;小明&#39;},{name:&#39;小李&#39;}])打印true
    (!!)号控制台 数据类型转换的时候：将其他数据类型转换为Boolean的时候的隐式转换的方式</code></pre><hr>
<h3 id="2-javascript-三部分组成"><a href="#2-javascript-三部分组成" class="headerlink" title="2.javascript 三部分组成"></a>2.javascript 三部分组成</h3><pre><code>     三部分组成：行内式，内嵌式和外链式</code></pre><hr>
<h3 id="3-javaScript-变量类型"><a href="#3-javaScript-变量类型" class="headerlink" title="3..javaScript 变量类型"></a>3..javaScript 变量类型</h3><pre><code>    var obj = null;
    console.log(typeof obj); // 打印的Object对象</code></pre><hr>
<h3 id="4-undefined-未定义"><a href="#4-undefined-未定义" class="headerlink" title="4.undefined 未定义"></a>4.undefined 未定义</h3><pre><code>     undefined未定义,声明一个变量,没有赋值</code></pre><hr>
<h3 id="5-小数相加（隐藏bug）"><a href="#5-小数相加（隐藏bug）" class="headerlink" title="5.小数相加（隐藏bug）"></a>5.小数相加（隐藏bug）</h3><pre><code>    var result = 0.1 + 0.2
    console.log(result); // 0.3000000000004
    // number:我们的js语言是不区分小数和整数，不管是小数还是整数都是number
    var num1 = 88;
    var num2 = 88.88;
    console.log(typeof num1);
    console.log(typeof num2);</code></pre><hr>
<h3 id="6-JS的基本数据类型"><a href="#6-JS的基本数据类型" class="headerlink" title="6.JS的基本数据类型"></a>6.JS的基本数据类型</h3><pre><code>    JS的基本数据类型：number、string、boolean、null、undefined--未定义</code></pre><hr>
<h3 id="7-注释"><a href="#7-注释" class="headerlink" title="7.注释"></a>7.注释</h3><pre><code>    /* alt+shift+a 多行注释*/
    // var x = 10;  记住这个就够了 ctrl + / 反斜杠 </code></pre><hr>
<h3 id="8-NaN问题"><a href="#8-NaN问题" class="headerlink" title="8.NaN问题"></a>8.NaN问题</h3><pre><code>    // 一个数字 和undefined相加是 NaN
    // 不要用NaN判断和NaN是否相等; NaN 与任何值都不相等的，包括他本身

    // 如果是数字返回false,不是数字返回true

    var age = 18;
    console.log(isNaN(age)); // false

    var bb;
    console.log(isNaN(bb)); // true</code></pre><hr>
<h3 id="9-字符串拼接"><a href="#9-字符串拼接" class="headerlink" title="9.字符串拼接"></a>9.字符串拼接</h3><pre><code>    // 减 乘 除（遇到数字的字符串）会隐式转换（除+号回拼接）
    var age1 = 10;
    var age2 = &quot;5&quot;;
    console.log(age1 - age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）
    console.log(age1 * age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）
    console.log(age1 / age2); // 隐士转换（浏览器学雷锋做好事不留名，自动转换了）

    var aa = 250;
    var bb = &quot;250&quot;;
    console.log(aa + bb); // 250250</code></pre><hr>
<h3 id="10-boolean-和-undefind-（true-1-，false-0）"><a href="#10-boolean-和-undefind-（true-1-，false-0）" class="headerlink" title="10. boolean 和 undefind （true 1 ，false 0）"></a>10. boolean 和 undefind （true 1 ，false 0）</h3><pre><code>    // boolean:布尔类型就两个结果，true和false（在做算术运算的时候true当1看，false当0看）
    var flag = true;
    console.log(flag);

    // null就是接收了一个null的赋值
    var nll = null;
    console.log(nll);

    // undefined 声明一个变量，没有赋值那么他就是undefined
    var age;
    console.log(age);</code></pre><hr>
<h3 id="11-数值转换-三个"><a href="#11-数值转换-三个" class="headerlink" title="11.数值转换 三个"></a>11.数值转换 三个</h3><pre><code>    1.parseInt()  2.parseFloat() 3.Number()

    // 如果想就转换整数就用parseInt()
    // 如果想转换小数就用 parseFloat()
    // Number()只转换数字，只要遇到字母就是NaN

    console.log(parseInt(&quot;10&quot;)); // 10
    console.log(parseInt(&quot;10abcdefg&quot;)); // 10
    console.log(parseInt(&quot;g10sdfsdfs&quot;)); // NaN
    console.log(parseInt(&quot;1sadfasdf&quot;)); // 1
    console.log(parseInt(&quot;10.98&quot;)); // 10
    console.log(parseInt(&quot;10.98asdfsdfs&quot;)); // 10

    // parseFloat()转换小数----浮点型
    console.log(&quot;=======&quot;);
    console.log(parseFloat(&quot;10&quot;)); // 10
    console.log(parseFloat(&quot;10abcdefg&quot;)); // 10
    console.log(parseFloat(&quot;g10sdfsdfs&quot;)); // NaN
    console.log(parseFloat(&quot;1sadfasdf&quot;)); // 1
    console.log(parseFloat(&quot;10.98&quot;)); // 10.98
    console.log(parseFloat(&quot;10.98asdfsdfs&quot;));// 10.98

    console.log(&quot;==========&quot;);
    console.log(Number(&quot;10&quot;)); // 10
    console.log(Number(&quot;10abcdefg&quot;)); // NaN
    console.log(Number(&quot;g10sdfsdfs&quot;)); // NaN
    console.log(Number(&quot;1sadfasdf&quot;)); // NaN
    console.log(Number(&quot;10.98&quot;)); // 10.98
    console.log(Number(&quot;10.98asdfsdfs&quot;)); // NaN</code></pre><hr>
<h3 id="12-转义字符"><a href="#12-转义字符" class="headerlink" title="12.转义字符"></a>12.转义字符</h3><pre><code>    // 要求掌握转义符    \\&#39;    \\&quot;    \t    \n    四个的用法
    console.log(&quot;哈哈\t嘎嘎&quot;); // 空格
    console.log(&quot;哈哈\n嘎嘎&quot;); // 换行
    console.log(&quot;哈哈\&quot;嘎嘎&quot;);
    console.log(&quot;哈哈\&#39;嘎嘎&quot;);</code></pre><hr>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-显示对话框-prompt-“您觉得我帅吗-y-n”"><a href="#1-显示对话框-prompt-“您觉得我帅吗-y-n”" class="headerlink" title="1.显示对话框( prompt(“您觉得我帅吗?y/n”))"></a>1.显示对话框( prompt(“您觉得我帅吗?y/n”))</h3><pre><code>    // 使用do-while循环:问用户:您觉得我帅吗?提示用户请输入y/n ,如果n就一直问,我帅不帅,如果用户输入的y,则结束,并提示用户,您真有眼光。
    do {
        var result = prompt(&quot;您觉得我帅吗?y/n&quot;);
    } while (result != &quot;y&quot;);
    console.log(&quot;您真有眼光&quot;);</code></pre><hr>
<h3 id="2-转换字符串类"><a href="#2-转换字符串类" class="headerlink" title="2.转换字符串类"></a>2.转换字符串类</h3><pre><code>    toString() 和String()方法 

    null和undefined 是不能用toString()---null和undefined是没有意义的，所以是不能转换的。</code></pre><hr>
<h3 id="3-重点5个类型boolean默认为false-考点-其他的都是true（隐式转换"><a href="#3-重点5个类型boolean默认为false-考点-其他的都是true（隐式转换" class="headerlink" title="3.重点5个类型boolean默认为false(考点) 其他的都是true（隐式转换 )"></a>3.重点5个类型boolean默认为false(考点) 其他的都是true（隐式转换 )</h3><pre><code>    console.log(Boolean(0));  // false
    console.log(Boolean(null)); // false
    console.log(Boolean(undefined)); // false
    console.log(Boolean(&quot;&quot;)); // false
    console.log(Boolean(NaN)); // false
    console.log(Boolean(Boolean(-1))); // true</code></pre><hr>
<h2 id="第三天（循环）"><a href="#第三天（循环）" class="headerlink" title="第三天（循环）"></a>第三天（循环）</h2><h3 id="1-面试坑-false默认为0"><a href="#1-面试坑-false默认为0" class="headerlink" title="1.(面试坑)false默认为0"></a>1.(面试坑)false默认为0</h3><pre><code>    var num = 0;
    if(num){ // num = false; false默认数值为false
        console.log(num); // 这个num不会输出
    }</code></pre><hr>
<h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><pre><code>    1.先执行后判断
    do{
        counter += 1;
    }while(counter &lt;= 100)

    2.先判断后执行
    var i = 0;
    while(i &lt;= 9){
        console.log(&#39;----&#39;)
        i++;  //这是终止条件
    }</code></pre><hr>
<h3 id="3-输出到页面"><a href="#3-输出到页面" class="headerlink" title="3.输出到页面"></a>3.输出到页面</h3><pre><code>    consle.log(&quot;---&quot;);
    document.write(&quot;输出&quot;)； //不会换行</code></pre><hr>
<h3 id="4-continue的使用"><a href="#4-continue的使用" class="headerlink" title="4.continue的使用"></a>4.continue的使用</h3><pre><code>    var i = 0;
    while (i &lt; 5) {
        console.log(i);
        // continue; // 加个continue直接就死循环了，小心面试坑!
        i++;
    }

    求100-200之间所有的奇数的和（用continue）
    var sum = 0;
    var i = 1;
    while (i &lt;= 10) {
        // 判断
        if (i % 2 == 0) {
            i++;
            continue;
        }
        sum += i;
        i++;
    }
    console.log(&quot;100-200之间所有的奇数的和:&quot; + sum);</code></pre><hr>
<h3 id="5-数组求和"><a href="#5-数组求和" class="headerlink" title="5.数组求和"></a>5.数组求和</h3><pre><code>    var arr1 = [10, 20, 30, 40, 50];
    var sum = 0;
    for (var i = 0; i &lt; arr1.length; i++) {
        sum += arr1[i];
    }
    console.log(&quot;组中所有元素的和：&quot; + sum);</code></pre><hr>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="1-九九乘法表"><a href="#1-九九乘法表" class="headerlink" title="1.九九乘法表"></a>1.九九乘法表</h3><pre><code>    document.write(&quot;&lt;table border = &#39;1&#39; cellpadding= &#39;0&#39; cellspacing=&#39;0&#39;&gt;&quot;);
    for (var i = 1; i &lt;= 9; i++) {
        document.write(&quot;&lt;tr&gt;&quot;);
        for (var j = 1; j &lt;= i; j++) {
            document.write(&quot;&lt;td&gt;&quot;);
            document.write(j + &quot;*&quot; + i + &quot;=&quot; + i * j);
            document.write(&quot;&lt;/td&gt;&quot;);
        }
        document.write(&quot;&lt;/tr&gt;&quot;);
    }
    document.write(&quot;&lt;/table&gt;&quot;);</code></pre><hr>
<h3 id="2-数组倒装"><a href="#2-数组倒装" class="headerlink" title="2.数组倒装"></a>2.数组倒装</h3><pre><code>    var arr = [10,1,2,3,9,1];
    for(var i = 0; i &lt; arr.length / 2; i++){  //交换一半5的话是2
        var temp = arr[i];
        arr[i] = arr[arr.length - 1 - i];
        arr[arr.length - 1 - i] = temp;
    }</code></pre><hr>
<h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h3><pre><code>    var arr=[10,1,3];
    //比较的轮数
    for(var i = 0;i &lt;arr.length - 1; i++){
        //比较的次数
        for(var j = 0; j&lt;arr.length - 1 - i; j++){
           if(arr[j] &gt; arr[j + 1]){
               var tem =arr[j];
               arr[j] = arr[j + 1]
               arr[j + 1] = tem;
           }
       }
    }
    console.log(arr);</code></pre><hr>
<h3 id="4-定义函数"><a href="#4-定义函数" class="headerlink" title="4.定义函数"></a>4.定义函数</h3><pre><code>    function 函数名(形参1, 形参2, 形参...){
        //函数体 return 值;
    }</code></pre><hr>
<h3 id="5-函数的形参和实参个数不等"><a href="#5-函数的形参和实参个数不等" class="headerlink" title="5.函数的形参和实参个数不等"></a>5.函数的形参和实参个数不等</h3><pre><code>    //第一种情况：如果实参的个数大于形参的个数，那么多余的实参会被丢弃。
    //第二种情况：如果实参的个数小于形参的个数，那么结果是NaN，因为是数字 + undefined = NaNnotanumber</code></pre><hr>
<h3 id="6-对话输入框并转换"><a href="#6-对话输入框并转换" class="headerlink" title="6.对话输入框并转换"></a>6.对话输入框并转换</h3><pre><code>    function he (x, y){
        var sum = x + y;
        console.log(sum);
    }
    var num1 = parseInt(prompt(&quot;输入第一个数字&quot;));
    var num2 = parseInt(prompt(&quot;输入第二个数字&quot;));
    he(num1, num2);</code></pre><hr>
<h3 id="7-调用方法接受"><a href="#7-调用方法接受" class="headerlink" title="7.调用方法接受"></a>7.调用方法接受</h3><pre><code>    var bb = config(x,y);</code></pre><hr>
<h3 id="8-什么会NAN"><a href="#8-什么会NAN" class="headerlink" title="8.什么会NAN"></a>8.什么会NAN</h3><pre><code>    数字 + undefined //结果是NaN</code></pre><hr>
<h3 id="9-什么情况下undefind"><a href="#9-什么情况下undefind" class="headerlink" title="9.什么情况下undefind"></a>9.什么情况下undefind</h3><pre><code>    1、如果函数中没有使用 return语句 ，那么函数有默认的返回值：undefined
    2、如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined
    3、如果函数使用 return语句，那么跟在return后面的值，就成了函数的返回值,里面的所有其他代码都不会再执行
    4、函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。</code></pre><hr>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-Math内置对象-计算面积"><a href="#1-Math内置对象-计算面积" class="headerlink" title="1.Math内置对象(计算面积)"></a>1.Math内置对象(计算面积)</h3><pre><code>    Math.PI * r * r</code></pre><hr>
<h3 id="2-数组倒置函数"><a href="#2-数组倒置函数" class="headerlink" title="2.数组倒置函数"></a>2.数组倒置函数</h3><pre><code>    function reverseArr(arr){
        for(var i = 0; i &lt; arr.length / 2; i++){
            var temp = arr[i];
            arr[i] = arr[arr.length - 1 - i];
            arr[arr.length - 1 - i] = temp;
        }
        return arr;
    };
    var arr = [3,42,6,8,3];
    var result = reverseArr(arr);
    console.log(result);</code></pre><hr>
<h3 id="3-阶乘"><a href="#3-阶乘" class="headerlink" title="3.阶乘"></a>3.阶乘</h3><pre><code>    function jiecheng(num){
        var value = 1;
        for(var i = 1; i &lt;= num; i++){
            value * = i
        }
        return value;
    }
    var value2 = jiecheng(5);
    console.log(value2);</code></pre><hr>
<h3 id="4-布局的优先级"><a href="#4-布局的优先级" class="headerlink" title="4.布局的优先级"></a>4.布局的优先级</h3><pre><code>    首先考虑标准流，其次考虑浮动，最后考虑定位</code></pre><hr>
<h3 id="5-斐波那契数列-重点"><a href="#5-斐波那契数列-重点" class="headerlink" title="5.斐波那契数列(重点)"></a>5.斐波那契数列(重点)</h3><pre><code>    (兔子的规律为数列，1，1，2，3，5，8，13，21,34,55,89,144) 
    // 找规律----这个是属于算法---需要时间需理解
    var num1 = 1;//第一个月
    var num2 = 1;//第二个月
    var sum = num1 + num2;//第三个月

    // 模拟第四个月
    var num1 = num2//第二个月
    var num2 = sum;//第三个月
    var sum = num1 + num2;//第四个月

    // 继续模拟伪代码，就是我们推论的规律
    var num1 = num2;
    var num2 = sum;
    var sum = num1 + num2;

    var num1 = 1;
    var num2 = 1;
    var sum = 0; //总和
    for (var i = 3; i &lt;= 12; i++) {
        sum = num1 + num2;
        num1 = num2;
        num2 = sum;
    }
    console.log(&quot;12个月的斐波那契数列的和是:&quot; + sum);</code></pre><hr>
<h3 id="6-函数-arguments-伪数组"><a href="#6-函数-arguments-伪数组" class="headerlink" title="6.函数 arguments 伪数组"></a>6.函数 arguments 伪数组</h3><pre><code>    // 直接使用 i&lt; arguments.length;

    function getSum() {
        var sum = 0 ;
        for(var i = 0; i &lt; arguments.length; i++){
            sum += arguments[i];
        }
        return sum;
    }
    var result = getSum(23, 4, 56, 4); 
    console.log(result);     </code></pre><hr>
<h3 id="7-常规函数定义-（函数创建）"><a href="#7-常规函数定义-（函数创建）" class="headerlink" title="7.常规函数定义 （函数创建）"></a>7.常规函数定义 （函数创建）</h3><pre><code>    function fun() {
        console.log(&quot;我就是命名函数，我是有函数名的。&quot;);
    }
    fun();</code></pre><hr>
<h3 id="8-匿名函数-记得加-分号-一般初始化（函数创建）"><a href="#8-匿名函数-记得加-分号-一般初始化（函数创建）" class="headerlink" title="8.匿名函数 (记得加 ;分号),一般初始化（函数创建）"></a>8.匿名函数 (记得加 ;分号),一般初始化（函数创建）</h3><pre><code>    1.带有变量名的
    var age = 18; 
    var f1 = function(){}; // 匿名要加分号

    f1(); // 函数执行加括号

    window.onload = function(){} // 匿名函数最大

    2.不带变量名的
    ()(); // 这样定义，第一个括号填function(){}
    (function(){
        console.log(&quot;99iiii&quot;);
    })();</code></pre><hr>
<h3 id="9-this关键字的讲解"><a href="#9-this关键字的讲解" class="headerlink" title="9.this关键字的讲解"></a>9.this关键字的讲解</h3><pre><code>    console.log(this); // 在全局作用域下this指向window
    // 普通函数this指向window
    function fun() {
        console.log(this); // 普通函数里面的this也指向window
    }
    fun();</code></pre><hr>
<h3 id="10-作用域理解"><a href="#10-作用域理解" class="headerlink" title="10.作用域理解"></a>10.作用域理解</h3><pre><code>    作用域:全局作用域和局部作用域(或者说私有作用域)
    全局作用域：(工作经验：网页一打开就形成了一个全局作用域)---函数外面都称为全局作用域;
    全局变量:在全局作用域下面定义的变量叫做全局变量（函数外面定义的变量都叫做全局变量）
    局部作用域:函数已执行就形成了局部作用域（也有人叫做私有作用域）
    局部变量:在局部作用域下面定义的变量叫做局部变量（函数里面定义的变量叫做局部变量，形参也是局部变量）</code></pre><hr>
<h3 id="11-计算今天在这年中第多少天"><a href="#11-计算今天在这年中第多少天" class="headerlink" title="11.计算今天在这年中第多少天"></a>11.计算今天在这年中第多少天</h3><pre><code>    // 定义一个函数,输入某年某月某日,判断这一天是这一年的第几天？
    // 假设我们输入的是2020-1-31
    function getDays(year, month, day) { //year--年,month--月,--day天
        // 先定义一个变量来存储天数
        var days = day;
        // 如果用户输入的时候一月份, 没有必要向后算天数，直接返回天数就ok了
        if (month == 1) {
            return days; // 函数里面遇到return后面代码不再执行了
        }
        // 如果代码继续往下执行了,说明用户输入的一定不是1月份,除了1月份的任意的其他月份2,3,4,5...12月
        // 假设用户输入的是2020年4月1; 1月的天数+2月的天数+3月的天数+1天
        // 1,3,5,7,8,10,12----31天; 2月是--28天; 4,6,9,11---30天
        // 定义一个数组来存储每个月的天数
        var months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        // 如果用户输入的不是一月份,就要开始遍历循环数组把数组里面天数加起来
        for (var i = 0; i &lt; month - 1; i++) {
            days += months[i];
        }
        // 判断，记得上面要调用我们的公用文件publick.js
        if (isLeapYear(year) &amp;&amp; month &gt; 2) {
            days++; // 判断公式：是闰年并且大于2月才会加这一天 
        }
        return days; // 返回值
    }
    var result = getDays(2020, 3, 2);
    console.log(result);
    // 判断闰年公式是公用文件只写一次下次就直接调用了
    function isLeapYear(year) {
        return year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;
    }</code></pre><hr>
<h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-预解析"><a href="#1-预解析" class="headerlink" title="1.预解析"></a>1.预解析</h3><p>可以参考 : <a href="https://blog.csdn.net/qq_43615908/article/details/86495976" target="_blank" rel="noopener">JavaScript中域解析的拆解</a></p>
<pre><code>域解析是指在正式执行js代码之前，进行的一些解析工作。他会在全局中寻找关键字var声明的变量和关键字function声明的函数。    </code></pre><pre><code>    1. 提升变量声明：把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。
    2. 提升函数声明：把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</code></pre><hr>
<h3 id="2-js中同名的变量名"><a href="#2-js中同名的变量名" class="headerlink" title="2.js中同名的变量名"></a>2.js中同名的变量名</h3><pre><code>    1.变量和变量同名，解析之后只存在一个当前变量的声明
    console.log(a); // undefined
    var a = 123;
    console.log(a); // 123
    var a = 456;
    console.log(a); // 456

    2.函数名和变量名一样了，只提升函数，不提升变量var a,函数和变量同名，函数声明提升，忽略变量的声明
    console.log(a); // 函数体
    var a = 123;
    console.log(a); // 123
    function a() {} // 小心函数名和变量名一样了，只提升函数，不提升变量var a

    3. 局部方法定义var 与不带var
    // console.log(a); // undefined
    // var a = 12;

    // function fn() {
    // console.log(a); // undefined
    // var a = 13;

    // }
    // fn();
    // console.log(a); // 12

    //小心//
    console.log(a); // undefined
    var a = 12;

    function fn() {
        console.log(a); // 12
        a = 13;
    }
    fn();
    console.log(a) // 13

    4.比较难理解
    // 小心掉坑
    var foo = 1;
    function bar() {
    // 不管条件成立还是不成立都要进行变量提升。  var foo; !undefind== true
    console.log(undefind == false + &#39;---&#39;);
       if (!foo) {
           var foo = 10;
       }
       console.log(foo);
    }
    bar(); // 10

    5.比较难理解
    var a;
    console.log(a); // undefined
    a = 12;
    function fn(a) {
       console.log(a); // 12
       a = 13; // 虽然没有var但是是形参，形参也是局部变量，修改私有的,不会修改全局的
    }
    fn(a);
    console.log(a); // 12</code></pre><hr>
<h3 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链:"></a>3.作用域链:</h3><pre><code>    // 作用域链:我们的作用域链是从里往外一层一层查找，这种查找机制叫做作用域链。
    var num = 10;
        function fun1() {
            //var num = 20;
            function fun2() {
                //var num = 30;
                function fun3() {
                    //var num = 50;
                    console.log(num);
                }
                fun3();
            }
            fun2();
        }
    fun1();
    结果：10</code></pre><hr>
<h3 id="4-清空控制台"><a href="#4-清空控制台" class="headerlink" title="4.清空控制台"></a>4.清空控制台</h3><pre><code>    console.clear()</code></pre><hr>
<h3 id="5-全局变量的理解（注意重点）"><a href="#5-全局变量的理解（注意重点）" class="headerlink" title="5.全局变量的理解（注意重点）"></a>5.全局变量的理解（注意重点）</h3><pre><code>    // 在函数里面只要var了，就不会修改全局的, 函数里面变量没有var及没有形参 ,可以修改全局,这么理解
    console.log(a, b, c); // undefind
    var a = 10,
        b = 20,
        c = 30;
    function f(a){
        var b;
        console.log(a, b, c);  // 10 undefind 30
        b = a = c = 100;
        console.log(a, b, c) // 100，100 ，100
    }    
    f(10, 20); // 多余的实参丢掉
    console.log(a, b, c); // 10 20 100</code></pre><hr>
<h3 id="6-拆解var-a-b-constant的声明与赋值"><a href="#6-拆解var-a-b-constant的声明与赋值" class="headerlink" title="6.拆解var a = b = constant的声明与赋值"></a>6.拆解var a = b = constant的声明与赋值</h3><pre><code>    // var a = b = contant可拆解为:
    var a;
    b = contant;
    a = b;</code></pre><hr>
<h3 id="7-函数名一样只会执行最后一个函数"><a href="#7-函数名一样只会执行最后一个函数" class="headerlink" title="7.函数名一样只会执行最后一个函数"></a>7.函数名一样只会执行最后一个函数</h3><pre><code>    function f() {
        console.log(&quot;1&quot;);
    }

    function f() {
        console.log(&quot;2&quot;);
    }
    function f() {
        console.log(&quot;3&quot;);
    }
    f(); // 打印3</code></pre><hr>
<h3 id="8-查方法字典内置对象-Math"><a href="#8-查方法字典内置对象-Math" class="headerlink" title="8.查方法字典内置对象(Math)"></a>8.查方法字典内置对象(Math)</h3><p>1.参考资料 : <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN字典查询</a></p>
<pre><code>    1.最大值 Math.max(10,20,30,90,20)打印为90；
    var arr = [2, 3, 47, 6];
    2.数组最大值 
    Math.max(...arr);
    3.取整数
    parseInt();
    案例：    
    //Math.ceil() 向上取整
    console.log(Math.ceil(12.3));
    console.log(Math.ceil(12.9));
    console.log(Math.ceil(12.09));
    console.log(Math.ceil(12.03));
    console.log(Math.ceil(12.92));

    // Math.floor() 向下取整
    console.log(Math.floor(12.3));
    console.log(Math.floor(12.9));
    console.log(Math.floor(12.09));
    console.log(Math.floor(12.03));
    console.log(Math.floor(12.92));    

    // Math.max()/Math.min() 取最大和最小值
    console.log(Math.max(10,1,9,100,200,45,78));
    console.log(Math.min(10,1,9,100,200,45,78));

    // Math.abs() 取绝对值
    console.log(Math.abs(&#39;-1&#39;)); // 1
    console.log(Math.abs(-2)); // 2
    console.log(Math.abs(null)); // 0
    console.log(Math.abs(&#39;string&#39;)); // NaN
    console.log(Math.abs()); // NaN

    //Math.power()、Math.sqrt() 求指数次幂/求平方根
    console.log(Math.pow(2,4));
    console.log(Math.sqrt(16));

    //Math.round() 四舍五入 
    console.log(Math.round(20.49));
    console.log(Math.round(20.5));

    //随机数 获取一个0到1的随机浮点小数,包含0不包含1
    parseInt(Math.random() * 100) + 1) 转换整数 //取1-100之间的数据

    //生成随机数    Math.random() 生成随机数 获取一个0到1的随机的浮点数（小数）包含0不包含1 [0,1)
    console.log(Math.random());
    console.log(parseInt(Math.random() * 5 ) + 1);
    console.log(parseInt(Math.random() * 100 ) + 1); // 1-100随机数</code></pre><hr>
<h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><h3 id="1-运用递归计算1234数字的和"><a href="#1-运用递归计算1234数字的和" class="headerlink" title="1.运用递归计算1234数字的和"></a>1.运用递归计算1234数字的和</h3><pre><code>    function getSum(x){
        if(x&lt;10){
            return x;
        }
        return x % 10 + dg(parseInt(x / 10)); // 4444 / 10 = 444 444 % 10 = 4   
    } 
    var result = getSum(4444)
    console.log(result);</code></pre><hr>
<h3 id="2-计算一个月份斐波那契（小兔子）"><a href="#2-计算一个月份斐波那契（小兔子）" class="headerlink" title="2.计算一个月份斐波那契（小兔子）"></a>2.计算一个月份斐波那契（小兔子）</h3><pre><code>    function getFib(x){
        if(x == 1 || x == 2){
            return 1;
        }
        return getFib(x - 1) + getFib(x - 2);
    }
    var result = getFib(3);
    console.log(result);</code></pre><hr>
<h3 id="3-利用伪数组计算一组数中的最大值"><a href="#3-利用伪数组计算一组数中的最大值" class="headerlink" title="3.利用伪数组计算一组数中的最大值"></a>3.利用伪数组计算一组数中的最大值</h3><pre><code>    function getMax(){
        var max = arguments[0];
        for(var i = 0; i &lt; arguments.length; i++){
                if(max &lt; arguments[i]){
                    max = arguments[i];
                }
        }
        return max;
    }
    // var list = [12, 34, 56, 78];
    // var result =getMax(list); // 直接返回数组
    var result =getMax(12, 67, 45, 36, 78); // 返回最大值
    console.log(result); </code></pre><hr>
<h3 id="4-随机产生一个十六进制的颜色值（随机色）"><a href="#4-随机产生一个十六进制的颜色值（随机色）" class="headerlink" title="4.随机产生一个十六进制的颜色值（随机色）"></a>4.随机产生一个十六进制的颜色值（随机色）</h3><pre><code>    function getColor() {
        var str = &quot;#&quot;;// 颜色以#开头
        // 一个十六进制的值的数组
        var arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];
        for(var i = 0; i &lt; 6; i++){
        // 产生的每个随机数都是一个索引,根据索引找到数组中对应的值,拼接到一起
        var num = parseInt(Math.random() * 16);
        str += arr[num];
       }
       return str; // 返回的是一个字符串类型的，因为有字母和数字
    }
    var result = getColor();
    console.log(result);
```

***

### 5.dom元素操作默认加载
```
    window.onload = function(){
        document.getElementById(&quot;dv&quot;).style.backgroundColor = getColor();
    }
```

***

### 6.日期函数    
```
    // 注意星期天 返回的是0;

    // getFullYear() 返回4位的年份  如 2019
    console.log(date.getFullYear());

    // getMonth() 返回月份，从0开始 记得+1
    console.log(date.getMonth());

    // getDate() 返回当前月的第几天（日）
    console.log(date.getDate());

    // getDay() 返回星期几 0 表示周日，6 表示周六
    console.log(date.getDay());

    // getHours() 根据本地时间，返回一个指定的日期对象的小时数 0-23
    console.log(date.getHours());

    // getMinutes() 根据本地时间，返回一个指定的日期对象的分钟数。0-59
    console.log(date.getMinutes());

    // getSeconds() 根据本地时间，返回一个指定的日期对象的秒数。0-59
    console.log(date.getSeconds());    
```

***

### 7.拼接今天的时间周几
```
    function getToday(today){
        var y = today.getFullYear();
        var m = today.getMonth() + 1;
        var d = today.getDay();

        var hour =today.getHours();
        var minute = today.getMinutes();
        var second = today.getSeconds();

        var week = today.getDay(); // 返回的数字是4  
        switch(week){
            case 1:
                week = &quot;星期一&quot;;
                break;
            case 2:
                week = &quot;星期二&quot;;
                break;
            case 3:
                week = &quot;星期三&quot;;
                break;
            case 4:
                week =&quot;星期四&quot;;
                break;
            case 5:
                week =&quot;星期五&quot;;
                break;
            case 6:
                week =&quot;星期六&quot;;
                break;
            case 0:
                week =&quot;星期天&quot;;
                break;
        }
    return y +&#39;年&#39;+ m +&#39;月&#39; + d +&#39;日&#39;+ hour +&#39;时&#39;+ minute + &#39;分&#39; + second + &#39;秒&#39;;
    }
    var today = getToday(new Date());
    console.log(today);
```

***

### 8.String类型
```
    // 1..length 字符串的长度
    var str = &quot;hello word&quot;;
    console.log(str.length); // 10

    // 2.charAt(索引)，返回值是指定索引位置的字符串，超出索引，结果是空字符串

    var str = &quot;hello word&quot;;
    var result = str.charAt(1);
    var result = str.charAt(5); // 这个超出了输出空字符串
    console.log(result);

    // 3.fromCharCode(数字值，可以是多个参数)，返回的是ASCII码对应的值

    var str = String.fromCharCode(83, 79, 83);
    console.log(str); //sos

    // 4.concat(字符串，字符串)，返回拼接新的字符串

    var str1 = &quot;我们&quot;；
    var str1 = str1.concat(&quot;,她们！&quot;)；
    console.log(str1);

    // 5.indexOf(要找的字符串,从某个位置开始) 返回的是这个字符串的索引值，没找到返回-1，第二个参数可以不要

    var str = &quot;我们今天真开心&quot;;
    var index = str.indexOf(&quot;真&quot;, 5); // 从下表5开始，找‘真’

    var index = str.indexOf(&quot;真开&quot;); // 返回第一个&#39;真&#39;索引值
    console.log(index); // 返回-1，因为从第5个开始后面就没有真，如果不写后面的5结果就是4正好是真的索引位置

    // 6.lastIndexOf(要找的字符串) 从后往前找，但是索引仍然是从左向右的方式，找不到则返回-1;

    var str = &quot;hello word&quot;;
    var index = str.lastIndexOf(&quot;o&quot;);
    console.log(index); // 返回结果7，从后面往前找到后面的那个o

    // 7.replace(&quot;原来的字符串&quot;,&quot;新的字符串&quot;);用来替换字符串的

    var str = &quot;小明真的好帅哦，真的好勇敢哦&quot;;
    // 寻找带‘帅’；没有返回-1
    if (str.indexOf(&quot;帅&quot;) != -1) {
        str = str.replace(&quot;帅&quot;, &quot;丑&quot;);
    } else {
        console.log(&quot;不存在&quot;);
    }
    console.log(str);

    // 8.slice(开始的索引，结束的索引) 从索引5的位置开始提取(截取)，到索引10的前一个结束，没有10，返回这个提取后的字符串

    var str = &quot;如果有一天我邪恶了,请记住,我曾纯洁过&quot;;
    str = str.slice(5, 10);
    console.log(str);

    // 9.split(&quot;以什么字符串拆分&quot;,拆分后留下的字符个数);后面参数    可以省略，直接以什么字符串拆分，他是把字符串以指定的字符    拆分成数组

    var str = &quot;乔峰|慕容|凤姐|梅超风|小苏|大蛇丸&quot;;
    var arr = str.split(&quot;|&quot;);
    console.log(arr); // [&quot;乔峰&quot;, &quot;慕容&quot;, &quot;凤姐&quot;, &quot;梅超风&quot;, &quot;小苏&quot;, &quot;大蛇丸&quot;]

    // 10.substr(开始的位置，个数) 返回的是截取后的新的字符串,个数也可以省略，就是从什么位置开始截取到最后
    .substring(开始的索引， 结束的索引)， 返回截取后的字符串， 不包含结束的索引字符串

    var str = &quot;哈哈,小明真的是好帅哦&quot;;
    str = str.substr(5, 5);
    console.log(str); // 真的是好帅
    //11.substring(开始的索引，结束的索引)，返回截取后的字符串，不包含结束的索引字符串

    var str = &quot;哈哈,小明真的是好帅哦&quot;;
    str = str.substring(5, 9);
    console.log(str); // 真的是好

    // 12.转换大小写
    .toLowerCase();
    // 转小写, 两个方法都是转小写。
    .toLocaleLowerCase() // 转小写字母

    var str = &quot;HELLO&quot;;
    str = str.toLocaleLowerCase();
    str = str.toLowerCase();
    console.log(str);

    .toLocaleUpperCase() // 转大写
        .toUpperCase() // 转大写
    var str = &quot;hello&quot;;
    str = str.toLocaleUpperCase();
    str = str.toUpperCase();
    console.log(str);

    // 13.trim() 删除两端空格,中间的空格是删除不了的

    var str3 = &quot;  这是一个神奇的一天  哦我们学了很多很多内置对象  &quot;;
    str3 = str3.trim();
    console.log(str3);

    // 14.案例2：找到字符串中所有的o的出现的位置
    var str = &quot;hello wod odd ott fbo nhyo&quot;;
    var index = 0;
    var key = &quot;o&quot;;
    while ((index = str.indexOf(key, index)) != -1) { // 如果是-1了，就表示找完了
        console.log(index); // != -1表示找到了，找到立马给我弹出他所在的索引位置
        //index += 1; // 这一定要会的
        index += key.length; // 这个是扩展的（等价于index += 1）
    }

    // 15.查找指定的字符
    // 案例1.截取字符串&quot;我爱中华人民共和国&quot;，中的&quot;中华&quot;
    var str = &quot;我爱中华人民共和国&quot;;
    var index = str.indexOf(&quot;中华&quot;);
    // console.log(index);
    str = str.substr(index, 2);
    console.log(str);

    // 16.String其他额外方法：

    str.search(string): // 查找
        str.substring(star, end): // 获取子字符串
        str.charAt(i): // 获取某个字符
        str.split(“;”): // 分割字符串， 获得字符
        str.match(re): // 以数组的形式返回匹配的字符串
        str.replace(string, ‘abc’): // 替换字符串
```

***

## 第八天    

### 1.数组的创建方式
```
    1.第一种
    var array = [6];  // 长度为1，下标0为6
    console.log(array);
    或:
    var arr = [1, 2, 3, 4, 5];
    console.log(arr);

    2.第二种
    var array = new Array[6]; // 长度为6的数组
    console.log(array);
    或:
    var arr = new Array(10, 20, 30, 40);
    console.log(arr);
```

***

### 2.判断对象是不是数组instanceof关键字和isArray()
```
    var array = new Array[6];
    console.log(array);

    1.第一种
    console.log(array instanceof Array);

    2.第二种
    console.log(Array.isArray(arr));
```

***

### 3.轮播图会用到的，数组操作（数组4种方法）
```
    1.push()  2.unshift()  3.pop()   4.shift()

    // 1.push(值1,值2...);把值往数组后面添加、返回值是追加数据之后的数组长度，参数的数据类型不限;
    var arr1 = [10, 20, 30, 40, 50];
    var result = arr1.push(100, 200);
    console.log(result, arr1); // 返回结果：[10, 20, 30, 40, 50, 100, 200]

    // 2.unshift(值1,值2...)往数组前面添加，返回的是改变后的数组的长度参数数据类型不限;
    var arr2 =[10, 20, 30, 40, 50];
    var result = arr2.unshift(100, 200);
    console.log(result,arr2); // 返回结果：[100, 200, 10, 20, 30, 40, 50]

    // 3.pop()删除数组最后一项，参数无 返回值是删除的那一项;
    var arr3 = [10, 20, 30, 40, 50];
    var result = arr3.pop();
    console.log(result, arr3); // 返回结果：50和[10, 20, 30, 40]

    // 4.shift()删除数组第一项，参数无 返回值是删除的那一项;
    var arr4 = [10, 20, 30, 40, 50];
    var result = arr4.shift();
    console.log(result, arr4); // 返回结果：10和[20, 30, 40, 50]
```

***

### 4.数组方法索引查找
```
    // .indexOf(元素值)查看某个元素在数组里面的索引，如果没有这个元素返回值是-1
    var arr2 = [10, 20, 30, 40, 50];
    var index = arr2.indexOf(30);
    console.log(index);

    // 返回值是该元素在数组中的索引值，如果没有返回-1
    indexOf（n，m）// 从索引m开始查看n在数组里面的索引值
    lastIndexOf（）// 从后往前看
```

***

### 5.数组中元素拼接
```
    // join(&quot;字符串&quot;)把数组按照指定的字符串拼接成一个字符串,如果没有参数就按默认的逗号拼接成字符串，如果有参数就按照指定的字符串拼接成字符串
    var arr2 = [&quot;小白&quot;, &quot;小黑&quot;, &quot;小红&quot;, &quot;小芳&quot;, &quot;小绿&quot;, &quot;小花&quot;];
    var str = arr2.join(&quot;|&quot;);
    console.log(str);
```

***

### 6.数组反转
```
    // reverse() 数组反转 参数无 返回值是反转后的数组，(改变原有数组)
    var arr3 = [10, 20, 30, 40, 50];
    var temp = arr3.reverse(); // 反转
    console.log(temp,arr3); // [50, 40, 30, 20, 10]两个结果一样
```

***

### 7.数组排序
```
    // 1.sort()数组排序 返回值是排好序的数组，改变原有数组。参数可传可不传，如果传参数，参数是回调函数。如果不传参数的时候只能排10以内的数字
    // 不传参数的sort（）排序----从小到大
    var ary = [1, 2, 3, 6, 5, 4];
    var temp = ary.sort();
    console.log(temp); // 结果：[1, 2, 3, 4, 5, 6]
    console.log(ary); // 结果：[1, 2, 3, 4, 5, 6]

    // 2.升序降序(数组排序)
    // sort（）带有参数的升序和降序（超过10的数需要匿名函数调用）

    // 2.1、从小到大排序 a-b
    var ary = [1, 2, 3, 6, 5, 4, 13, 12, 15, 16];
    var temp = ary.sort(function (a, b) {
        return a - b; // 把原数组升序排 从小到大
    });
    console.log(temp); // 结果：[1, 2, 3, 4, 5, 6, 12, 13, 15, 16]

    // 2.2、从大到小排列 b-a
    var temp = ary.sort(function (a, b) {
        return b - a;
    });
    console.log(temp); // 结果：[16, 15, 13, 12, 6, 5, 4, 3, 2, 1]
```

***

### 8.数组索引查找(都是将原数复制一份)
```
    // slice（n, m）从索引n开始获取到索引m（不包含m）返回值是获取到的元素组成的新数组
    var ary = [10,20,30,40,50,60,70,80,90,100];
    var temp = ary.slice(2, 6);
    console.log(temp); // 结果是[30, 40, 50, 60] 从索引2开始获取到索引6不包括索引6
    //注意：slice();和slice(0);都是把原数组复制一份
```

***

### 9.将数组替换删除元素（splice）放置顺序（删除数组）增删改查
```
    // 1.splice(n,m,x/y/z...) 把数组从索引n开始删除m个元素，用x，y...替换删除的m项。返回值是删除的m项组成的新数组
    var ary = [1, 2, 3, 4, 5, 6];
    var temp = ary.splice(1, 2, 7, 8, 9, 10);
    console.log(temp); // 返回结果是：[2, 3]这个是删除的项组成的新数组，就是删除了2，3
    console.log(ary); // 返回结果是：[1, 7, 8, 9, 10, 4, 5, 6]

    // 2.当m项是0的时候，它把x,y...替换项放到索引n的前面
    var ary = [1, 2, 3, 4, 5, 6];
    var temp = ary.splice(1, 0, 7, 8, 9, 10);
    console.log(temp); // [] 返回空数组，因为没有删除
    console.log(ary); // 结果：[1, 7, 8, 9, 10, 2, 3, 4, 5, 6]

    // 3.当不写x、y替换项的时候代表删除数组的元素
    var ary = [1, 2, 3, 4, 5];
    var temp = ary.splice(1, 2);
    console.log(temp); // 结果：[2, 3]
    console.log(ary); // 结果：[1, 4, 5]

    // 4.当splice（）里面什么都不写的时候，代表没有对数组做任何操作，返回一个空数组
    var ary = [1, 2, 3, 4, 5];
    var temp = ary.splice();
    console.log(temp); // 结果：[]
    console.log(ary); // 结果：[1, 2, 3, 4, 5]

    // 5.当splice(0)  里面是0 的时候，代表删除整个数组，返回的是原数组的数据，原数组变为空数组
    var ary = [1, 2, 3, 4, 5];
    var temp = ary.splice(0);
    console.log(temp); // 结果： [1, 2, 3, 4, 5]
    console.log(ary); // 结果：[]原数组变为空数组

    // 6.替换
    var str = &quot;hello&quot;;
    str = str.replace(&quot;he&quot;, &#39;HHH&#39;)
    console.log(str);
```

***

### 10一个对象&amp;&amp;true
```
    // 如果是一个对象&amp;&amp;true,那么结果是true
    var flag = new Boolean(false);
    var result = flag &amp;&amp; true;
    console.log(result); // 返回true

    // 如果是一个true&amp;&amp;对象,那么结果是对象
    var flag = new Boolean(false);
    var result = true &amp;&amp; flag;
    console.log(result); // 返回对象
```

***

# WebAPI阶段
## 第一天 document

### 1.WebApi
```
WebApi就是浏览器给我们提供一系列用来操作DOM和BOM的接口
```

***

### 2.打印输出命令
```
    1.console.log()；
    2.console.dir(); // 打印对象的方法和属性
```

***

### 3.js的书写位置？
```
    body结束前面
```

***

### 4.选择器
```
    1. 根据id获取元素
    document.getElementById(&quot;id名称&quot;)  // 返回不存在null

    2.根据类名获取元素
    document.getElementsByClassName(&quot;类名&quot;) // 返回不存在空数组

    3.根据标签名获取元素
    document.getElementsByTagName(&quot;div&quot;) // 返回伪数组 （浏览器兼容问题）
    例子：
    &lt;input type = &quot;text&quot; name = &quot;user&quot;&gt;
    var input = document.getElementsByTagName(&quot;user&quot;);
    console.log(input);


    4.根据标签名
    &lt;input type = &quot;checkbox&quot; name = &quot;check&quot;&gt;
    document.getElementsByName(&quot;check&quot;); // 数组集合（浏览器兼容问题）

    5.根据选择器获取（单元素）css选择器（返回伪数组）

    返回值：
        查找成功，返回 选择器规则的第一个元素
        查找失败，返回 null

    1.案例1:
    &lt;div class = &quot;box&quot;&gt;&lt;/div&gt;
    var box = document.querySelector(&#39;.box&#39;); // 返回第一个(&lt;div class = &quot;box&quot;&gt;&lt;/div&gt;)

    2.案例2：
    &lt;ul&gt;
        &lt;li&gt;&lt;a&gt;测试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

    var box = document.querySelector(&#39;ul li a&#39;)

    6.根据选择器获取（多个元素），如果没有找到返回空数组  css选择器
    返回值：
    查找成功，返回 选择器规则的全部元素，伪数组，有索引值，有长度，可以遍历
    查找失败，返回 空集合伪数组，length 为 0，集合中没有元素
    伪数组无法直接操作，需要通过索引取到元素才能操作。
    document.querySelectorAll(&#39;选择器&#39;)
```

***

### 5.注册事件
```
    &lt;input type=&quot;button&quot; name=&quot;name&quot; value=&quot;按钮&quot; class=&quot;anniu&quot;/&gt;

    &lt;script&gt;
    // 获取元素
    var query = document.querySelector(&#39;.anniu&#39;);
    console.log(query);

    // 获取Body
    var body = document.body;
    // 注册事件
    query.onclick = function () {
        body.style.backgroundColor = &#39;rgb(255,1,255)&#39;
    };
    &lt;/script&gt;

    练习1:点击按钮禁用和启用

    &lt;input type = &quot;button&quot; value = &quot;点击禁用文本框&quot; id = &quot;btn1&quot;&gt;
    &lt;input type = &quot;button&quot; value = &quot;点击启用文本框&quot; id = &quot;btn2&quot;&gt;
    &lt;input type = &quot;button&quot; value = &quot;禁用或者启用&quot; id = &quot;btn3&quot;&gt;
    &lt;input type = &quot;text&quot; name = &quot;&quot; id = &quot;text&quot;&gt;
    &lt;script&gt;
        var btn1 = document.getElementById(&#39;btn1&#39;);
        var btn2 = document.getElementById(&#39;btn2&#39;);
        var btn3 = document.getElementById(&#39;btn3&#39;);
        var text = document.getElementById(&#39;text&#39;);
        // 注册事件
        btn1.onclick = function () {
            text.disabled = true;
        }
        btn2.onclick = function () {
            text.disabled = false;
        }
        btn3.onclick = function () {
            text.disabled = !text.disabled;
        }
    &lt;/script&gt;

    练习2：密码的显示和隐藏
    请输入密码：&lt;input type = &quot;password&quot; id = &quot;text&quot; value = &quot;123456&quot;&gt;
              &lt;input type = &quot;button&quot; id = &quot;btn&quot; value = &quot;显示密码&quot;&gt;

    &lt;script&gt;
        var pad = document.getElementById(&#39;text&#39;);
        var btn = document.getElementById(&#39;btn&#39;);
        // 定义变量默认true
        var b1 = true;
        //注册
        btn.onclick = function(){
            // 默认是隐藏密码
            btn.value = b1 ? &#39;隐藏密码&#39; : &#39;显示密码&#39;;
            pad.type = b1 ? &#39;text&#39; : &#39;password&#39;;
            b1 = !b1;
        }
    &lt;/script&gt;
    第二种:
    if(btn.innerText == &#39;隐藏密码&#39;);

    练习3：点击按钮切换图片
    &lt;style&gt;
        #div{
            width: 600px;
            margin: 100px auto;
            /* border: 1px solid #000; */
        }
        img{
            width: 600px;
        }
    &lt;/style&gt;

    &lt;div id=&quot;div&quot;&gt;
        &lt;input type = &quot;button&quot; value = &quot;按钮1&quot; alt = &quot;./images/01.jpg&quot;/&gt;
        &lt;input type = &quot;button&quot; value = &quot;按钮2&quot; alt = &quot;./images/02.jpg&quot;/&gt;
        &lt;input type = &quot;button&quot; value = &quot;按钮3&quot; alt = &quot;./images/03.jpg&quot;/&gt;
        &lt;input type = &quot;button&quot; value = &quot;按钮4&quot; alt = &quot;./images/04.jpg&quot;/&gt;
        &lt;img src = &quot;./images/01.jpg&quot; alt = &quot;&quot; id = &quot;img&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var img = document.getElementById(&quot;img&quot;);
        var inputList = document.getElementsByTagName(&#39;input&#39;);

        for(var i = 0;i &lt; inputList.length; i++){
            inputList[i].onclick = function(){
                img.src = this.alt;
            }
        }
    &lt;/script&gt;
```

***

## 第二天

### 1.元素的属性
```
    type、name、checked、src、href、alt 这些事元素的属性
```

***

### 2.获取元素的class(注意点)
```
    console.log（input1.className）; 这样获取类名

    console.log（input1.value）; //获取值
```

***

### 3.js是指标准属性 三个比较特殊（单选赋值、checked、selected、 disabled）
```
    1.单选：
    &lt;input type = &quot;radio&quot; checked&gt;

    &lt;script&gt;
    var input = document.querySelector(&#39;input&#39;);
    input.checked = true;
    input.checked = false;
    &lt;/script&gt;

    2.多选：
    &lt;select name = &quot;&quot; id = &quot;&quot;&gt;
    &lt;option value = &quot;&quot;&gt;北京&lt;/option&gt;
    &lt;option value = &quot;&quot; selected class = &quot;gd&quot;&gt;广东&lt;/option&gt;
    &lt;/select&gt;

    &lt;script&gt;    
        var selt = document.querySelector(&#39;select .gd&#39;);
        console.log(selt.selected);
        selt.selected = false;
    &lt;/script&gt;

    3.不可更改灰色：
    &lt;!-- 如果表单元素设置了disable的属性，表示这个表单元素被禁用 --&gt;
    &lt;input type = &quot;text&quot; class = &quot;txt&quot; disabled&gt;   
    var txt = document.querySelector(&#39;.txt&#39;);
    console.log(txt.disabled);
    console.log(document.querySelector(&#39;.txt&#39;).disabled = false);
```

***

### 4.innerHTML和innerText两个属性（获取不到用value）
```
    innerHTML:可以获取到标签
    innerText:只能获取文本内容
```

***

### 5.路src的设置
```
    img.src = &#39;../img/02.jpg&#39;; //设置是相对路径

    获取到的是绝对路径
```

***

### 6.案例表格的多选
```
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;
            &lt;input type = &quot;checkbox&quot; name = &quot;&quot; id = &quot;checkAll&quot; /&gt;全选/全不选
        &lt;/th&gt;
        &lt;th&gt;菜名&lt;/th&gt;
        &lt;th&gt;商家&lt;/th&gt;
        &lt;th&gt;价格&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;
        &lt;/td&gt;
        &lt;td&gt;红烧肉&lt;/td&gt;
        &lt;td&gt;隆江猪脚饭&lt;/td&gt;
        &lt;td&gt;￥200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;
        &lt;/td&gt;
        &lt;td&gt;香酥排骨&lt;/td&gt;
        &lt;td&gt;隆江猪脚饭&lt;/td&gt;
        &lt;td&gt;￥998&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;input type = &quot;checkbox&quot; name = &quot;check&quot; /&gt;
        &lt;/td&gt;
        &lt;td&gt;北京烤鸭&lt;/td&gt;
        &lt;td&gt;隆江猪脚饭&lt;/td&gt;
        &lt;td&gt;￥88&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;script&gt;
    var checkAll = document.getElementById(&quot;checkAll&quot;);
    var checks = document.getElementsByName(&quot;check&quot;);
    // 全选状态
    checkAll.onclick = function () {
        var statu = this.checked;
        for (var i = 0; i &lt; checks.length; i++) {
            checks[i].checked = statu;
        }
    }
    // 下面的多选框的点击事件
    for (var i = 0; i &lt; checks.length; i++) {
        checks[i].onclick = function () {
            // 判断多个多选框是否同时成立(勾上)
            var flag = true;
            for (var j = 0; j &lt; checks.length; j++) {
                // 如果有某一个没有勾上，假设不成立
                // if(checks[j].checked == false){
                if (!checks[j].checked) {
                    flag = false;
                    break;
                }
            }
            // 判断假设是否仍然成立
            if (flag) {
                // 如果成立，让全选勾上
                checkAll.checked = true;
            } else {
                // 否则，让全选不勾
                checkAll.checked = false;
            }

            // 全选按钮
            checkAll.checked = flag;
        }
    }
&lt;/script&gt;
```

***

### 7.自定义属性
```
    命名规则：data-* * 自定义属性的名称
    获取自定义属性值：    元素对象.dataset.属性名
    设置属性值：元素对象.dataset.属性名 = 值

    案例1：方法中设置    
        &lt;input type = &quot;text&quot; name = &quot;input&quot; id = &quot;&quot;&gt;
        var input = document.querySelector(&#39;input&#39;);
        input.dataset.box = &#39;我是新来的&#39;;
        console.dir(input);

    案例2：
    &lt;input type = &quot;text&quot; name = &quot;input&quot; id = &quot;&quot; data-box = &quot;或这样定义&quot;&gt;    
    &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;images/01.jpg&quot;&gt;
```

***

### 8.自定义属性按钮图片切换
```
    &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;./images/01.jpg&quot;/&gt;
    &lt;input type = &quot;button&quot; value = &quot;美女2&quot; data-src = &quot;./images/02.jpg&quot;/&gt;
    &lt;input type = &quot;button&quot; value = &quot;美女3&quot; data-src = &quot;./images/03.jpg&quot;/&gt;
    &lt;input type = &quot;button&quot; value = &quot;美女4&quot; data-src = &quot;./images/04.jpg&quot;/&gt;
    &lt;input type = &quot;button&quot; value = &quot;美女5&quot; data-src = &quot;./images/05.jpg&quot;/&gt;
    &lt;img src = &quot;./images/01.jpg&quot; alt = &quot;&quot; id = &quot;img&quot;/&gt;

    &lt;script&gt;
    // 获取所有的按钮和图片对象
    var btns = document.querySelectorAll(&#39;input&#39;)
    // 获取图片对象
    let img = document.querySelector(&#39;#img&#39;)

    // 给每个按钮注册点击事件
    for (let i = 0; i &lt; btns.length; i++) {
        btns[i].onclick = function () {
            let src = this.getAttribute(&#39;data-src&#39;)
            // console.log(src);
            img.setAttribute(&#39;src&#39;, src)
        }
    }
    &lt;/script&gt;
```

***

### 9.ES6写法拼接字符串(模版字符串)ESC键下的波浪符
```
    console.log(~我叫${name}~);
```

***

### 10.ES6写法拼接字符串(模版字符串换行)ESC键下的点
```
    var str = `我是中国人`
    console.log(str);
```

***

### 11.伪数组转换为真数组
```
    Array.from(&quot;&quot;);
```

***

### 12.排他思想(tab切换选项)
```
    &lt;div class = &quot;wrapper&quot;&gt;
    &lt;ul class = &quot;tab&quot;&gt;
        &lt;li class = &quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;男士精品&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class = &quot;products&quot;&gt;
        &lt;div class = &quot;main selected&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guojidapai.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class = &quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guozhuangmingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class = &quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/qingjieyongpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/nanshijingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var lis = document.getElementsByClassName(&quot;tab-item&quot;);
    var mains = document.getElementsByClassName(&quot;main&quot;);
    for (var i = 0; i &lt; lis.length; i++) {
        lis[i].index = i;
        lis[i].onmouseover = mouseOverHandle;
    }

    function mouseOverHandle() {
        // 排它思想
        for (var j = 0; j &lt; lis.length; j++) {
            lis[j].className = &quot;tab-item&quot;;
        }
        this.className = &quot;tab-item active&quot;;

        for (var k = 0; k &lt; mains.length; k++) {
            mains[k].className = &quot;main&quot;;
        }
        mains[this.index].className = &quot;main selected&quot;;
    }
&lt;/script&gt;
```

***

### 13.（onmouseover）鼠标指针移动到指定的对象上时触发事件（鼠标指针事件tab切换选项）
```
    &lt;style type = &quot;text/css&quot;&gt;
    * {
        margin: 0;
        padding: 0;
    }

    ul {
        list-style: none;
    }

    .wrapper {
        width: 1000px;
        height: 475px;
        margin: 0 auto;
        margin-top: 100px;
    }

    .tab {
        border: 1px solid #ddd;
        border-bottom: 0;
        height: 36px;
        width: 320px;
    }

    .tab li {
        position: relative;
        float: left;
        width: 80px;
        height: 34px;
        line-height: 34px;
        text-align: center;
        cursor: pointer;
        border-top: 4px solid #fff;
    }

    .tab span {
        position: absolute;
        right: 0;
        top: 10px;
        background: #ddd;
        width: 1px;
        height: 14px;
        overflow: hidden;
    }

    .products {
        width: 1002px;
        border: 1px solid #ddd;
        height: 476px;
    }

    .products .main {
        float: left;
        display: none;
    }

    .products .main.selected {
        display: block;
    }

    .tab li.active {
        border-color: red;
        border-bottom: 0;
    }
&lt;/style&gt;

&lt;div class = &quot;wrapper&quot;&gt;
    &lt;ul class = &quot;tab&quot;&gt;
        &lt;li class = &quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt;
        &lt;li class = &quot;tab-item&quot;&gt;男士精品&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class = &quot;products&quot;&gt;
        &lt;div class = &quot;main selected&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guojidapai.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class = &quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/guozhuangmingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class = &quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/qingjieyongpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class = &quot;main&quot;&gt;
            &lt;a href = &quot;### &quot;&gt;&lt;img src = &quot;images/nanshijingpin.jpg&quot; alt = &quot;&quot; /&gt;&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var items = document.querySelectorAll(&#39;.tab-item&#39;);
    var mains = document.querySelectorAll(&#39;.main&#39;);

    // 鼠标的移入事件
    for (var i = 0; i &lt; items.length; i++) {
        items[i].index = i;
        items[i].onmouseover = function () {

            for (var j = 0; j &lt; items.length; j++) {
                items[j].classList.remove(&#39;active&#39;);
            }
            this.classList.add(&#39;active&#39;);

            // 排除
            for (var k = 0; k &lt; mains.length; k++) {
                mains[k].classList.remove(&#39;selected&#39;);
            }
            mains[this.index].classList.add(&#39;selected&#39;);
        }
    }
&lt;/script&gt;
```

***

### 14.开关灯效果（开关思想）
```
    &lt;img src=&quot;./images/off.gif&quot; alt=&quot;&quot;&gt;

    &lt;script&gt;
        let img = document.querySelector(&#39;img&#39;)
        let bl = true;
        img.onclick = function () {
            img.src = bl ? &#39;./images/on.gif&#39; : &#39;./images/off.gif&#39;;
            bl = !bl;
        }
    &lt;/script&gt;
```

***

### 15.元素的操作标签属性
```
    1.获取元素属性值： 元素对象.getAttribute(属性名)
    2.设置元素属性值： 元素对象.setAttributr(属性，属性值)

    案例：
    &lt;input type = &quot;button&quot; value = &quot;美女1&quot; data-src = &quot;images/01.jpg&quot;/&gt;

    &lt;script&gt;
    let img = document.querySelector(&#39;#img&#39;);
    let src = this.getAttribute(&#39;data-src&#39;);
    img.setAttribute(&#39;src&#39;, src);
    &lt;/script&gt;

    3.删除属性:   元素对象.removeAttribute()
    4.检测是否有： 元素对象.hasAttribute()  // 返回fase
```

***

### 16.Attribute   属性 的意思
| 功能 | 方法名 | 参数个数 | 是否有返回值 |
| :-: | :-: | :-: | :-: |
| 获取属性 | getAttribute() | 一个参数：属性名作为参数 | 有返回值 |
| 设置属性 | setAttribute() | 两个参数：属性名 和 属性值 | undefined |
| 移除属性 | removeAttribute() | 一个参数：属性名作为参数 | undefined |
| 是否有属性 | hasAttribute() | 一个参数：属性名作为参数 | 有返回值，布尔类型 |

***

## 第三天

### 1.对class类进行添加 /类删除(都是对classList中操作)
```
    &lt;script&gt;
    console.log(box.classList.value); // 获取元素所有类名

    // 1. 添加
    var box = document.querySelector(&#39;.box&#39;);

    box.add() //不能直接使用
    box.classList.add(&#39;five&#39;, &#39;six&#39;, &#39;seven&#39;); // 通过classList中的add方法添加

    // 2. 删除类名（ remove）
    var res = box.classList.remove(&#39;two&#39;, &#39;one&#39;); // 删除元素类名

    // 3. 包含类名（ contains） 检测类名
    box.classList.contains(&#39;one&#39;); // 如果包含返回true，只能传参一个

    // 4. 类名替换（ replace）
    box.classList.replace(&#39;原类名&#39;, &#39;新替换值&#39;)
    box.classList.replace(&#39;one&#39;, &#39;呼呼呼&#39;)

    // 5. 切换类名 toggle()
    var box = document.querySelector(&#39;.box&#39;);
    box.onclick = function () {
        box.classList.toggle();
    }
&lt;/script&gt;
```

***

### 2.创建元素
```
    &lt;script&gt;
    // 1. 标准元素
    var res = document.createElement(&#39;div&#39;);
    res.innerHTML = &#39;这是动态创建&#39;;
    console.log(res);

    // 注意： 页面生效要获取body
    var body = document.body;
    body.appendChild(res);

    // 自定义创建元素:
    var res = document.createElement(&#39;jj&#39;);
    res.innerHTML = &#39;这是动态创建&#39;;
    var body = document.body;
    body.appendChild(res);

    // 2.document.write() //不推荐使用会将原有的内容覆盖掉
    document.write(&#39; &lt;a href=&quot;www.baidu.com&quot;&gt;&lt;/a&gt;&#39;)

    // 3. innerHTML也不推荐使用，原来的内容会覆盖（ += 不会覆盖）
    var body = document.body;
    body.innerHTML = &#39;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39;;
&lt;/script&gt;
```

***

### 3.追加元素
```
    appenedChild();  将元素追加到原有的元素后面
```

***

### 4.删除元素的操作
```
&lt;!-- removeChild(参数) ;调用这个方法的元素一定是被删除的元素的父元素 返回被删除的元素（节点） --&gt;
&lt;ul&gt;
    &lt;li&gt;这是第1个li的内容&lt;/li&gt;
    &lt;li&gt;这是第2个li的内容&lt;/li&gt;
    &lt;li&gt;这是第3个li的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var ul = document.querySelector(&#39;ul&#39;);
    // 获取所有的li
    var lis = document.querySelectorAll(&#39;ul li&#39;);
    // 删除元素
    var res = ul.removeChild(lis[1]);
    console.log(res);
    console.log(lis[1] == res);
&lt;/script&gt;
```

***

### 5.替换节点操作    
```
&lt;!-- replaceChild((参数1,参数2); 调用的时候： 使用要被替换的元素的父元素来调用 返回： 被提换的旧的节点 --&gt;
&lt;ul&gt;
    &lt;li&gt;这是第1个li的内容&lt;/li&gt;
    &lt;li&gt;这是第2个li的内容&lt;/li&gt;
    &lt;li&gt;这是第3个li的内容&lt;/li&gt;
    &lt;li&gt;这是第4个li的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var ul = document.querySelector(&#39;ul&#39;);
    var lis = document.querySelectorAll(&#39;li&#39;);

    // 替换节点
    var newLi = document.createElement(&#39;li&#39;);
    newLi.innerHTML = &#39;我是新创建的&#39;;

    var res = ul.replaceChild(newLi, lis[4]);
    console.log(res);

    console.log(lis[4] == res);
&lt;/script&gt;

```

***

### 6.插入节点操作(在..之前插入)
```
&lt;!-- //在某一个节点前面插入一个节点操作
insertBefore(newElement，oldElement); 在调用这个方法的时候也是使用要插入的元素的父元素
参数1： 表示要被插入的元素
参数2：要被插入的哪个元素的前面 --&gt;

&lt;ul&gt;
    &lt;li&gt;这是第1个li的内容&lt;/li&gt;
    &lt;li&gt;这是第2个li的内容&lt;/li&gt;
    &lt;li&gt;这是第3个li的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var ul = document.querySelector(&#39;ul&#39;);
    var lis = document.querySelectorAll(&#39;li&#39;);

    var res = ul.insertBefore(lis[5], lis[0]);

    console.log(res);
&lt;/script&gt;
```

***

### 7.复制节点操作（克隆）
```
&lt;!-- 克隆节点操作：   复制一个节点
cloneNode(参数);      返回被克隆的节点
注意： 如果不传入参数，表示浅拷贝，只克隆当前的节点，节点中的内容不会被克隆
如果传入参数：true，表示深拷贝，就是将这个节点下面的所有的内容都克隆下来
返回： 被克隆的节点 --&gt;

&lt;ul&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;哈哈哈哈&lt;/a&gt;
        &lt;p&gt;嘻嘻嘻嘻嘻嘻&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;这是第5个li的内容&lt;/li&gt;
    &lt;li&gt;这是第6个li的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var lis = document.querySelectorAll(&#39;li&#39;);

    // 克隆节点操作
    var res = lis[0].cloneNode(true); // 这个元素被克隆的，但是元素中的内容没有被克隆

    document.querySelector(&#39;ul&#39;).appendChild(res);
&lt;/script&gt;
```

***

### 8.案例：克隆表情
```
&lt;!-- 1.cloneNode() 2.appendChild() --&gt;

&lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;emoji&quot;&gt;
        &lt;img src=&quot;img/01.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;img/02.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;img/03.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;img/04.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
    &lt;p&gt;
        &lt;strong&gt;请发言：&lt;/strong&gt;
        &lt;img src=&quot;img/12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; /&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
    var imgs = document.querySelectorAll(&#39;#emoji img&#39;);

    var p = document.querySelector(&#39;p&#39;);

    // for (var i = 0; i &lt; imgs.length; i++) {
    //     imgs[i].onclick = function () {
    //         let clone = this.cloneNode();
    //         p.appendChild(clone);
    //     }
    // }
    imgs.forEach(element =&gt; {
        element.onclick = function () {
            let newClone = element.cloneNode();
            p.appendChild(newClone);
        }
    });
&lt;/script&gt;
```

***

### 9.案例发布内容
```
&lt;textarea cols = &quot;30&quot; rows = &quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;
&lt;input type = &quot;button&quot; value = &quot;发布内容&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;听说多喝热水能治病哦&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    let txt = document.querySelector(&#39;textarea&#39;)
    let btn = document.querySelector(&#39;input&#39;)
    let ul = document.querySelector(&#39;ul&#39;)

    btn.onclick = function () {
        let content = txt.value;
        if (content == &#39;&#39;) {
            alert(&#39;内容不能为空，请输入内容&#39;)
            return;
        }
        let li = document.createElement(&#39;li&#39;)
        li.innerHTML = content;
        ul.appendChild(li);
        txt.value = &#39;&#39;;
    }
&lt;/script&gt;
```

***

### 10.获取DOM树 子元素/子节点(都是属性不是方法)
```
&lt;!-- 1.children 2.childNodes 3.nextElementSibling(下个节点) --&gt;
&lt;ul&gt;
    &lt;li&gt;获取子元&lt;/li&gt;
    &lt;li&gt;获取子元&lt;/li&gt;
    &lt;li&gt;获取子元&lt;/li&gt;
    &lt;li&gt;获取子元&lt;/li&gt;
    &lt;/ul&gt;

&lt;script&gt;
    var ul = document.querySelector(&#39;ul&#39;);
    // 获取子元素
    var lis = ul.children; // 获取父元素下面的子元素集合
    console.log(lis);


    var LisNode = ul.childNodes; // 获取子节点（(换行也是元素)
    console.log(LisNode);
&lt;/script&gt;
```

***

### 11.案例：仿微博发布往li添加内容
```
&lt;!-- 1.createElement() 2.innerHTML 3.appendChild() 4.value --&gt;

&lt;textarea cols = &quot;30&quot; rows = &quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;
&lt;input type = &quot;button&quot; value = &quot;发布内容&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;测试发送微博&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var text = document.querySelector(&#39;textarea&#39;)
    var btn = document.querySelector(&#39;input&#39;)
    var ul = document.querySelector(&#39;ul&#39;)

    btn.onclick = function () {
        var content = text.value;
        if (content == &#39;&#39;) {
            alert(&#39;内容不能为空，请输入内容&#39;)
            return;
        }
        var li = document.createElement(&#39;li&#39;);
        li.innerHTML = content;
        ul.appendChild(li);
        text.value = &#39;&#39;;
    }
&lt;/script&gt;
```

***

###    12.通过子元素获取父元素(都是属性不是方法)
```
&lt;script&gt;
    // 1. parentElement 2. parentNode

    var lis = document.querySelector(&#39;li&#39;);
    //获取父元素
    var pe = lis[0].parentElement;
    console.log(pe);

    var LisNode = lis[0].parentNode; //获取父节点
    console.log(LisNode);
&lt;/script&gt;
```

***

### 13.兄弟元素和兄弟节点(都是属性不是方法)(下一个节点)
```
&lt;script&gt;
    // 1.previousElementSibling 2.nextElementSibling // 兄弟元素
    // 1.previousSibling  2.nextSibling  // 兄弟节点

    var lis = document.querySelector(&#39;li&#39;);

    //上一个兄弟元素
    var pes = lis[0].previousElementSibling;
    console.log(pes);

    //下一个兄弟元素
    var next = lis[0].nextElementSibling;
    console.log(next);

    //上一个兄弟节点
    var pesjd = lis[0].previousSibling;
    console.log(pes);

    //下一个兄弟节点
    var nextjd = lis[0].nextSibling;
    console.log(nextjd);
&lt;/script&gt;
```

***

### 14.鼠标事件（前面加on）
| 英文 | 翻译 | 备注 |
| :-: | :-: | :-: |
| click | 鼠标单击 | 重点 |
| dblclick | 鼠标双击 | double 双倍 |
| mousemove | 鼠标移动 | |
| mousedown | 鼠标按下 | |
| mouseup | 鼠标弹起 | |
| mouseenter | 鼠标移入 | 重点，推荐使用 |
| mouseleave | 鼠标移出 | 重点，推荐使用 |
| mouseover | 鼠标移入 | div中有小div也触发 |
| mouseout | 鼠标移出 | div中有小div也触发|
</code></pre><p>案例：<br>    var divs = document.querySelectorAll(‘div’);<br>    // click: 鼠标单击<br>    divs[0].onclick = function() {<br>        console.log(‘鼠标单击’);<br>    }</p>
<pre><code>
***

### 15.鼠标x轴Y轴坐标
| 英文 | 翻译 | 备注 |
| :-: | :-: | :-: |
| clientX | 鼠标在可视区的 X 轴坐标 | |
| clientY | 鼠标在可视区的 Y 轴坐标 | |

***
</code></pre><p>// 案例：小天使跟随鼠标移动</p>
<style>
    img {
        position: fixed;
        /*固定定位只识别浏览器视口*/
    }
</style>

<!-- 1.document.onmousemove(鼠标移动事件) 2.clientX -坐标 3.position: fixed; -->

<img src = "img/tianshi.gif" alt = "" id = "img" />

<script>
    var img = document.querySelector('img');
    //移动鼠标事件
    document.onmousemove = function (e) {
        img.style.left = e.clientX + "px";
        img.style.top = e.clientY + "px";
    }
</script>
<pre><code>
***

### 16.键盘事件类型（用时加on）
| 英文 | 翻译 | 备注 |
| :-: | :-: | :-: |
| keydown | 键盘按下 |
| keyup | 键盘弹起 |
| keypress | 键盘按下并弹起 |

***
</code></pre><p>// 案例：<br>// keydown 键盘按下<br>var body = document.body;</p>
<p>body.onkeydown = function() {<br>     console.log(‘键盘已经按下’);<br>}</p>
<pre><code>
***

### 17.键盘事件属性（不用加on）
| 英文 | 翻译 | 备注 |
| :-: | :-: | :-: |
| keyCode | 获取键盘按键编码 | 重点 |
| ctrlKey | 是否同时按了组合键 Ctrl | 了解 |
| altKey | 是否同时按了组合键 Alt | 了解 |
| shiftKey | 是否同时按了组合键 Shift | 了解 |

***
</code></pre><p>// 1.alt/ctrl/shift 通过boolean类型的值判断是否被按下<br>// 2.回车键的键盘码 13</p>
<p>案例：</p>
<script>
document.body.onkeydown = function (e) {
    var content = txt.value;
    if (e.ctrlKey && e.keyCode == 13) {
        if (content == '') {
            alert('内容不能为空，请输入内容');
            return;
        }
        fun();
    }
}
</script> 

<pre><code>
***

### 18.表单事件类型（用时加on）
| 英文 | 翻译 | 备注 |
| :-: | :-: | :-: |
| focus | 获取焦点 | |
| blur | 失去焦点 | blur 模糊就是失去焦点 |
| change | 重点记 | |
| submit | 提交表单 | 后面 AJAX 阶段要用到 |

***
</code></pre><pre><code>注意事项：

- 获取焦点和失去焦点主要是表单的输入框元素添加较多
- 获取焦点 - 光标在输入内闪烁
- 失去焦点 - 光标不再输入框内闪烁 - 鼠标点击了别的地方

案例：
&lt;input type = &quot;text&quot; class = &quot;txt&quot;&gt;

//1.focus 获取焦点
&lt;script&gt;
document.querySelector(&#39;.txt&#39;).onfocus = function () {
    // console.log(&#39;获得了焦点&#39;);
    this.value = &#39;请输入用户名&#39;;
}
&lt;/script&gt;

// 2.blur 失去焦点
&lt;script&gt;
document.querySelector(&#39;.txt&#39;).onblur = function () {
    // console.log(&#39;你这样会失去我的&#39;);
    this.value = &#39;&#39;;
}
&lt;/script&gt;
//3.change:事件类型 改变 当表单中的内容发生改变的时候触发
&lt;script&gt;
document.querySelector(&#39;input&#39;).onchange = function () {
    console.log(&#39;我又变了&#39;);
}
&lt;/script&gt;</code></pre><pre><code>
***

### 19.事件处理函数内的事件对象</code></pre><pre><code>1.所有的事件处理函数内都可以调用事件对象，但是需要在事件处理函数的形参位置起个名字。
2.建议大家使用形参名字：event，ev，e 。

案例：
&lt;script&gt;
document.body.onkeydown = function (e) {
    var content = txt.value;
    if (e.ctrlKey &amp;&amp; e.keyCode == 13) {}
}
&lt;/script&gt;</code></pre><pre><code>
***

### 微博升级版</code></pre><p>未做 待补</p>
<pre><code>
***

## 第四天

### 1.鼠标事件对象页面坐标
| 属性名 | 描述 | 备注 |
| :-: | :-: | :-: |
| clientX/clientY | 浏览器坐标 | 可视区域 |
| pageX/pageY | 页面坐标 | |

***

### 2.案例放大镜</code></pre><style>
    * {
        margin: 0;
        padding: 0;
    }

    .main {
        width: 350px;
        height: 350px;
        margin: 100px;
        border: 1px solid #ccc;
        position: relative;
    }

    .big {
        width: 400px;
        height: 400px;
        position: absolute;
        top: 0;
        left: 360px;
        border: 1px solid #ccc;
        overflow: hidden;
        display: none;
    }

    .mask {
        width: 175px;
        height: 175px;
        background: rgba(255, 255, 0, 0.4);
        position: absolute;
        top: 0px;
        left: 0px;
        /* 把鼠标指针换成移动图标 */
        cursor: move;
        display: none;
    }

    .small {
        position: relative;
        height: 350px;
        width: 350px;
    }

    .active .mask,
    .active .big {
        display: block;
    }

    .big img {
        /* 相对定位：相对自己原本的位置定位，原来的位置保留的 */
        position: absolute;
    }
</style>

<!-- 整个大盒子 -->
<div class="main" id="main">
    <div class="small">
        <!--小图-->
        <img alt="" class="smallImg" src="images/iphoneX.jpg" width="350" />
        <!-- 遮挡层,黄色的小方块 -->
        <div class="mask"></div>
    </div>
    <!--大层-->
    <div class="big">
        <!--大图-->
        <img alt="" class="bigImg" src="images/iphoneX.jpg" width="800" />
    </div>
</div>
```

<hr>
<h3 id="3-事件对象中通用属性-target"><a href="#3-事件对象中通用属性-target" class="headerlink" title="3.事件对象中通用属性(target)"></a>3.事件对象中通用属性(target)</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">type</td>
<td align="center">事件类型</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">timeStamp</td>
<td align="center">时间标记</td>
<td align="center">事件触发时候的时间标记，单位是毫秒</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">目标元素</td>
<td align="center">重点，触发事件时候真正被(点击)那个元素</td>
</tr>
</tbody></table>
<hr>
<pre><code>    // 目标属性案例(target)：
    &lt;div class=&quot;box&quot;&gt;
    &lt;h1&gt;标题&lt;/h1&gt;
    &lt;p&gt;段落&lt;/p&gt;
    &lt;span&gt;文本内容&lt;/span&gt;

    &lt;ul&gt;
        &lt;li&gt;这是第1个里的内容&lt;/li&gt;
        &lt;li&gt;这是第2个里的内容&lt;/li&gt;
        &lt;li&gt;这是第3个里的内容&lt;/li&gt;
    &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script&gt;
    var box = document.querySelector(&#39;.box&#39;);

    // 注册点击事件   事件注册box身上
    box.onclick = function (e) {
        // console.log(e.target);
        // 有一个属性可以获取到标签的名字： nodeName
        console.log(e.target.nodeName);

        // 判断，点击的目标是否是li
        if (e.target.nodeName == &#39;LI&#39;) {
            console.log(&#39;当li被点击的时候才执行这个逻辑&#39;);
        }
    }
    &lt;/script&gt;</code></pre><hr>
<h3 id="4-选择有有类名one案例"><a href="#4-选择有有类名one案例" class="headerlink" title="4.选择有有类名one案例"></a>4.选择有有类名one案例</h3><pre><code>&lt;ul&gt;
    &lt;li&gt;这是第1个里的内容&lt;/li&gt;
    &lt;li class=&quot;one&quot;&gt;这是第2个里的内容&lt;/li&gt;
    &lt;li&gt;这是第3个里的内容&lt;/li&gt;
    &lt;li&gt;这是第4个里的内容&lt;/li&gt;
    &lt;li class=&quot;one&quot;&gt;这是第5个里的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var box = document.querySelector(&#39;.box&#39;);
    // 注册点击事件   事件注册box身上
    box.onclick = function (e) {
        //当点击的li标签中有class=&#39;one&#39;这个类名的元素才执行

        // console.log(e.target);
        // 判断元素是否有某一个类名，有类名才执行，没有不执行
        if (e.target.classList.contains(&#39;one&#39;)) {
            console.log(&#39;带有类名的执行&#39;)
        }
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="5-获取标签名属性（nodeName）"><a href="#5-获取标签名属性（nodeName）" class="headerlink" title="5.获取标签名属性（nodeName）"></a>5.获取标签名属性（nodeName）</h3><pre><code>    1.target  2.nodeName 3.e.target.classList.contains()

    1. 判断target中的元素
    &lt;script&gt;
    e.target; // 获取当前的元素 &lt;li&gt;jjklj&lt;/li&gt;    
    e.target.nodeName; // li 返回都是大写LI

    box.onclick = function (e) {
        if (e.target.nodeName == &#39;LI&#39;) {

        }
    }
    &lt;/script&gt;

    2.查找带有同类名的li

    e.target.classList.contains(&#39;one&#39;); // 有返回true</code></pre><hr>
<h3 id="6-事件委托（委托父元素）非常重要"><a href="#6-事件委托（委托父元素）非常重要" class="headerlink" title="6.事件委托（委托父元素）非常重要"></a>6.事件委托（委托父元素）非常重要</h3><pre><code>&lt;ul&gt;
    &lt;li&gt;这是第1个li中的内容&lt;/li&gt;
    &lt;li&gt;这是第2个li中的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    // 事件委托：事件注册没有在元素本身身上，而是在其父辈元素身上 
    // 注意： 父辈元素一定是在页面中存在的，而不是动态创建的

    var ul = document.querySelector(&#39;ul&#39;);

    // 对于动态生成的元素也是可以实现的
    var newLi = document.createElement(&#39;li&#39;);
    newLi.innerHTML = &#39;新创的li元素&#39;;
    ul.appendChild(newLi);


    // 事件委托
    ul.onclick = function () {
        console.log(&#39;li被点击了&#39;);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="7-微博升级（删除-编辑）"><a href="#7-微博升级（删除-编辑）" class="headerlink" title="7.微博升级（删除 编辑）"></a>7.微博升级（删除 编辑）</h3><pre><code>&lt;style&gt;
    * {
        margin: 0;
        padding: 0;
        list-style: none;
    }

    .weibo {
        width: 600px;
        border: 1px solid #ccc;

        margin: 100px auto;
        padding: 10px;

    }

    .weibo-text {
        width: 590px;
        height: 140px;
        padding: 5px;
        border: 1px solid #ccc;
        outline: none;
        resize: none;
    }

    .weibo-text:focus {
        border-color: #f60;
    }

    .weibo-btn {
        width: 80px;
        height: 30px;
        background-color: #f90;
        color: #fff;
        border: 0 none;
        margin-top: 5px;
        border-radius: 3px;
        cursor: pointer;
        outline: 0 none;
    }

    .weibo-list {
        padding-top: 10px;
    }

    .weibo-list li {
        font-size: 14px;
        line-height: 30px;
        border-bottom: 1px dotted #ccc;
        overflow: hidden;
    }

    .weibo-list li p {
        float: left;
    }

    .weibo-list li span {
        float: right;
        cursor: pointer;
    }

    .weibo-list li input {
        height: 24px;
        line-height: 24px;
        width: 300px;
        font-size: 14px;
        /* border: 0 none; */
    }
&lt;/style&gt;

&lt;div class=&quot;weibo&quot;&gt;
    &lt;textarea class=&quot;weibo-text&quot;&gt;&lt;/textarea&gt;
    &lt;button class=&quot;weibo-btn&quot;&gt;发布&lt;/button&gt;
    &lt;ul class=&quot;weibo-list&quot;&gt;
        &lt;li&gt;
            &lt;p&gt;快来收了这九款用上就停不下来的应用吧！！&lt;/p&gt;
            &lt;span&gt;删除&lt;/span&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p&gt;超级详细的云南大理自助游攻略&lt;/p&gt;
            &lt;span&gt;删除&lt;/span&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p&gt;外国最近很火的舞蹈，舒服简单自然，太棒了！&lt;/p&gt;
            &lt;span&gt;删除&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
    // 1. 查找元素
    var text = document.querySelector(&#39;.weibo-text&#39;);
    var btn = document.querySelector(&#39;.weibo-btn&#39;);
    var list = document.querySelector(&#39;.weibo-list&#39;);

    var realseNews = function () {
        //获取值并清空
        var str = text.value.trim();
        if (str === &#39;&#39;) {
            alert(&#39;不能为空!&#39;);
            return;
        } else if (str.length &gt; 120) {
            alert(&#39;输入内容请在120个字符内!&#39;);
            return;
        } else {
            //发布的内容
            var newLi = document.createElement(&#39;li&#39;);
            newLi.innerHTML = `
                &lt;p&gt;${str}&lt;/p&gt;
                &lt;span&gt;删除&lt;/span&gt;
            `;
            //插入第一列
            list.insertBefore(newLi, list.children[0]);
            text.value = &#39;&#39;;
        }
    }

    btn.onclick = realseNews;

    // 把点击事件委派给父级元素
    list.onclick = function (e) {
        //判断点击是否标签名(点击了删除)
        if (e.target.nodeName === &#39;SPAN&#39;) {
            //删除当前span父元素li
            list.removeChild(e.target.parentElement);
            //编辑
        } else if (e.target.nodeName === &#39;P&#39;) {
            // console.log(&#39;你点击了 p 标签&#39;);
            var newInput = document.createElement(&#39;input&#39;);
            newInput.type = &#39;text&#39;;
            newInput.value = e.target.innerText;
            console.log(e.target.parentElement);
            //替换
            e.target.parentElement.replaceChild(newInput, e.target);
            // newInput.focus();       // 主动获取一下获取焦点
        }
    }

    // 按下键盘事件 ctrl + Enter
    text.onkeyup = function (e) {
        // console.log(e);
        if (e.ctrlKey &amp;&amp; e.keyCode === 13) {
            realseNews();
        }
    }
    // 文本域进入页面的时候主动获取焦点，用户可以直接编辑，百度搜索框也是主动获取焦点
    // text.focus();
&lt;/script&gt;</code></pre><hr>
<h3 id="8-阻止默认行为（event-preventDefault-）"><a href="#8-阻止默认行为（event-preventDefault-）" class="headerlink" title="8.阻止默认行为（event.preventDefault();）"></a>8.阻止默认行为（event.preventDefault();）</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">preventDefault()</td>
<td align="center">阻止默认行为</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">stopPropagation()</td>
<td align="center">停止事件传播</td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<pre><code>案例：
1.a阻止默认打开
&lt;!-- &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; --&gt;

&lt;!-- &lt;input type=&quot;submit&quot;&gt; --&gt;
&lt;!-- 阻止元素默认行为： a的跳转     input ---submit --&gt;
&lt;script&gt;
    var a = document.querySelector(&#39;a&#39;);
    a.onclick = function (e) {
        //阻止默认行为的方法： preventDefault();
        e.preventDefault();
    }
&lt;/script&gt;

2.div域阻止复制
&lt;div&gt;这是我们创造的新的东西，不要随便复制。&lt;/div&gt;

&lt;script&gt;
    document.querySelector(&#39;div&#39;).oncopy = function (e) {
        e.preventDefault();
        alert(&#39;创造不易，请打发一点&#39;);
    }
&lt;/script&gt;

3.右边菜单禁止打开
&lt;script&gt;
    document.body.oncontextmenu = function (e) {
        e.preventDefault();
        alert(&#39;你是不是想复制，不让你复制，气死你&#39;);
    }
&lt;/script&gt;</code></pre><hr>
<h2 id="第五天-1"><a href="#第五天-1" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-事件注册（绑定）两种写法"><a href="#1-事件注册（绑定）两种写法" class="headerlink" title="1.事件注册（绑定）两种写法"></a>1.事件注册（绑定）两种写法</h3><pre><code>1.绑定写法1（事件的冒泡）（on会覆盖前面的函数）
事件冒泡就是事件委托原理
事件源.on事件类型 = 事件处理函数; //缺陷会当执行子div父辈div事件也会执行

阻止事件的冒泡：
&lt;script&gt;
    e.stopPropagation();
&lt;/script&gt;

2.通过 addEventListener() 方法添加事件(同名函数不会覆盖，不加on，，给谷歌)
&lt;script&gt;
    事件源.addEventListener(&#39;事件类型&#39;, 事件处理函数);

    window.addEventListener(&#39;add&#39;, function () {})
&lt;/script&gt;

3.attachEvent事件（低版本ie8支持 兼容，不加on)</code></pre><hr>
<h3 id="2-事件的解绑两种写法"><a href="#2-事件的解绑两种写法" class="headerlink" title="2.事件的解绑两种写法"></a>2.事件的解绑两种写法</h3><pre><code>1.第一种解绑on
&lt;script&gt;
    事件源.on事件类型 = null;
    document.querySelector(&#39;input&#39;).onclick = null; //推荐这种
    document.querySelector(&#39;input&#39;).onclick = &#39;&#39;;
&lt;/script&gt;

2.第二种解绑addEventListener()

&lt;script&gt;
    事件源.removeEventListener(&#39;事件类型&#39;, 事件处理函数的内存地址)
    案例： removeEventListener()
    var fn = function () {
        console.log(&#39;事件注册成功！&#39;);
    }
    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;, fn);

    //解绑事件
    document.querySelector(&#39;input&#39;).removeEventListener(&#39;click&#39;, fn);
&lt;/script&gt;

3.detachEvent解绑事件</code></pre><hr>
<h3 id="3-json"><a href="#3-json" class="headerlink" title="3.json"></a>3.json</h3><pre><code>&lt;script&gt;
    json是一种轻量级的数据交换格式

    3.1 输写json格式
    1. 都是键值对出现， 使用引号引起来；
    2. 每一组后面加逗号， 最后一组不加逗号
    3. 数字和boolean类型不使用引号

    3.2 把JSON字符串转对象
    var jsonObj = {
        name: &#39;小李&#39;,
        age: 30,
        gender: &#39;不详&#39;
    }

    var 转换后的结果 = JSON.parse(需要转换的数据);
&lt;/script&gt;</code></pre><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JSON.stringify()</td>
<td align="center">把对象转换成 JSON 字符串</td>
<td align="center">对象的方法不会转换到字符串中</td>
</tr>
<tr>
<td align="center">JSON.parse()</td>
<td align="center">把 JSON 字符串转换成对象</td>
<td align="center">转换失败会报错</td>
</tr>
</tbody></table>
<hr>
<pre><code>3.3把JSON对象转字符串 （网络传输都是字符串或二进制传输
&lt;script&gt;
    JSON.stringify(jsonObj);
&lt;/script&gt;</code></pre><hr>
<h3 id="4-页面显示处理（alert打印Obj）"><a href="#4-页面显示处理（alert打印Obj）" class="headerlink" title="4.页面显示处理（alert打印Obj）"></a>4.页面显示处理（alert打印Obj）</h3><pre><code>&lt;script&gt;
    alert(), document.write(), innerHTML 会自动把数据隐式转换成了字符串。
    对象如果直接通过隐式转换成字符串， 相当于直接调用了 `String()` 进行转换， 所以会看到 `[object Object]` 错误结果。

    如果要输出对象的数据格式，可以通过 `JSON.stringify()` 转换成字符串。

    案例：
    alert(JSON.stringify(jsonObj));
&lt;/script&gt;</code></pre><hr>
<h3 id="5-Bom中的顶级对象-window"><a href="#5-Bom中的顶级对象-window" class="headerlink" title="5.Bom中的顶级对象: window"></a>5.Bom中的顶级对象: window</h3><pre><code>&lt;script&gt;
    console.log(window);
    console.log(window.document == document); // true,document相当于属性
&lt;/script&gt;</code></pre><hr>
<h3 id="6-localStorage-本地存储-重点"><a href="#6-localStorage-本地存储-重点" class="headerlink" title="6.localStorage 本地存储(重点)"></a>6.localStorage 本地存储(重点)</h3><pre><code>本地存储的学习： 本地存储是浏览器的行为  帮助我们存储数据使用的</code></pre><hr>
<p>学习的方法：<br>| 方法名 | 描述 | 参数 | 备注 |<br>| :-: | :-: | :-: | :-: |<br>| <code>setItem()</code> | 设置一条数据 | 两个参数：键名称，值 | 直接保存到浏览器，参数二自动隐式转换成字符串 |<br>| <code>getItem()</code> | 获取一条数据 | 一个参数 | 有返回值，返回字符串数据 |<br>| <code>removeItem()</code> | 移除一条数据 | 一个参数 | |<br>| <code>clear()</code>  | 清空所有数据 | 无需传参 | 了解 |</p>
<pre><code>1.setItem() 这个方法就是用来存储数据的
//将对象数据存入本地存储中，会调用toString方法来处理，这样我们不能看到完整的数据

案例：
&lt;script&gt;
    var obj = {
        name: &#39;张三&#39;,
        age: 20,
        gender: &#39;女&#39;,
        address: &#39;天河区大地商务中心&#39;
    }

    var obj1 = {
        name: &#39;李四&#39;,
        age: 20,
        gender: &#39;女&#39;,
        address: &#39;天河区大地商务中心&#39;
    }

    localStorage.setItem(&#39;student&#39;, JSON.stringify(obj))

    console.log(typeof 对象名) //类型打印
&lt;/script&gt;

2.getItem() 获取本地存储的数据
&lt;script&gt;
    var res = localStorage.getItem(&#39;key键名&#39;)；

    console.log(typeof res); // 取出是string

    console.log(JSON.parse(res)); // 转换json对象
&lt;/script&gt;

3.删除本地数据（`removeItem(&#39;键&#39;)）
&lt;script&gt;
    // 注意： 每次只能删除一对
    localStorage.removeItem(&#39;res&#39;);
&lt;/script&gt;

4.一次删除所有数据
&lt;script&gt;
    localStorage.clear();
&lt;/script&gt;</code></pre><hr>
<h3 id="7-案例：发布新闻本地存储"><a href="#7-案例：发布新闻本地存储" class="headerlink" title="7.案例：发布新闻本地存储"></a>7.案例：发布新闻本地存储</h3><pre><code>&lt;style&gt;
        /* 上面有样式 */
&lt;/style&gt;

&lt;div class=&quot;weibo&quot;&gt;
    &lt;textarea class=&quot;weibo-text&quot;&gt;&lt;/textarea&gt;
    &lt;button class=&quot;weibo-btn&quot;&gt;发布&lt;/button&gt;
    &lt;ul class=&quot;weibo-list&quot;&gt;

    &lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
    // 获取元素
    var wbTxt = document.querySelector(&#39;.weibo-text&#39;);
    var wbBtn = document.querySelector(&#39;.weibo-btn&#39;);
    var wbList = document.querySelector(&#39;.weibo-list&#39;);

    ​​​​ // 每次刷新页面或者重新打开页面的时候都去本地存储中获取一次数据，将获取的数据渲染在页面上
    ​ // wbData:是我自己定义的，因为在存储数据的时候，我使用就是这个键名
    ​
    var getData = JSON.parse(localStorage.getItem(
        &#39;wbData&#39;));​​ // 我们在获取数据的时候，如果有数据： getData = [{content:&#39;哈哈哈&#39;,id:123456}]
    ​​// 如果没有数据的时候： getData：null
    ​​
    if (getData) {
        ​ // 定义个字符串用来拼接
        ​
        var strHtml = &#39;&#39;;​​ // 循环遍历
        ​
        for (var i = 0; i &lt; getData.length; i++) {
            ​
            strHtml += `
​                    &lt;li&gt;
​                        &lt;p&gt;${getData[i].content}&lt;/p&gt;
​                        &lt;span data-id=${getData[i].id}&gt;删除&lt;/span&gt;
​                    &lt;/li&gt;
​                    `​
        }​ // console.log(strHtml);
        ​
        wbList.innerHTML = strHtml;​
    }

    ​​​// 封装一个发布微博的函数
    ​
    function release() {
        ​// 获取文本域中的内容
        ​
        var str = wbTxt.value.trim();​​ // 生成一个唯一标识
        ​
        var time = +new Date(); // 会生成一个13位数的数字
        ​​// 做非空判断
        ​
        if (str == &#39;&#39;) {
            ​
            alert(&#39;请输入内容，不能为空&#39;);​
            return;​
        } else if (str.length &gt; 120) {
            ​
            alert(&#39;您的内容太多了，请重新输入&#39;);​
            return;​
        } else {
            ​
            var lis = wbList.children;​​
            var newLi = document.createElement(&#39;li&#39;);​
            newLi.innerHTML = `
​                            &lt;p&gt;${str}&lt;/p&gt;
​                            &lt;span data-id=${time}&gt;删除&lt;/span&gt;
​                    `; // 将创建的元素添加到列表中

            wbList.insertBefore(newLi, lis[0]);​​ // 将文本域中的内容清空
            ​
            wbTxt.value = &#39;&#39;;

            ​​ // 如果有数据，将数据返回给newArr，如果没有数据创建一个空的数组
            ​
            var newArr = JSON.parse(localStorage.getItem(&#39;wbData&#39;)) || [];

            newArr.unshift({
                ​
                content: str,
                ​id: time​
            })​ // if (newArr) {
            ​ //     newArr.unshift(
            ​ //         {
            ​ //             content: str,
            ​ //             id: time
            ​ //         }
            ​ //     )
            ​​ // } else {
            ​ //     newArr = [];
            ​ //     newArr.push(
            ​ //         {
            ​ //             content: str,
            ​ //             id: time
            ​ //         }
            ​ //     )
            ​​ // }
            ​​ // 将数据添加到本地存储中
            ​ localStorage.setItem(&#39;wbData&#39;, JSON.stringify(newArr));​​
        }​
    }​​ // 点击发布按钮发布微博信息
    ​
    wbBtn.onclick = release;​​ // 按ctrl+enter键也能实现发布
    ​
    wbTxt.onkeydown = function (e) {
        if (e.ctrlKey &amp;&amp; e.keyCode == 13) {
            release();​
        }​
    }

    // 删除操作
    wbList.onclick = function (e) {
        if (e.target.nodeName == &#39;SPAN&#39;) {
            wbList.removeChild(e.target.parentNode);
            var delData = JSON.parse(localStorage.getItem(&#39;wbData&#39;));
            for (var i = 0; i &lt; delData.length; i++) {
                if (delData[i].id == e.target.dataset.id) {
                    delData.splice(i, 1); //i:当前这条数据的索引，1：删除一条
                    localStorage.setItem(&#39;wbData&#39;, JSON.stringify(delData));
                    return;
                }
            }
        }
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="7-BOM-其他对象window"><a href="#7-BOM-其他对象window" class="headerlink" title="7.BOM 其他对象window"></a>7.BOM 其他对象window</h3><pre><code>    1.屏幕对象:window.screen

    2.浏览历史对象:window.history

    3.浏览器信息对象:window.navigator

    4.浏览器地址栏对象 URL:window.location</code></pre><hr>
<h3 id="8-location-URL对象"><a href="#8-location-URL对象" class="headerlink" title="8.location URL对象"></a>8.location URL对象</h3><table>
<thead>
<tr>
<th align="center">属性和方法</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">href</td>
<td align="center">设置或返回完整的 URL</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">search</td>
<td align="center">设置或返回从问号(?)开始的 URL(查询部分)</td>
<td align="center">要获取页面参数时使用 , 便捷</td>
</tr>
<tr>
<td align="center">reload()</td>
<td align="center">刷新页面，重新加载当前文档</td>
<td align="center">true 参数传入 , 绕过缓存 , 强制刷新</td>
</tr>
</tbody></table>
<hr>
<pre><code>案例：
&lt;script&gt;
    // location.search: 可以获取url地址？ 后面的内容
    location.reload();
&lt;/script&gt;</code></pre><hr>
<h3 id="9-短路运算"><a href="#9-短路运算" class="headerlink" title="9.短路运算"></a>9.短路运算</h3><pre><code>    与(&amp;&amp;):找假 第一个为假不往下走

    或(||):找真 有一个true就返回 (第一个不true 找第二个)</code></pre><hr>
<h2 id="第六天-1"><a href="#第六天-1" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-定时器"><a href="#1-定时器" class="headerlink" title="1.定时器"></a>1.定时器</h3><pre><code>&lt;script&gt;
    // -调用 `setInterval()`
    // 方法的时候， 定时器启动后有返回值， 返回定时器的编号， 一般用变量接收用于以后清除使用。
    //     -
    //     多次定时器启动后是一直运行， 如果不清除或者关掉页面， 定时器会一直保持运动。

    // const timerId = setInterval(定时执行的函数地址, 毫秒时间);

    // 案例：
    var num = 0;
    var res = setInterval(function () {
        num++;
        console.log(&#39;哈哈哈&#39; + num);
    }, 1000)

    console.log(res);
&lt;/script&gt;</code></pre><hr>
<h3 id="2-延时器"><a href="#2-延时器" class="headerlink" title="2.延时器"></a>2.延时器</h3><pre><code>&lt;script&gt;
    // 只执行一次,延迟执行
    setTimeout(function () {
        alert(&#39;hhha&#39;)
    }, 100);
&lt;/script&gt;
</code></pre><hr>
<h3 id="3-清除多次定时器"><a href="#3-清除多次定时器" class="headerlink" title="3.清除多次定时器"></a>3.清除多次定时器</h3><pre><code>&lt;script&gt;
    // clearInterval(定时器启动时候的编号);

    // clearInterval(参数) 参数：定时器的id
    document.querySelector(&#39;input&#39;).onclick = function () {
        clearInterval(timeId)
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="4-案例验证码定时器"><a href="#4-案例验证码定时器" class="headerlink" title="4.案例验证码定时器"></a>4.案例验证码定时器</h3><pre><code>&lt;style&gt;
    .form {
        width: 600px;
        margin: 100px auto;
    }

    .row {
        width: 100%;
        display: flex;
        border-top: 1px solid #0094ff;
        border-bottom: 1px solid #0094ff;
    }

    .cols-1 {
        flex: 1;
    }

    .cols-2 {
        flex: 2;
    }

    .cell {
        border-left: 1px solid #0094ff;
        padding: 10px 6px;
        line-height: 42px;
        text-align: center;
    }

    .cell:last-child {
        border-right: 1px solid #0094ff;
    }

    .text {
        width: 268px;
        height: 30px;
        padding: 4px;
    }

    .btn {
        height: 38px;
        width: 104px;
    }
&lt;/style&gt;

&lt;div class=&quot;form&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;cell cols-1&quot;&gt;请输入手机号码&lt;/div&gt;
        &lt;div class=&quot;cell cols-2&quot;&gt;
            &lt;input type=&quot;text&quot; class=&quot;text&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;cell cols-1&quot;&gt;
            &lt;input type=&quot;button&quot; class=&quot;btn&quot; data-time=&quot;3&quot; value=&quot;获取验证码&quot; id=&quot;getCode&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    // 获取元素
    var btn = document.querySelector(&#39;.btn&#39;);

    // 给按钮注册点击事件
    btn.onclick = function () {
        // 让按钮变成禁用状态
        btn.disabled = true;

        // 获取倒计时的初始时间，在按钮的data-time上面
        var time = btn.getAttribute(&#39;data-time&#39;);

        // console.log(time);
        // 将时间设置给按钮
        btn.value = time + &#39;秒&#39;;

        // 开启定时器，开始倒计时
        var timeId = setInterval(function () {
            // 让时间不断的减少
            time--;
            // 将这个时间设置给按钮的文本
            btn.value = time + &#39;秒&#39;;

            // 当时间减少到0的时候，定时器需要停止了。
            if (time == 0) {
                // 清除定时器
                clearInterval(timeId);

                // 让按钮可以被点击，按钮上的文本变成获取验证码
                btn.disabled = false;
                // 改变按钮的文本
                btn.value = &#39;获取验证码&#39;;
            }

        }, 1000)

    }
&lt;/script&gt;</code></pre><hr>
<h3 id="5-单次定时器"><a href="#5-单次定时器" class="headerlink" title="5.单次定时器"></a>5.单次定时器</h3><pre><code>&lt;script&gt;
    // 返回定时器的id
    // const timerId = setTimeout(定时执行的函数地址, 毫秒时间);

    // 案例：
    // 隔一个时间点，函数只执行一次，后面就不在执行
    // 返回：定时器id

    var res = setTimeout(function () {
        console.log(&#39;已经爆炸了&#39;);
        // setTimeout(function(){},1000)
    }, 3000)
&lt;/script&gt;</code></pre><hr>
<h3 id="6-清除单次定时器"><a href="#6-清除单次定时器" class="headerlink" title="6.清除单次定时器"></a>6.清除单次定时器</h3><pre><code>&lt;script&gt;
    // clearTimeout(定时器启动时候的编号);

    // 案例：
    //setTimeout()这个定时器也可以清除
    // clearTimeout(定时器id);

    document.querySelector(&#39;input&#39;).onclick = function () {
        clearTimeout(res);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="7-load事件（加载）"><a href="#7-load事件（加载）" class="headerlink" title="7.load事件（加载）"></a>7.load事件（加载）</h3><pre><code>&lt;script&gt;
    // 给图片注册一个load事件
    document.querySelector(&#39;img&#39;).onload = function () {
        // 必须等图片加载完成才做这个事情
        console.log(&#39;图片已经加载完成，可以继续了&#39;);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="8-window中的load事件"><a href="#8-window中的load事件" class="headerlink" title="8.window中的load事件"></a>8.window中的load事件</h3><pre><code>&lt;script&gt;
    // 1. 使用on的方式注册的事件， 后面的会覆盖前面的
    window.onload = function () {

    }

    // 2. 这种方式可以避免同一类型的事件被覆盖
    window.addEventListener(&#39;load&#39;, function () {

    })
&lt;/script&gt;</code></pre><hr>
<h3 id="9-获取元素的样式设值-元素的计算样式：行内，内嵌，外联）"><a href="#9-获取元素的样式设值-元素的计算样式：行内，内嵌，外联）" class="headerlink" title="9.获取元素的样式设值(元素的计算样式：行内，内嵌，外联）"></a>9.获取元素的样式设值(元素的计算样式：行内，内嵌，外联）</h3><pre><code>// 1.window.getComputedStyle();
&lt;script&gt;
    var text = document.querySelector(&#39;.text&#39;);
    var res = window.getComputedStyle(box);
    console.log(parseInt(res.width)); // 800px 转换800
&lt;/script&gt;

&lt;!-- 2.模拟投票（类似进度条） --&gt;
&lt;style&gt;
        .box {
            width: 200px;
            height: 50px;
            background: purple;
        }
&lt;/style&gt;

&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;

&lt;script&gt;
        // 获取元素
        var box = document.querySelector(&#39;.box&#39;);

        box.onclick = function () {
            // 获取当前元素的宽度
            var divWidth = parseInt(window.getComputedStyle(box).width);
            // console.log(divWidth);
            divWidth += 20;

            box.style.width = divWidth + &#39;px&#39;;
        }
&lt;/script&gt;</code></pre><hr>
<h3 id="10-元素的自身样式属性"><a href="#10-元素的自身样式属性" class="headerlink" title="10.元素的自身样式属性"></a>10.元素的自身样式属性</h3><pre><code>&lt;script&gt;
    // offset系列：
    offsetParent: 离这个元素最近的非静态定位的元素
    offsetHeight: height + border + padding
    offsetWidth: width + border + padding
    offsetLeft: 元素左边距离offsetParent左边的间距
    offsetTop: 元素顶部距离offsetParent顶部的距离

    // client系列
    clientWidth: width + padding
    clientHeight: height + padding
    clientLeft: 左边框宽度
    clientTop: 上边框宽度

    // scroll系列
    scrollWidth: 内容的宽度（ 包含超出元素的内容）
    scrollHeight: 内容的高度
    scrollTop: 内容滚动出去的距离
    scrollLeft: 内容滚动出去的距离
&lt;/script&gt;</code></pre><hr>
<h3 id="11-轮播图案例"><a href="#11-轮播图案例" class="headerlink" title="11.轮播图案例"></a>11.轮播图案例</h3><pre><code>&lt;style&gt;
    * {
        margin: 0;
        padding: 0;
    }

    ul {
        list-style: none;
    }

    .box {
        width: 730px;
        height: 454px;
        padding: 8px;
        border: 1px solid green;
        margin: 100px auto;
    }

    .inner {
        position: relative;
        overflow: hidden;
        height: 454px;
    }

    .imglist {
        width: 700%;
        position: absolute;
        left: 0;
        transition: all .4s;
    }

    .imglist img {
        width: 730px;
    }

    li {
        float: left;
    }

    .list {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
    }

    .list i {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: #fff;
        color: #333;
        float: left;
        font-style: normal;
        line-height: 20px;
        font-size: 14px;
        text-align: center;
        margin-right: 10px;
        cursor: pointer;
    }

    .list i:last-child {
        margin-right: 0;
    }

    .list i.current {
        background-color: skyblue;
        color: #fff;
    }

    .arrow {
        position: absolute;
        width: 100%;
        top: 50%;
        margin-top: -30px;
    }

    .arrow-left,
    .arrow-right {
        width: 30px;
        height: 60px;
        position: absolute;
        font: 20px/60px &quot;consolas&quot;;
        color: #fff;
        background-color: rgba(0, 0, 0, .3);
        text-align: center;
        cursor: pointer;
    }

    .arrow-right {
        right: 0;
    }
&lt;/style&gt;

&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;
    &lt;div class=&quot;inner&quot; id=&quot;inner&quot;&gt;
        &lt;ul class=&quot;imglist&quot; id=&quot;imglist&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/1.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/2.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/3.jpg&quot;&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div class=&quot;list&quot;&gt;
            &lt;i class=&quot;current&quot;&gt;1&lt;/i&gt;
            &lt;i&gt;2&lt;/i&gt;
            &lt;i&gt;3&lt;/i&gt;
        &lt;/div&gt;
        &lt;div class=&quot;arrow&quot;&gt;
            &lt;span class=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt;
            &lt;span class=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var dots = document.querySelectorAll(&#39;.list i&#39;);
    var arrowLeft = document.querySelector(&#39;.arrow-left&#39;);
    var arrowRight = document.querySelector(&#39;.arrow-right&#39;);
    var imglist = document.querySelector(&#39;#imglist&#39;);
    var box = document.querySelector(&#39;#box&#39;);
    var imgWidth = document.querySelector(&#39;#imglist img&#39;).offsetWidth;

    // 准备全局步长，整体控制动画速度
    var speed = 100;
    // 准备全局索引值，整体控制图片索引切换
    var keyIndex = 0;

    for (var i = 0; i &lt; dots.length; i++) {
        dots[i].dataset.index = i;
        dots[i].onclick = function () {
            for (var i = 0; i &lt; dots.length; i++) {
                dots[i].classList.remove(&quot;current&quot;);
            }
            this.classList.add(&quot;current&quot;);
            // 同步索引值：把小圆点的索引值也赋值给全局的索引值
            keyIndex = this.dataset.index;
            var target = keyIndex * imgWidth * -1;
            imglist.style.left = target + &quot;px&quot;;
        }
    }

    // 2. 点击左箭头
    // 给左箭头绑定点击事件
    arrowLeft.onclick = function () {
        // =========== 模块1：边界处理 =============
        // 2.1 如果是&lt;边界索引&gt;，开分支判断处理
        if (keyIndex === 0) {
            // 2.1.1 把索引值改成&lt;另一个边界&gt;
            keyIndex = imglist.children.length - 1;
        } else {
            keyIndex--;
        }
        console.log(keyIndex);
        // =========== 模块2：换图处理 =============
        // 2.2.1 计算换图的目标值
        var target = keyIndex * imgWidth * -1;
        // 2.2.2 调用动画函数实现换图效果
        // animate(imglist, target, speed);
        imglist.style.left = target + &quot;px&quot;;
        // =========== 模块3：小圆点处理 =============
        // 2.3.1 排除所有小圆点
        for (var i = 0; i &lt; dots.length; i++) {
            dots[i].classList.remove(&quot;current&quot;);
        }
        dots[keyIndex].classList.add(&quot;current&quot;);
    };

    // 3. 给右箭头绑定点击事件
    arrowRight.onclick = function () {
        moveNext();
    };

    function moveNext() {
        // =========== 模块1：边界处理 =============
        // 3.1 如果是&lt;边界索引&gt;，开分支判断处理
        if (keyIndex === imglist.children.length - 1) {
            // 3.1.1 把索引值改成&lt;另一个边界&gt;
            keyIndex = 0;
            // 3.1.2 把图片换成另一张相同的图片
        } else {
            // 3.1.3 索引值增加
            keyIndex++;
        }
        console.log(keyIndex)
        // =========== 模块2：换图处理 =============
        // 3.2.1 计算换图的目标值
        var target = keyIndex * imgWidth * -1;
        // 3.2.2 调用动画函数实现换图效果
        // animate(imglist, target, speed);
        imglist.style.left = target + &quot;px&quot;;
        // =========== 模块3：小圆点处理 =============
        // 3.3.1 排除所有小圆点
        for (var i = 0; i &lt; dots.length; i++) {
            dots[i].classList.remove(&quot;current&quot;);
        }
        // 通过当前索引值确立对应的小圆点
        dots[keyIndex].classList.add(&quot;current&quot;);
    }

    // 4. 自动播放的功能
    var playTime = 2000;

    var timer = setInterval(function () {
        moveNext();
    }, playTime);

    box.onmouseover = function () {
        clearInterval(timer);
    };

    box.onmouseout = function () {
        timer = setInterval(function () {
            moveNext();
        }, playTime);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="手风琴案例"><a href="#手风琴案例" class="headerlink" title="手风琴案例"></a>手风琴案例</h3><pre><code>&lt;style&gt;
    * {
        margin: 0;
        padding: 0;
    }

    /* 去掉li标签自带的样式 点 */
    ul {
        list-style: none;
    }

    .wrap {
        width: 1000px;
        margin: 50px auto;
    }

    .slider {
        width: 1000px;
        height: 400px;
        border: 1px solid red;
        overflow: hidden;
    }

    .slider li {
        width: 200px;
        height: 400px;
        float: left;
        cursor: pointer;
        /* 过渡属性 */
        transition: all 0.4s;
    }
&lt;/style&gt;

&lt;div class=&quot;wrap&quot;&gt;
    &lt;ul id=&quot;slider&quot; class=&quot;slider&quot;&gt;
        &lt;li&gt;
            &lt;img src=&quot;./images/mi1.jpg&quot; alt=&quot;&quot; /&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;img src=&quot;./images/mi2.jpg&quot; alt=&quot;&quot; /&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;img src=&quot;./images/mi3.jpg&quot; alt=&quot;&quot; /&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;img src=&quot;./images/mi4.jpg&quot; alt=&quot;&quot; /&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;img src=&quot;./images/mi5.jpg&quot; alt=&quot;&quot; /&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
    // 1.获取所有的li元素
    var lis = document.querySelectorAll(&#39;.slider li&#39;);

    // 获取ul的宽度   一会要计算用
    var ul = document.querySelector(&#39;.slider&#39;);
    var ulWidth = parseInt(window.getComputedStyle(ul).width);
    // console.log(ulWidth);

    // 将ul的宽度评分给所有的li
    for (var i = 0; i &lt; lis.length; i++) {
        //将ul的宽度平分给每个li元素
        lis[i].style.width = ulWidth / lis.length + &#39;px&#39;;
    }

    // 给每个里注册一个鼠标移入事件  mouseenter
    // 先设置一个初始鼠标移入的li的宽度
    var liWidth = 800;
    for (var j = 0; j &lt; lis.length; j++) {
        lis[j].onmouseenter = function () {
            // 将当前的这个li的宽度变宽，其他的变窄
            // 排他思想
            for (var k = 0; k &lt; lis.length; k++) {
                lis[k].style.width = (ulWidth - liWidth) / (lis.length - 1) + &#39;px&#39;;
            }
            this.style.width = liWidth + &#39;px&#39;;
        }
    }

    // 给每个li注册一个鼠标离开事件
    for (var v = 0; v &lt; lis.length; v++) {
        lis[v].onmouseleave = function () {
            for (var r = 0; r &lt; lis.length; r++) {
                lis[r].style.width = ulWidth / lis.length + &#39;px&#39;;
            }
        }
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="12-旋转木马案例"><a href="#12-旋转木马案例" class="headerlink" title="12.旋转木马案例"></a>12.旋转木马案例</h3><pre><code>&lt;style&gt;
    /*初始化  reset*/
    * {
        margin: 0;
        padding: 0
    }

    ul {
        list-style: none
    }

    .wrap {
        width: 1200px;
        margin: 100px auto;
    }

    .slider {
        height: 500px;
        position: relative;
    }

    .slider li {
        position: absolute;
        left: 200px;
        top: 0;
        /* CSS3 过渡属性 */
        transition: all .4s;
    }

    .slider li img {
        width: 100%;
    }

    .prev,
    .next {
        width: 76px;
        height: 112px;
        position: absolute;
        top: 50%;
        margin-top: -56px;
        background: url(images/prev.png) no-repeat;
        z-index: 99;
    }

    .next {
        right: 0;
        background-image: url(images/next.png);
    }

    /* 旋转木马布局核心代码 */
    .slider .zuo3 {
        width: 400px;
        top: 20px;
        left: 50px;
        opacity: 0.2;
        z-index: 2;
    }

    .slider .zuo2 {
        width: 600px;
        top: 70px;
        left: 0px;
        opacity: 0.8;
        z-index: 3;
    }

    .slider .zhong {
        width: 800px;
        top: 100px;
        left: 200px;
        opacity: 1;
        z-index: 4;
    }

    .slider .you2 {
        width: 600px;
        top: 70px;
        left: 600px;
        opacity: 0.8;
        z-index: 3;
    }

    .slider .you3 {
        width: 400px;
        top: 20px;
        left: 750px;
        opacity: 0.2;
        z-index: 2;
    }
&lt;/style&gt;

&lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt;
    &lt;div class=&quot;slider&quot; id=&quot;slider&quot;&gt;
        &lt;ul&gt;
            &lt;li class=&quot;&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic1.jpg&quot; /&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic2.jpg&quot; /&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic3.jpg&quot; /&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic4.jpg&quot; /&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;images/slidepic5.jpg&quot; /&gt;&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div class=&quot;arrow&quot; id=&quot;arrow&quot;&gt;
            &lt;a class=&quot;prev&quot; href=&quot;javascript:;&quot; id=&quot;arrLeft&quot;&gt;&lt;/a&gt;
            &lt;a class=&quot;next&quot; href=&quot;javascript:;&quot; id=&quot;arrRight&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var arr = [&#39;zuo3&#39;, &#39;zuo2&#39;, &#39;zhong&#39;, &#39;you2&#39;, &#39;you3&#39;];

    // 页面一加载就将这些类名设置给li元素
    // 封装一个设置类名的函数
    function setClassName(Elements, array) {
        for (var i = 0; i &lt; Elements.length; i++) {
            Elements[i].className = array[i];
        }
    }

    // 获取所有的li
    var lis = document.querySelectorAll(&#39;.slider li&#39;);

    var arrLeft = document.querySelector(&#39;.prev&#39;);
    var arrRight = document.querySelector(&#39;.next&#39;);

    // 第一次进来页面调用一次方法
    setClassName(lis, arr)

    // 给左右的按钮注册点击事件

    // 给右边的按钮注册点击事件
    arrRight.onclick = function () {
        arr.push(arr.shift());

        // 将改变的数组中的类名以此设置给li元素
        // for(var i=0;i&lt;lis.length;i++) {
        //     lis[i].className = arr[i];
        // }

        setClassName(lis, arr);
    }

    // 给左边按钮注册点击事件
    arrLeft.onclick = function () {

        arr.unshift(arr.pop());

        // 将改变之后的数组中的每一项设置给li元素
        // for(var j=0;j&lt;lis.length;j++) {
        //     lis[j].className = arr[j];
        // }
        setClassName(lis, arr);

    }
&lt;/script&gt;</code></pre><hr>
<h3 id="13-forEach使用"><a href="#13-forEach使用" class="headerlink" title="13.forEach使用"></a>13.forEach使用</h3><pre><code>&lt;!-- 案例: --&gt;
&lt;script&gt;
    var arr = [1, 2, 3, 4, 5, 6];

    // for(var i=0;i&lt;arr.length;i++) {
    //     console.log(arr[i]);
    // }

    // ES6中提供的一个循环变量的方法
    // forEach(函数)

    arr.forEach(function (item, index) {
        // console.log(item);
        // console.log(index);
        console.log(item + &#39;------&#39; + index)
    })
&lt;/script&gt; </code></pre><hr>
<h3 id="14-存钱取钱案例："><a href="#14-存钱取钱案例：" class="headerlink" title="14.存钱取钱案例："></a>14.存钱取钱案例：</h3><pre><code>&lt;button class=&quot;setMoney&quot;&gt;存钱&lt;/button&gt;
&lt;button class=&quot;getMoney&quot;&gt;取钱&lt;/button&gt;
&lt;h3&gt;你的账户余额为：&lt;span&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;script&gt;
    var setMoney = document.querySelector(&#39;.setMoney&#39;);
    var getMoney = document.querySelector(&#39;.getMoney&#39;);
    var span = document.querySelector(&#39;span&#39;);

    var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money : 0);
    span.innerText = money;
    setMoney.onclick = function () {
        do {
            var num = Number(prompt(&#39;请输入你要存储的money!&#39;));
            if (num &lt; 0) {
                alert(&#39;请输入正确金额&#39;);
                return;
            }
        } while (!num)
        var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money :
            0);
        money += num;
        this.dataset.id = new Date().getTime();
        var data = {
            money,
            id: this.dataset.id
        }
        localStorage.setItem(&#39;money&#39;, JSON.stringify(data));
        span.innerText = money;
    }
    getMoney.onclick = function () {
        do {
            var num = Number(prompt(&#39;请输入你要取多少money!&#39;));
            if (num &lt; 0) {
                alert(&#39;请输入正确金额&#39;);
                return;
            }
        } while (!num)
        var money = JSON.parse(localStorage.getItem(&#39;money&#39;) ? JSON.parse(localStorage.getItem(&#39;money&#39;)).money :
            0);
        var sum = money - num;
        if (sum &lt; 0) {
            alert(&#39;你的余额已不足！&#39;);
            return;
        }
        var data = {
            money: sum,
            id: setMoney.dataset.id
        }
        localStorage.setItem(&#39;money&#39;, JSON.stringify(data));
        span.innerText = sum
    }
&lt;/script&gt;</code></pre><hr>
<h1 id="js高级课程"><a href="#js高级课程" class="headerlink" title="js高级课程"></a>js高级课程</h1><h2 id="第一天面向对象"><a href="#第一天面向对象" class="headerlink" title="第一天面向对象"></a>第一天面向对象</h2><h3 id="1-定义及让权-两种方法"><a href="#1-定义及让权-两种方法" class="headerlink" title="1.$定义及让权(两种方法)"></a>1.$定义及让权(两种方法)</h3><pre><code>&lt;script&gt;
    // 1. jQuery 
    // 案例：
    var $ = 10;
    console.log($);
    // 第一种：解决方法 $ 等价jQuery
    jQuery(function () {
        jQuery(&quot;#btn&quot;).click(function () {
            console.log(&quot;大家好好听课，开心快乐的学会面向对象&quot;);
        });
    })

    // 2. $.noConflict(); // 让权
    // 案例：
    var xy = $.noConflict(); //等价于让权利，把$权利让给了xy
    var $ = 10;
    console.log($);
    // 第二种：解决方法 $ 等价jQuery
    xy(function () {
        xy(&quot;#btn&quot;).click(function () {
            console.log(&quot;大家好好听课，开心快乐的学会面向对象&quot;);
        });
    })
&lt;/script&gt;</code></pre><hr>
<h3 id="2-判断当前数据类型对象（当前对象-）"><a href="#2-判断当前数据类型对象（当前对象-）" class="headerlink" title="2.判断当前数据类型对象（当前对象 ）"></a>2.判断当前数据类型对象（当前对象 ）</h3><pre><code>&lt;script&gt;
    var nul = null;
    console.log(typeof nul);
    Object.prototype.toString.call(nul); // 输出当前对象 
&lt;/script&gt;</code></pre><hr>
<h3 id="3-js组成部分"><a href="#3-js组成部分" class="headerlink" title="3.js组成部分"></a>3.js组成部分</h3><pre><code>    1.ECMAScript 2.DOM（文档对象模型） 3.BOM(浏览器对象模型)</code></pre><hr>
<h3 id="4-js的数据类型"><a href="#4-js的数据类型" class="headerlink" title="4.js的数据类型"></a>4.js的数据类型</h3><pre><code>    基本数据类型和引用数据类型</code></pre><hr>
<h3 id="5-typeof-打印的都是字符串"><a href="#5-typeof-打印的都是字符串" class="headerlink" title="5.typeof 打印的都是字符串"></a>5.typeof 打印的都是字符串</h3><pre><code>&lt;script&gt;
    var nul = null;
    console.log(typeof nul);
    Object.prototype.toString.call(nul);
&lt;/script&gt;</code></pre><hr>
<h3 id="6-判断当前变量属于哪个对象"><a href="#6-判断当前变量属于哪个对象" class="headerlink" title="6.判断当前变量属于哪个对象"></a>6.判断当前变量属于哪个对象</h3><pre><code>&lt;script&gt;
    Object.prototype.toString.call(nul);
&lt;/script&gt;</code></pre><hr>
<h3 id="7-引用都是object对象-（typeof打印）"><a href="#7-引用都是object对象-（typeof打印）" class="headerlink" title="7.引用都是object对象 （typeof打印）"></a>7.引用都是object对象 （typeof打印）</h3><pre><code>&lt;script&gt;
    var arr = [1, 2, 2]
    console.log(typeof arr) // 输出object 
&lt;/script&gt;
</code></pre><hr>
<h3 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h3><pre><code>    基本数据类型除了null 特例 返回object，其他都返回对应的数据类型
    引用数据类型除了function() 返回function  其他都是object</code></pre><hr>
<h3 id="9-null-undefined-是true（隐式转换）"><a href="#9-null-undefined-是true（隐式转换）" class="headerlink" title="9.null == undefined 是true（隐式转换）"></a>9.null == undefined 是true（隐式转换）</h3><h3 id="10-NaN-翻译是-not-a-number"><a href="#10-NaN-翻译是-not-a-number" class="headerlink" title="10.NaN 翻译是 not a number"></a>10.NaN 翻译是 not a number</h3><pre><code>&lt;script&gt;
    // 我们向isNaN传递一个参数，它的本意是通过Number()方法尝试转换参数的类型为Number,如果转换成功返回false，否则失败转返回true；

    isNaN(123) // false
    isNaN(&#39;123时间跳跃&#39;) // true
&lt;/script&gt;</code></pre><hr>
<h3 id="11-号和"><a href="#11-号和" class="headerlink" title="11.== 号和 ==="></a>11.== 号和 ===</h3><pre><code>    == 只是比较值
    === 比较值和类型</code></pre><hr>
<h3 id="12-amp-（或）-（与）"><a href="#12-amp-（或）-（与）" class="headerlink" title="12.&amp;（或） ||（与）"></a>12.&amp;（或） ||（与）</h3><pre><code>&lt;script&gt;
    // 逻辑与 || 如果有一个为true， 结果都为真， 除非两个都为假， 结果才为假

    // 2.1 只要有一个条件为true时， 结果就为true；
    // 2.2 当两个条件都为false时， 结果才为false；
    // 2.3 当一个条件为true时， 后面的条件不再判断

    console.log(5 &amp;&amp; 4); // 当结果为真时，返回第二个为真的值4 
    console.log(0 &amp;&amp; 4); // 当结果为假时，返回第一个为假的值0 
    console.log(5 || 4); // 当结果为真时，返回第一个为真的值5 
    console.log(0 || 0); // 当结果为假时，返回第二个为假的值0 
    console.log((3 || 2) &amp;&amp; (5 || 0)); //5 

    var a = obj || &quot; &quot;; // 如果 obj 为空，a就赋值为 &quot; &quot; ；
    var a = check() &amp;&amp; do(); // 如果check()返回为真，就执行do()，并将结果赋值给 a;

    // 补充:

    // 表达式a &amp;&amp; 表达式b: 计算表达式a（ 也可以是函数） 的运算结果，
    // 如果为 True, 执行表达式b（ 或函数）， 并返回b的结果；
    // 如果为 False， 返回a的结果；

    // 表达式a || 表达式b: 计算表达式a（ 也可以是函数） 的运算结果，
    // 如果为 Fasle, 执行表达式b（ 或函数）， 并返回b的结果；
    // 如果为 True， 返回a的结果；
&lt;/script&gt;</code></pre><hr>
<h3 id="13-引用类型比较的地址"><a href="#13-引用类型比较的地址" class="headerlink" title="13.引用类型比较的地址"></a>13.引用类型比较的地址</h3><pre><code>&lt;script&gt;
    var arr1 = [1, 2, 3, 4, 5]
    var arr2 = [1, 2, 3, 4, 5]

    console.log(arr1 == arr2) // false

    // 值类型和引用类型:

    // 值类型传递的是指
    // 引用类型传递的是地址
&lt;/script&gt;</code></pre><hr>
<h3 id="14-数组"><a href="#14-数组" class="headerlink" title="14.数组"></a>14.数组</h3><pre><code>&lt;script&gt;
    var arr = [] // 创建方式名字：字面量
&lt;/script&gt;
</code></pre><hr>
<h3 id="15-函数传参值和引用no区别"><a href="#15-函数传参值和引用no区别" class="headerlink" title="15.函数传参值和引用no区别"></a>15.函数传参值和引用no区别</h3><pre><code>    1.值类型传参 ，只改边方法内部，
    2.引用类型传参，能改变全局变量，因为引用是地址，改变是同一地址</code></pre><hr>
<h3 id="16-创建空对象"><a href="#16-创建空对象" class="headerlink" title="16.创建空对象"></a>16.创建空对象</h3><pre><code>&lt;script&gt;
    var obj ={};
&lt;/script&gt;</code></pre><hr>
<h3 id="17-对象增加属性"><a href="#17-对象增加属性" class="headerlink" title="17.对象增加属性"></a>17.对象增加属性</h3><pre><code>&lt;script&gt;
    // 1. 第一种
    obj.name = &#39;dddd&#39;,
        obj.age = 10

    // 2. 第二种[]
    obj[&#39;name&#39;] = &#39;xiaoming&#39;;
    obj[&#39;sex&#39;] = 1;
&lt;/script&gt;</code></pre><hr>
<h3 id="18-对象增加方法"><a href="#18-对象增加方法" class="headerlink" title="18.对象增加方法"></a>18.对象增加方法</h3><pre><code>&lt;script&gt;
    // 1.第一种
    obj.say = function () {}
    obj.say();

    // 2.通过中[]
    obj[&#39;say&#39;] = function () {}

    // 调用：
    obj[&#39;say&#39;]();
&lt;/script&gt;</code></pre><hr>
<h3 id="19-修改属性"><a href="#19-修改属性" class="headerlink" title="19.修改属性"></a>19.修改属性</h3><pre><code>&lt;script&gt;
    // 对象属性总结： 有则改， 无则增
    // 1. 第一种
    obj.name = &#39;tt&#39;;
    obj.age = 10;

    // 2. 第二种
    obj[&#39;name&#39;] = &#39;ppp&#39;;
    obj[&#39;sex&#39;] = 8;

    console.log(obj[&#39;name&#39;])
&lt;/script&gt;</code></pre><hr>
<h3 id="20-删除属性"><a href="#20-删除属性" class="headerlink" title="20.删除属性"></a>20.删除属性</h3><pre><code>&lt;script&gt;
    // 1. delete obj.name // 删除成功返回true

    console.log(delete obj.name)

    // 2. 第二种[]：
    delete obj[&#39;name&#39;]
&lt;/script&gt;</code></pre><hr>
<h3 id="21-语法处理数字key-查询"><a href="#21-语法处理数字key-查询" class="headerlink" title="21.[]语法处理数字key 查询"></a>21.[]语法处理数字key 查询</h3><pre><code>&lt;script&gt;
    var per = {
        1: &#39;小明&#39;,
        201: 54
    }

    console.log(per[&#39;3&#39;]) // 也可以per[3] 只有数字的可以省略引号

    console.log(obj[&quot;name&quot;]);
&lt;/script&gt;</code></pre><hr>
<h3 id="22-in关键字的基本使用"><a href="#22-in关键字的基本使用" class="headerlink" title="22.in关键字的基本使用"></a>22.in关键字的基本使用</h3><pre><code>&lt;script&gt;
    // in判断一个成员（ 属性或函数） 是否在对象中存在， 如果存在返回true， 反之返回false

    // 1. 语法格式： key in obj: key必须是字符串

    var a = &quot;name&quot;
    console.log(a in obj); // 这样是可以的 输出true

    // 案例：
    var obj = {
        name: &#39;jkjkkj&#39;,
        age: 12
    }

    console.log(&quot;name&quot; in obj); // 返回true

    //in遍历循环
    for (var key in obj) {
        alert(key); // name；
        console.log(key, obj[key]);
    }

    // 案例：
    var obj = {
        name: &quot;xiaoqiang&quot;,
        age: 18,
        say: function () {
            console.log(&quot;我是方法&quot;);
        }
    };

    for (var key in obj) {
        if (typeof obj[key] != &#39;function&#39;) {
            console.log(key, obj[key]);
        }
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="23-判断一个数组存在的元素-方法两种"><a href="#23-判断一个数组存在的元素-方法两种" class="headerlink" title="23.判断一个数组存在的元素(方法两种:)"></a>23.判断一个数组存在的元素(方法两种:)</h3><pre><code>&lt;script&gt;
    // 1. arr[key] == &quot;B&quot;;
    // 2. indexOf();

    // 1. 第一种
    var arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
    // 第一种写法：for in
    for (var key in arr) { //推 荐第一个方法
        // 判断
        if (arr[key] == &quot;B&quot;) { // 存在
            console.log(&quot;存在&quot;);
        }
    }

    // 2. 第二种
    if (arr.indexOf(&quot;B&quot;) != -1) { //表 示存在
        console.log(&quot;存在&quot;);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="24-delete关键字基本使用"><a href="#24-delete关键字基本使用" class="headerlink" title="24.delete关键字基本使用"></a>24.delete关键字基本使用</h3><pre><code>&lt;script&gt;
    // 语法： delete 对象.成员 或 对象[成员]
    // 作用： 删除对象的成员， 删除成功返回true， 反之返回false

    // 1. 可以删除未定义var的变量

    // 案例：
    test9 = &quot;这是一个未使&quot;;
    console.log(test);
    console.log(delete test9); // true

    // 2. 不可以删除 var声明的变量

    var str = &quot;demo&quot;;
    console.log(delete str); // false
    console.log(str); // demo

    // 3. 可以直接删除window上的属性

    window.demo2 = &quot;demo001&quot;;
    console.log(delete window.demo2); // true
    console.log(window.demo2); // undefined
&lt;/script&gt;</code></pre><hr>
<h3 id="25-for循环跳出"><a href="#25-for循环跳出" class="headerlink" title="25.for循环跳出"></a>25.for循环跳出</h3><pre><code>    1.break;    跳出整个for循环
    2.continue; 跳出本次循环</code></pre><hr>
<h3 id="26-异常处理"><a href="#26-异常处理" class="headerlink" title="26.异常处理"></a>26.异常处理</h3><pre><code>&lt;script&gt;
    // 1.try： 可能出错的代码块
    // 2.catch： 处理try代码块中抛出的异常
    // 3.throw： 抛出自定义的异常
    // 4.finally： 无论上面的程序是否有错误， 都会执行性的代码块

    // 案例：
    var a = 123;
    try {
        console.log(a);
        console.log(b);
    } catch (e) {
        // throw &quot;这是一个错误信息&quot;;
        throw {
            errorMsg: e, // 具体的错误信息
            errorCode: 10001 // 错误码
        }
    } finally { // 加上finally是一个完整的结构
        // 不管前面的代码有没有出错,都会执行
        console.log(&quot;不管前面的代码有没有出错,都会执行这个代码块中的代码&quot;);
    }
&lt;/script&gt;</code></pre><hr>
<h2 id="第二天-1"><a href="#第二天-1" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-面向对象三大特性"><a href="#1-面向对象三大特性" class="headerlink" title="1.面向对象三大特性"></a>1.面向对象三大特性</h3><pre><code>    1.封装
    2.多态 ：多种形态
    3.继承(组合继承, 原型继承，原型链继承，call继承，经典继承，class继承)</code></pre><hr>
<h3 id="2-创建对象封装案例："><a href="#2-创建对象封装案例：" class="headerlink" title="2.创建对象封装案例："></a>2.创建对象封装案例：</h3><pre><code>&lt;script&gt;
    var p = {
        name: &quot;xiao song&quot;,
        age: 10,
        sex: 1,
        eat: function () {
            console.log(&quot;吃饭&quot;);
        },
        sleep: function () {
            console.log(&quot;睡觉&quot;);
        }
    }
    console.log(p.name); // 访问对象的属性
    p.eat(); // 访问对象的方法
&lt;/script&gt;</code></pre><hr>
<h3 id="3-获取dom元素"><a href="#3-获取dom元素" class="headerlink" title="3.获取dom元素"></a>3.获取dom元素</h3><pre><code>&lt;script&gt;
    // 创建div元素： document.createElement(&quot;div&quot;);

    // 获取元素对象： document.getElementById(&quot;div&quot;);

    // 获取div标签： document.getElementsByTagName(&quot;div&quot;)[0];

    // 访问元素的文本内容： div.innerText;

    // 页面追加元素： document.body.appendChild(div);

    // 页面删除子元素： document.body.removeChild(div);

    // 案例：
    document.getElementsByTagName(&quot;p&quot;);
    document.getElementsByClassName(&quot;test&quot;);
    document.getElementById(&quot;test&quot;);
    oDiv.innerText = &quot;div&quot; + i;
&lt;/script&gt;
</code></pre><hr>
<h3 id="4-封装函数案例"><a href="#4-封装函数案例" class="headerlink" title="4.封装函数案例"></a>4.封装函数案例</h3><pre><code>&lt;script&gt;
    var $ = {
        setStype: function (eles, bgcolor) {
            for (var i = 0; i &lt; eles.length; i++) {
                eles[i].style.backgroundColor = bgcolor;
                eles[i].style.border = &quot;1px solid #000&quot;;
                eles[i].style.color = &quot;white&quot;;
            }
        },
        getElementsByTagName: function (tagName) {
            return document.getElementsByTagName(tagName);
        },
        getElementsByClassName: function (className) {
            return document.getElementsByClassName(className);
        }
    }
    var ps = $.getElementsByTagName(&quot;p&quot;)
    $.setStype(ps, &quot;green&quot;);
    var tests = $.getElementsByClassName(&quot;test&quot;);
    $.setStype(tests, &quot;red&quot;);
&lt;/script&gt;</code></pre><hr>
<h3 id="5-id处理成数组"><a href="#5-id处理成数组" class="headerlink" title="5.id处理成数组"></a>5.id处理成数组</h3><pre><code>&lt;script&gt;
    getElementById: function (eleId) {
        return [document.getElementById(eleId)];​
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="6-创建对象-五种方式-1-5种"><a href="#6-创建对象-五种方式-1-5种" class="headerlink" title="6.创建对象 (五种方式+1 5种)"></a>6.创建对象 (五种方式+1 5种)</h3><pre><code>&lt;script&gt;
    // 1.字面量创建对象 var obj={}
    // 案例：
    var book1 = {
        name: &quot;JavaScript权威指南&quot;,
        price: 100,
        author: &quot;tim&quot;,
        showInfo: function () {
            console.log(this.name, this.price, this.author);
        }
    }
    console.log(book1);

    // 2.内置构造函数创建对象 var book2 = new Object();
    // 案例：
    var book2 = new Object();
    book2.name = &quot;JS&quot;;
    book2.price = 10;
    book2.author = &quot;作者&quot;;
    book2.showInfo = function () {
        console.log(this.name, this.price, this.author);
    }
    book2.showInfo();

    // 3.工厂模式创建对象（this）instanceof判断 --- function person(){}
    // 这样有缺陷 console.log(book3 instanceof createBook); //结果false
    // 3.1 案例：
    function createBook(name, price, author) {
        var book = new Object();
        book.name = name;
        book.price = price;
        book.author = author;
        book.showInfo = function () {
            console.log(this.name, this.price, this.author);
        }
        return book;
    }
    var book3 = createBook(&quot;bookName1&quot;, 10, &quot;author1&quot;);
    var book4 = createBook(&quot;bookName2&quot;, 10, &quot;author2&quot;);
    console.log(book3);
    console.log(book4);

    // 4. 自定义构造函数方式--- function Person(name, age) {}
    // 4.1 解决是：采用（this）: 在全局作用下this 指向window，new之后指向这个对象
    1. 在函数内部默认会创建一个空对象
    var obj = new Object();
    // 4.2 默认把创建好的对象赋值给this this = obj;
    // 4.3 默认设置this的原型对象为当前构造函数的原型对象
    // 4.4 通过this添加属性和方法 
    // 4.5. 默认会把内部创建的对象返回
    return this;
    function CreatePerson(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex; // 默认的返回值return this
    }
    var p = new createPerson(&quot;Neld&quot;, 10, 1);
    var p2 = new createPerson(&quot;Song&quot;, 12, 0);
    console.log(p instanceof createPerson); // 是true

    // 5.Object.create() 原型链方式创建
    // 优势：好处可以创建一个没有原型链的对象，优势：提高检索的速度
    // 5.1:
    var per = {
        name: &#39;小刘&#39;,
        age: 45
    }
    var obj = Object.create(per);
    console.log(obj);

    // 5.2:
    var nul = Object.create(null);
    nul.name = &quot;测试成功&quot;;
    console.log(nul);

    // 6.assign:将多个对象合并到一个对象中

    var obj = {
        name: &quot;zs&quot;,
        age: 18
    }
    console.log(Object.assign(obj, {
        info: &quot;信息内容&quot;
    }, {
        adderss: &quot;地址&quot;
    }, {
        name: &quot;lw&quot;
    })) // 如果后面的对象和前面重名了，就直接修改了前面的对象名称
    重复的属性后面的会直接覆盖前面的
    // 6.1合并新对象    

    let result1 = Object.assign({}, obj1, obj2);
&lt;/script&gt;
</code></pre><hr>
<h3 id="7-构造函数创建对象的返回值"><a href="#7-构造函数创建对象的返回值" class="headerlink" title="7.构造函数创建对象的返回值"></a>7.构造函数创建对象的返回值</h3><pre><code>    1. 如果返回值类型的数据，无效 ，仍然返回创建好的对象（this），不做任何修改  
       2. 如果返回引用类型的数据，有效，则返回指定的数据，不再返回this。 返回指定的对象</code></pre><hr>
<h3 id="8-回调函数"><a href="#8-回调函数" class="headerlink" title="8.回调函数"></a>8.回调函数</h3><pre><code>&lt;script&gt;
    // 函数如果作为参数来使用我们一般叫做回调函数

    // 1. 匿名函数调用

    // 案例1：
    function f1(fn) {
        console.log(&quot;我是第一个函数&quot;);
        fn();
    }

    f1(function () {
        console.log(&quot;我是一个 匿名函数&quot;);
    });

    // 2. 命名函数调用命名函数

    function f1(fn) {
        console.log(&quot;我是第一个函数&quot;);
        fn();
    }

    function f2() {
        console.log(&#39;我是一份命名函数&#39;);
    }
    f1(f2);
&lt;/script&gt;
</code></pre><hr>
<h3 id="9-高阶函数"><a href="#9-高阶函数" class="headerlink" title="9.高阶函数"></a>9.高阶函数</h3><pre><code>&lt;script&gt;
    // 函数如果作为返回值来使用----我们叫做高阶函数（return 可以跟任意数据类型，当然也可以跟函数------函数是上帝，可以造万物）

    function f1() {
        console.log(&quot;我是第一个函数&quot;);
        return function () {
            console.log(&#39;内部函数体&#39;)
        }
    }
    var yunxing = f1();
    console.log(yunxing());
&lt;/script&gt;</code></pre><hr>
<h3 id="10-constructor判断对象构造器"><a href="#10-constructor判断对象构造器" class="headerlink" title="10.constructor判断对象构造器"></a>10.constructor判断对象构造器</h3><pre><code>&lt;script&gt;
    // 使用constructor属性可以获取到创建对象使用的构造器函数对象， 所以我们可以通过判断构造器的类型来得知创建的对象的类型-- - constructor和instanceof一样的都是找父类 是返回true

    // 案例：
    function Person(name) {
        this.name = name;
    }

    function Dog(name) {
        this.name = name;
    }
    var p = new Person(&quot;p&quot;);
    var d = new Dog(&quot;d&quot;);
    console.log(p.constructor); // 打印得到Person函数对象
    console.log(d.constructor); // 打印得到Dog函数对象
    if (p.constructor == Person) {
        console.log(&quot;是Person对象&quot;);
    }
    if (d.constructor == Dog) {
        console.log(&quot;是Dog对象&quot;);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="11-instanceof关键词"><a href="#11-instanceof关键词" class="headerlink" title="11.instanceof关键词"></a>11.instanceof关键词</h3><pre><code>&lt;script&gt;
    //instanceof关键字可以直接用来判断对象的类型，如果是指定的类型，返回true，反之返回false。---找父类

    // 案例：
    function Person(name, age) { // 构造函数---构造器
        this.name = name;
        this.age = age;
        this.sayHi = function () {
            console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);
        }
    }

    var per1 = new Person(&quot;zs&quot;, 18);
    console.log(per1 instanceof Person); // true
&lt;/script&gt;</code></pre><hr>
<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="1-this回顾"><a href="#1-this回顾" class="headerlink" title="1.this回顾"></a>1.this回顾</h3><h3 id="2-查看原型"><a href="#2-查看原型" class="headerlink" title="2.查看原型"></a>2.查看原型</h3><pre><code>&lt;script&gt;
    console.dir(对象);
&lt;/script&gt;</code></pre><hr>
<h3 id="3-原型三句话"><a href="#3-原型三句话" class="headerlink" title="3.原型三句话"></a>3.原型三句话</h3><pre><code>    1.每一个构造函数都有一个prototype属性，指向它自己原型的对象
    2.每一个实例化对象都有一个__proto__属性,指向它所属类的原型对象
    3.每一个原型对象都有一个constructor属性，指向构造函数本身</code></pre><hr>
<h3 id="4-获取原型三个方法"><a href="#4-获取原型三个方法" class="headerlink" title="4.获取原型三个方法"></a>4.获取原型三个方法</h3><pre><code>&lt;script&gt;
    // 1、 构造函数.prototype
    // 2、 实例化对象.__proto__
    // 3、 Object.getPrototypeOf(实例化对象)

    // 1. Person.prototype 2. 实例化对象.__proto__ 注意(两条线) 3. Object.getPrototypeOf(实例化 对象)
    // 案例：
    function Person(name, age) {
        this.name = name; // 属性
        this.age = age; // 属性
    }
    // 方法放在原型上
    Person.prototype.sayH = function () {
        console.log(&#39;我是原型上的方法&#39;);
    }
    var per1 = new Person(&quot;lw&quot;, 18);
    console.log(per1);

    console.log(Person.prototype == per1.__proto__);
    console.log(Person.prototype == Object.getPrototypeOf(per1));
    console.log(per1.__proto__ == Object.getPrototypeOf(per1));
&lt;/script&gt;</code></pre><hr>
<h3 id="5-this的重新认识-创建对象补充"><a href="#5-this的重新认识-创建对象补充" class="headerlink" title="5.this的重新认识(创建对象补充)"></a>5.this的重新认识(创建对象补充)</h3><pre><code>&lt;script&gt;
    // call或者apply方法修改this的指向, 借用对象的属性

    // 案例:
        function Person(name, age) {
            // var obj = new Object();
            // this = obj;
            // obj.name = name
            // ob.__proto__ = Person.prototype;
            this.name = name;
            this.age = age;
            // return this
        }

    // 实例化对象
    var per1 = new Person(&quot;ZS&quot;, 18);
    console.log(per1);
&lt;/script&gt;</code></pre><hr>
<h3 id="6-将定义的方法添加到对象中"><a href="#6-将定义的方法添加到对象中" class="headerlink" title="6.将定义的方法添加到对象中"></a>6.将定义的方法添加到对象中</h3><pre><code>&lt;script&gt;
    function demo() {
        console.log(this);
    }

    var obj = {
        name: &quot;zs&quot;
    };
    obj.demo = demo; // 有则改，无则增
    obj.demo();
&lt;/script&gt;</code></pre><hr>
<h3 id="7-函数共享-引入原型对象"><a href="#7-函数共享-引入原型对象" class="headerlink" title="7.函数共享(引入原型对象)"></a>7.函数共享(引入原型对象)</h3><pre><code>&lt;script&gt;
    function Person(name, age) {
        this.name = name; // 属性
        this.age = age; // 属性
        // this.sayHi = function() {这样不能共享
        //     console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);
        // };
    }

    // 原型的两大特点：数据共享，继承  原型prototype
    Person.prototype.sayHi = function () { // 一般来说方法都放在原型上
        console.log(&quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age);
    }

    // 实例化对象
    var per1 = new Person(&quot;lw&quot;, 18);
    console.log(per1);
    // 看原型的方法
    console.dir(per1)
    per1.sayHi();

    // 实例化对象
    var per2 = new Person(&quot;zs&quot;, 16);
    console.log(per2);
    per2.sayHi();
&lt;/script&gt;</code></pre><hr>
<h3 id="8-多个方法放在原型里（原型中改变父类指向）"><a href="#8-多个方法放在原型里（原型中改变父类指向）" class="headerlink" title="8.多个方法放在原型里（原型中改变父类指向）"></a>8.多个方法放在原型里（原型中改变父类指向）</h3><pre><code>&lt;script&gt;
    // 注意: constructor: Person, // 这句改变了指向

    // 案例：（ 如果对象这样定义）
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype = {
        constructor: Person, //解决只需这行
        sayHi: function () {
            console.log(&quot;改变指向&quot;);
        }
    }

    var per = new Person(&#39;XIAOO&#39;, 1);

    console.log(per.constructor);
&lt;/script&gt; </code></pre><hr>
<h3 id="9-hasOwnProperty和in属性操作-（私有属性和公有属性）判断"><a href="#9-hasOwnProperty和in属性操作-（私有属性和公有属性）判断" class="headerlink" title="9.hasOwnProperty和in属性操作 （私有属性和公有属性）判断"></a>9.hasOwnProperty和in属性操作 （私有属性和公有属性）判断</h3><pre><code>&lt;script&gt;
    // 案例1.（in） 公有和私有
    // 检测私有属性
    console.log(&quot;name&quot; in per1); // true
    console.log(&quot;age&quot; in per1); // true
    // 检测公用属性
    console.log(&quot;sayHi&quot; in per1);
    console.log(&quot;play&quot; in per1);

    // 案例2.（hasOwnProperty）只找私有

    // 私有的属性
    console.log(per1.hasOwnProperty(&quot;name&quot;));
    console.log(per1.hasOwnProperty(&quot;age&quot;));
    // 检测不到原型上的方法
    console.log(per1.hasOwnProperty(&quot;sayHi&quot;));
    console.log(per1.hasOwnProperty(&quot;play&quot;));

    // 需求1： 检测对象中是否存在某个指定的属性(该属性只在实例对象上) hasOwnProperty 有返回true
    // 需求2: 检测对象中是否存在指定的某个属性(该属性只存在原型对象上) onlyPrototypePro

    // 案例：
    // 函数写出需求
    function onlyPrototypePro(key, obj) { // key 属性，obj对象
        return key in obj &amp;&amp; !obj.hasOwnProperty(key); // 剩下的就是公有属性和方法
    }
    console.log(isPublic(&quot;sayHi&quot;, per1));
&lt;/script&gt;</code></pre><hr>
<h3 id="10-isPrototypeOf和instanceof"><a href="#10-isPrototypeOf和instanceof" class="headerlink" title="10.isPrototypeOf和instanceof"></a>10.isPrototypeOf和instanceof</h3><pre><code>&lt;script&gt;
    // 1. isPrototypeOf： 判断某个对象是否是指定对象的原型对象, 如果是返回true， 反之返回false

    console.log(Person.prototype.isPrototypeOf(per));

    // 2. instanceof--找父类

    console.log(per1 instanceof Person);
&lt;/script&gt;</code></pre><hr>
<h3 id="11-混入式继承-浅拷贝"><a href="#11-混入式继承-浅拷贝" class="headerlink" title="11.混入式继承(浅拷贝)"></a>11.混入式继承(浅拷贝)</h3><pre><code>&lt;script&gt;
    // 案例：

    var obj1 = {
        name: &quot;zs&quot;,
        age: 18,
        car: {
            name: &quot;mini&quot;
        }
    }

    var obj2 = {};
    for (var key in obj1) {
        obj2[key] = obj1[key];
    }
    obj1.car.name = &quot;bus&quot;;
    console.log(obj1);
    console.log(obj2);
&lt;/script&gt;</code></pre><hr>
<h3 id="12-原型式继承（原型式继承跟混入式继承都存在数据共享问题。）"><a href="#12-原型式继承（原型式继承跟混入式继承都存在数据共享问题。）" class="headerlink" title="12.原型式继承（原型式继承跟混入式继承都存在数据共享问题。）"></a>12.原型式继承（原型式继承跟混入式继承都存在数据共享问题。）</h3><pre><code>&lt;script&gt;
    Person.prototype = Animal.prototype; // 原型式继承    
    // 案例：
    // 定义一个Animal
    function Animal() {

    }
    // 原型加方法
    Animal.prototype.sayHI = function () {
        console.log(&quot;我是原型身上的方法&quot;);
    }
    //定义一个Person
    function Person() {

    }
    // 原型式继承
    Person.prototype = Animal.prototype; // 原型式继承

    Animal.prototype.say = function () {
        console.log(&quot;我是新加的方法&quot;);
    }
    var per1 = new Person();
    console.log(per1);

    var ani = new Animal();
    console.log(ani);
&lt;/script&gt;</code></pre><hr>
<h3 id="13-原型封装方法-原型增加方法"><a href="#13-原型封装方法-原型增加方法" class="headerlink" title="13.原型封装方法(原型增加方法)"></a>13.原型封装方法(原型增加方法)</h3><pre><code>&lt;script&gt;
    // 缺陷： 在原型上封装我们要使用的方法， 这样就不会影响到被人使用Array, 导致检索时间太长。
    // 案例：
    var arr1 = [1, 2, 3];
    var arr2 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;];

    //增加原型方法
    Array.prototype.getLength = function () {
        return this.length;
    }
    console.log(arr1.getLength());
    console.dir(arr1)
&lt;/script&gt;</code></pre><hr>
<h3 id="14-原型封装方法-原型增加方法-升级版（安全扩展）j解决缺陷"><a href="#14-原型封装方法-原型增加方法-升级版（安全扩展）j解决缺陷" class="headerlink" title="14.原型封装方法(原型增加方法)升级版（安全扩展）j解决缺陷"></a>14.原型封装方法(原型增加方法)升级版（安全扩展）j解决缺陷</h3><pre><code>&lt;script&gt;
    案例：
    function MyArray() {

    }

    MyArray.prototype = new Array(); // 我们继承这个new Array()
    MyArray.prototype.getLength = function () {
        return this.length;
    }
    // 实例化对象
    var arr1 = new MyArray();
    arr1.push(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;);
    console.log(arr1.getLength());
&lt;/script&gt;    </code></pre><hr>
<h3 id="15-原型对象Object"><a href="#15-原型对象Object" class="headerlink" title="15.原型对象Object"></a>15.原型对象Object</h3><pre><code>&lt;script&gt;
    console.log(Person.prototype.__proto__.constructor); // 指向原型对象
    console.log(Object.prototype.__proto__);
&lt;/script&gt;</code></pre><hr>
<h2 id="第四天-1"><a href="#第四天-1" class="headerlink" title="第四天"></a>第四天</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><h3 id="2-Object-create方法的基本使用"><a href="#2-Object-create方法的基本使用" class="headerlink" title="2.Object.create方法的基本使用"></a>2.Object.create方法的基本使用</h3><pre><code>&lt;script&gt;
    // 在Object的构造函数上存在一个create方法， 该方法的作用是用来创建对象的。
    // 该方法可以接收的参数有一下两种

    // 1. null
    // 创建一个空对象， 这个空对象中连最基本的原型对象都没有的

    // 2. 对象
    // 创建传递进来的对象， 并设置该对象的原型对象为当前的参数
&lt;/script&gt;</code></pre><hr>
<h3 id="3-call方法和apply方法的基本使用-借用其他对象方法"><a href="#3-call方法和apply方法的基本使用-借用其他对象方法" class="headerlink" title="3.call方法和apply方法的基本使用(借用其他对象方法)"></a>3.call方法和apply方法的基本使用(借用其他对象方法)</h3><pre><code>&lt;script&gt;
    // 语法： 
    // 1. 对象1.方法.call(对象2) // 此时方法不代括号()
    // 2. 对象1.方法.apply(对象2) // 此时方法不代括号()

    // 个人用法: 借用对象.函数不带括号.call(被借用对象2)

    // 作用: 借用其他对象的方法, call() 和apply() 可以改变this指向，
    // 看call() 和apply() 里面传递的第一个参数， 第一个参数是谁 this就指向谁

    // 两个不同： apply传参数值是[]

    // 案例：
    var obj1 = {
        name: &quot;zs&quot;,
        dog: function () {
            console.log(this.name + &quot;借用张三家的dog&quot;);
        },
        add: function (a, b) {
            return a + b;
        }
    }
    var obj2 = {
        name: &quot;lw&quot; // 隔壁老王
    }

    //借用对象.函数不带括号.call(被借用对象2)
    console.log(obj1.add.call(obj2, 2, 6)); // 借用方法
    console.log(obj1.add.apply(obj2, [2, 6])); // 借用方法
&lt;/script&gt;</code></pre><hr>
<h3 id="4-借用其他对象属性变量"><a href="#4-借用其他对象属性变量" class="headerlink" title="4.借用其他对象属性变量"></a>4.借用其他对象属性变量</h3><pre><code>&lt;script&gt;
    // 关键词： window.Person.call(this, name, age)

    // 案例：
    function Person(name, age) {
        this.name = name;
        this.age = age;
    };

    Person.prototype.fun1 = function () {
        console.log(&quot;name:&quot;, this.name, &quot;age:&quot;, this.age);
    };

    function Sub(color, age, name) {
        window.Person.call(this, name, age); // 主要是这句
        this.color = color;
    };

    var sub = new Sub(&quot;红色&quot;, 18, &quot;小明&quot;);
    console.log(sub);
&lt;/script&gt;</code></pre><hr>
<h3 id="5-五种继承方式-（五种继承）-1-class继承-（6种）"><a href="#5-五种继承方式-（五种继承）-1-class继承-（6种）" class="headerlink" title="5.五种继承方式 （五种继承）+1 class继承 （6种）"></a>5.五种继承方式 （五种继承）+1 class继承 （6种）</h3><pre><code>&lt;script&gt;
    // 1. 混入式继承， 浅拷贝存在共享(for key in obj)

    // 概念： 对于非基本类型数据， 浅拷贝只是拷贝了内存地址， 子类属性指向父类属性的内存地址， 而子类修改后父类也会被修改

    // 浅拷贝存在数据共享问题， 修改其中一个另外一个也被修改了（ 后面课有深拷贝） 搜索 深拷贝
    // 案例浅拷贝：
    var obj1 = {
        name: &quot;zs&quot;,
        age: 18,
        like: [&quot;Java&quot;, &quot;H5&quot;, &quot;Ui&quot;],
        wife: {
            name: &quot;翠花&quot;,
            age: 18
        }
    }

    var obj2 = {}; // 隔壁老王
    for (var key in obj1) {
        obj2[key] = obj1[key];
    }

    console.log(obj2);
    obj2.wife.name = &quot;如花&quot;;
    console.log(obj1);

    // 2. 原型式继承， 存在共享（ 问题是只能继承父类对象原型上的成员， 但无法继承父类对象中的成员。） Student.prototype = Person.prototype
    // 案例：
    function Animal() {
        this.color = &quot;red&quot;;
    }
    Animal.prototype.weight = 100;

    function Person() {}
    Person.prototype = Animal.prototype;
    var p = new Person();
    console.log(p);

    // 3. 原型链继承，存在问题

    // 3.1 共享的问题 3.2 子类无法向父类传参 Student.prototype = new Person()

    // 案例：
    function Person(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    Person.prototype.play = function () {
        console.log(&quot;我是原型上的方法&quot;);
    }

    function Student(score) {
        this.score = score;
    }

    // 原型链继承 Student.prototype = new Person()//这种写法叫做原型链继承
    Student.prototype = new Person(&quot;小明&quot;, 19, &quot;男&quot;);
    var stu1 = new Student(100);
    console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score);

    // stu1.name = &quot;zs&quot;;    （子类无法向父类传参）

    // 4.借用构造函数继承， 解决子类向父类传参方式， 不能调用父类方法 使用call() 继承（ window.Person.call(this, 参数, age, sex);）

    // 案例：
    function Person(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    Person.prototype.sayHi = function () {
        console.log(&quot;链上添加方法&quot;);
    }

    function Animal(color, name, age, sex) {
        // 借用其他对象中的构造函数
        window.Person.call(this, name, age, sex);
        this.color = color;
    }
    var per = new Person()

    var ani = new Animal(&quot;红色&quot;, &quot;小刘&quot;, 55, &quot;男&quot;);
    console.log(per);
    console.log(ani);
    // ani.sayHi(); 不能调用方法        

    // 5. 组合继承（借用构造函数继承和原型链继承） 工作中用这种（ Student.prototype = new Person();）

    // 案例：
    function Person(name, sex, age) {
        this.name = name;
        this.sex = sex;
        this.age = age;
    };

    Person.prototype.sayHi = function () {
        console.log(&quot;天气糟糕!&quot;);
    };

    // 组合继承，1.原型链方式加call()借用构造函数
    function Student(score, name, sex, age) {
        window.Person.call(this, name, sex, age);
        this.score = score;
    }

    Student.prototype = new Person();
    var stu = new Student(&#39;20&#39;, &#39;小刘&#39;, &#39;男&#39;, 51);
    stu.name = &quot;张&quot;
    stu.sayHi();
    console.log(stu);
    console.log(stu.__proto__);
&lt;/script&gt;</code></pre><hr>
<h3 id="6-原型链解析"><a href="#6-原型链解析" class="headerlink" title="6.原型链解析"></a>6.原型链解析</h3><pre><code>&lt;script&gt;
    // 案例：
    // 完整版的原型图
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    // 实例化对象
    var per = new Person();

    // 测试--找到构造函数的父类 Person(只要是函数都是Function)
    console.log(Person.constructor); // 找父类 Function
    console.log(Function.prototype); // 找原型，或者找妻子 f()
    console.log(Person.__proto__); // 找妈妈 f()

    // 测试扩展主线----函数是上帝，可以自己造自己
    console.log(Function.constructor); // Function

    // 测试空函数父类是谁
    console.log(Person.__proto__.constructor); // Function

    // 换个思想 把对象当成函数来看
    console.log(Object.__proto__.constructor); // Function

    console.log(Function.prototype.__proto__ == Object.prototype); // true
    console.log(Object.__proto__); // f()
&lt;/script&gt;</code></pre><hr>
<h3 id="7-圆括号语法（-语法）"><a href="#7-圆括号语法（-语法）" class="headerlink" title="7.圆括号语法（()语法）"></a>7.圆括号语法（()语法）</h3><pre><code>&lt;script&gt;
    // 圆括号语法(工作里面给我们的数据全部是json格式) - 跟对象是一样的就是键值对多了一对双引号(100).add(100)

    // 案例：
    console.log(({
        &quot;name&quot;: &quot;zs&quot;
    }));

    Number.prototype.add = function (num) {
        return this + num;
    };

    console.log((100).add(100)); // 圆括号语法，直接拿数组调用方法记得要加()圆括号语法
&lt;/script&gt;</code></pre><hr>
<h3 id="8-is-4个特例"><a href="#8-is-4个特例" class="headerlink" title="8.is(4个特例)"></a>8.is(4个特例)</h3><pre><code>&lt;script&gt;
    // is：判断两个参数是否相等， 等同于 === ，注意下面两种特殊的判断即

    console.log(0 === -0); // true
    console.log(Object.is(0, -0)); // false
    console.log(NaN === NaN); // false
    console.log(Object.is(NaN, NaN)); // true
    // 总结：特殊案例记下：转换为布尔为false: 0 &quot;&quot; undefined null NaN
&lt;/script&gt;</code></pre><hr>
<h3 id="9-Api方法-Object静态成员"><a href="#9-Api方法-Object静态成员" class="headerlink" title="9.Api方法 Object静态成员"></a>9.Api方法 Object静态成员</h3><pre><code>&lt;script&gt;
    // 1. getOwnPropertyDescriptor 访问属性（ 增、 删、 改、 查属性）

    console.log(Object.getOwnPropertyDescriptor(obj, &quot;name&quot;));

    // configurable： 属性可配置型， false， 当前属性不能被删除， 可修改， 并且后面不能再改变该描述对象
    // enumerable： 可枚举性， false， 当前属性不是被循环遍历到
    // value： 当前属性的值
    // writable： 可写性， false， 当前属性的值不能被修改

    // 2. getOwnPropertyDescriptors ** ：获取所有属性的描述对象

    // 案例： 
    console.log(Object.getOwnPropertyDescriptors(obj));

    // 3. defineProperties 一次定义多个属性的可操作性（ configurable | enumerable | value | writable）

    // 案例：
    Object.defineProperties(obj, {
        name: {
            configurable: false
        },
        age: {
            configurable: true
        }
    })

    console.log(delete obj.name); // name属性已被删除
    console.log(delete obj.age);
    console.log(obj);

    // 4. defineProperty： 定义当前指定属性的可操作性（ configurable | enumerable | value | writable）

    // 案例：
    Object.defineProperty(obj, &quot;name&quot;, {
        configurable: false //当前属性不能被删除
    });
    console.log(delete obj.name);
    console.log(obj);

    // 5. keys: 获取当前对象所有属性的名称， 不可枚举的属性除外

    // 案例：
    var obj = {
        name: &quot;zs&quot;,
        age: 18,
        sex: &quot;男&quot;
    };
    // keys：获取当前对象所有key属性的名称，不可枚举的属性除外(获取可以枚举的属性)
    Object.defineProperty(obj, &quot;name&quot;, {
        enumerable: false // 不可枚举
    });
    for (var key in obj) {
        console.log(obj[key]); // 遍历后都是可枚举的
    }

    console.log(Object.keys(obj)); // 这个等价上面的for循环

    // 6. getOwnPropertyNames： 获取当前对象所有属性的名称， 包括不可枚举的属性

    // 案例： 
    console.log(Object.getOwnPropertyNames(obj));

    // 7. isExtensible： 检查当前对象是否可扩展， false， 不能添加属性，

    console.log(Object.isExtensible(obj)); // true,如果是false就不能添加属性

    // 8. isSealed：： 检查当前对象是否是被密封的， true， 不能添加和删除属性

    console.log(Object.isFrozen(obj)); // false,如果设置为true这对象就不能删除和修改，和添加

    // 9. isFrozen： 检查当前对象是否是被冻结的， true， 不能添加， 删除和修改属性

    console.log(Object.isFrozen(obj)); // false,如果设置为true这对象就不能删除和修改，和添加

    // 10. preventExtensions： 阻止当前对象的可扩展性， 就是添加不了属性了

    // 案例:
    Object.preventExtensions(obj); // (不能添加,能修改，能删除)
    obj.color = &quot;pink&quot;;
    obj.age = 88;
    console.log(delete obj.name);
    console.log(obj);

    // 11. seal： 密封当前对象、 添加删除不了， 可以修改

    // 案例：
    Object.seal(obj); //（删除 --no添加--no，只可以修改）
    obj.color = &quot;pink&quot;;
    obj.age = 88;
    console.log(delete obj.name);
    console.log(obj);

    // 12. freeze: 冻结当前对象、 不能删除、 不能修改、 不能删除

    // 案例：
    Object.freeze(obj); //（添加 --no，删除--no 修改--no）
    obj.color = &quot;pink&quot;;
    obj.age = 88;
    console.log(delete obj.name);
    console.log(obj);

    // 13. entries： 获取到所有成员， 以数组形式返回

    // 案例：
    var obj2 = {
        name: &quot;lw&quot;,
        age: 88,
        sex: 1,
        fun: function () {
            console.log(&quot;我是方法&quot;);
        }
    }
    console.log(obj2);
    console.log(Object.entries(obj2));

    // 14. hasOwnProperty： 判断当前实例对象中是否存在指定的属性, 如果存在返回true， 反之返回false（ 只是判断私有属性）
    // 案例：
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    // 实例化对象
    var per = new Person(&quot;zs&quot;, 18);

    console.log(per.hasOwnProperty(&quot;name&quot;)); // true (in是判断私有和公有)

    // 15. isPrototypeOf： 判断当前对象是否在指定对象的原型链中, 如果是返回true， 反之返回false；

    // 案例： 
    console.log(Person.prototype.isPrototypeOf(per)); // true

    // 16. propertyIsEnumerable: 属性是否可以枚举（ 循环遍历）, 如果可以枚举返回的是true， 反之返回false

    // 案例： 
    console.log(per.propertyIsEnumerable(&quot;name&quot;)); // true
    console.log(per.propertyIsEnumerable(&quot;constructor&quot;)); // false

    // 17. valueOf(): 基本包装类型： 返回对应的值 | 日期转时间戳（ 微毫秒）（ 重点）

    // 引用类型： 返回this， 对象本身
    // 日期类型： 返回时间戳

    // 案例: 1. 返回对应的值
    var str = new String(&quot;demo&quot;);
    console.log(str.valueOf(str));

    // 17.2 返回对象本身
    var obj = {
        name: &quot;zs&quot;,
        age: 18
    };
    console.log(obj.valueOf());

    // 17.3 日期类型： 返回时间戳
    var now = new Date();
    console.log(now.valueOf());

    // 18. toString()（ 重点） 转字符串

    // 返回数据特定的格式的字符串
    // 基本类型： 返回对应值的字符串
    // 如果是数字类型， 可以传递一个参数指定转换成上面进制的数字字符串 二进制、 八进制、 16 进制
    // 引用类型： 返回[object Object] 格式的字符串， object为对象的类型， Object为对象对应的构造函数

    // 案例1：
    console.log((100).toString());
    console.log((100).toString(2));
    console.log((100).toString(8));
    console.log((100).toString(16));

    // 案例数组中toString() 不一样：

    var arr = [1, 2, 3, 45, &#39;eee&#39;, 7];
    console.log(arr.toString()); // 1,2,3,45,eee,7
    //借用Object
    console.log(Object.prototype.toString.call(arr)); // 借用Object方法  [object Array]

    var str11 = arr.toString();
    console.log(&quot;hhh:&quot; + str11); // hhh:1,2,3,45,eee,7

    //比较这两个方法
    console.dir(arr);
    console.log(Object.prototype.toString() == Array.prototype.toString()); // false
&lt;/script&gt;</code></pre><hr>
<h3 id="10-判断当前对象是否是数组类型-判断数组类型-重点-兼容-isArray"><a href="#10-判断当前对象是否是数组类型-判断数组类型-重点-兼容-isArray" class="headerlink" title="10.判断当前对象是否是数组类型(判断数组类型) 重点 兼容  isArray()"></a>10.判断当前对象是否是数组类型(判断数组类型) 重点 兼容  isArray()</h3><pre><code>&lt;script&gt;
    // 注意： 封装一个方法， 让所有浏览器兼容, Array.isArray有些浏览器兼容， 有些不兼容
    // 处理兼容问题，这个函数来判断你是否是数组

    // 案例:
        function isArray(arr) { // 处理兼容问题，这个函数来判断你是否是数组
            // 判断
            if (Array.isArray) {
                return Array.isArray(arr);
            } else {
                return Object.prototype.toString.call(arr) == &quot;[object Array]&quot;
            }
        }

    console.log(isArray({}));
    console.log(isArray([1, 2, 3, 4, 5]));

    // 19. toLocaleString() 将当前日期生成系统格式（本地时间格式）（重点）返回的是string类型
    var d = new Date();
    console.log(d.toLocaleString()); // 2019/3/10 下午4:23:54

    // 20. arguments是伪数组（重点）
    // 案例：
    function fun() {
        var sum = 0;
        for (var i = 0; i &lt; arguments.length; i++) {
            sum += arguments[i];
        }
        return sum;
    }
    var result = fun(10, 20, 30, 40, 50);
    console.log(result);
    // 21. eval() 函数 json数据处理（ 重点） 1. JSON.parse() 2. JSON
    // .stringify() 3. eval() 两种 1. 处理json加（） 语法 2. eval() 转换之后立即执行,
    // 可以实现 eval() 和函数几乎是一样， 都是把字符串转换成js能运行的代码 eval() 和函数的区别就是: 函数必须要调用， eval() 可以直接执行

    // 案例：
    var jsonObj = &#39;{&quot;name&quot;:&quot;xiaoliu&quot;,&quot;age&quot;:18}&#39;;
    console.log(eval(jsonObj)); // 报错 Unexpected token &#39;:&#39;
    // 解决方案：加()语法

    var jsonObj = &#39;({&quot;name&quot;:&quot;xiaoliu&quot;,&quot;age&quot;:18})&#39;; // 此处加()解决

    console.log(eval(jsonObj)); // 成功
&lt;/script&gt;</code></pre><hr>
<h2 id="第五天-2"><a href="#第五天-2" class="headerlink" title="第五天"></a>第五天</h2><h3 id="1-函数创建2种"><a href="#1-函数创建2种" class="headerlink" title="1.函数创建2种"></a>1.函数创建2种</h3><pre><code>&lt;script&gt;
    // 1. 第一种创建函数
    function fun() {
        console.log(&quot;我是命名函数，我是有名字的函数&quot;);
    }
    fun();

    // 2. 匿名函数
    var fun2 = function () {
        console.log(&quot;匿名函数或者叫做函数表达式&quot;);
    };
    fun2();

    // 传递形参
    var fun4 = new Function(&quot;a&quot;, &quot;b&quot;, &quot;console.log(a+b)&quot;);
    console.log(fun4); // 查看方法体
    fun4(5, 6)
&lt;/script&gt;</code></pre><hr>
<h3 id="2-Function构造函数创建对象"><a href="#2-Function构造函数创建对象" class="headerlink" title="2.Function构造函数创建对象"></a>2.Function构造函数创建对象</h3><pre><code>&lt;script&gt;
    // 1. 创建函数无参数的函数对象：
    var fun2 = new Function();
    fun2();

    // 2. 定义一个有函数体的函数对象
    var fun2 = new Function(&quot;console.log(&#39;hello h5&#39;);&quot;);
    fun2(); // hello h5
&lt;/script&gt;</code></pre><hr>
<h3 id="3-this指向（重点）this对象"><a href="#3-this指向（重点）this对象" class="headerlink" title="3.this指向（重点）this对象"></a>3.this指向（重点）this对象</h3><pre><code>&lt;script&gt;
    // 总结： 函数中的参数 arguments， this length
    // 1、函数作为普通函数执行的时候， this指向window *
    // 2、函数作为对象的方法调用， this指向调用方法的对象(看点， 点前面是谁this就指向谁) *
    // 3、使用new 构造函数， this指向我们新创建的实例对象 *
    // 4、上下文调用(call、 apply)， this指向第一个参数（ call() 和apply() 第一个参数是谁this就指向谁）


    // 1. 普通调用 fun() this指向调用函数的对象-- - window
    // 2. 对象调用 obj.fun() this指向调用函数的对象-- - obj
    // 3. 使用new关键字调用 new Fun() this指向函数内部创建的新对象
    // 4. call或者apply调用 this指向call或者apply方法的第一个参数
&lt;/script&gt;
</code></pre><hr>
<h3 id="4-检测类型4个-类型检查-判断类型-（4种）"><a href="#4-检测类型4个-类型检查-判断类型-（4种）" class="headerlink" title="4.检测类型4个 类型检查 判断类型 （4种）"></a>4.检测类型4个 类型检查 判断类型 （4种）</h3><pre><code>&lt;script&gt;
    // 1. typeof: 主要用来判断基本类型

    // 案例：
    onsole.log(typeof &quot;abc&quot;); // &quot;string&quot;
    console.log(typeof 123); // &quot;number&quot;
    console.log(typeof true); // &quot;boolean&quot;
    console.log(typeof null); // &quot;object&quot;
    console.log(typeof Function); // &quot;function&quot;
    console.log(typeof {
        name: &quot;Neld&quot;,
        age: 10
    }); // &quot;object&quot;

    // 2. constructor: 可以用来判断创建对象的构造器的类型

    function Person() {}
    var p = new Person();

    console.log(p.constructor == Person); // true

    // 3. instanceof: 判断指定构造函数的原型对象是否在当前实例对象的原型链上

    function Person() {}
    var p = new Person();

    console.log(p instanceof Person); // true
    console.log(p instanceof Object); // true

    // 4. Object.prototype.toString(): // 获取数据类型对应的字符串

    console.log(Object.prototype.toString.call(&quot;Neld&quot;)); // [object String]
    console.log(Object.prototype.toString.call(10)); // [object Number]
    console.log(Object.prototype.toString.call(p)); // [object Object]
    console.log(Object.prototype.toString.call([])); // [object Array]
&lt;/script&gt;</code></pre><hr>
<h3 id="5-class语法"><a href="#5-class语法" class="headerlink" title="5.class语法"></a>5.class语法</h3><pre><code>&lt;script&gt;
    // 案例：
    class Person {

        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        sayHi() {
            console.log(&quot;普通方法&quot;);
        }
        static hobby() {
            console.log(&quot;静态方法&quot;);
        }
    }
    let per = new Person(&#39;下课&#39;, 45);
    per.sayHi();
    Person.hobby();
&lt;/script&gt;</code></pre><hr>
<h3 id="6-class继承-（前面课总结5种继承）"><a href="#6-class继承-（前面课总结5种继承）" class="headerlink" title="6.class继承 （前面课总结5种继承）"></a>6.class继承 （前面课总结5种继承）</h3><pre><code>&lt;script&gt;
    // 案例：
    class Animal {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        // 一般方法都放在原型上
        play() {
            console.log(&quot;我是Animal原型上的方法&quot;);
        }
    }

    // ES6的继承
    class Person extends Animal {
        constructor(name, age) {
            super(name, age);
        }
        // 自己原型上也可以添加方法
        say() {
            console.log(&quot;我是Person原型的方法&quot;);
        }
    }

    // 实例化
    var per1 = new Person(&quot;zs&quot;, 18);
    console.log(per1);
    console.log(per1.name);
&lt;/script&gt;</code></pre><hr>
<h3 id="7-作用域安全问题有三种-代码的健壮性处理-容错机制-（重点）"><a href="#7-作用域安全问题有三种-代码的健壮性处理-容错机制-（重点）" class="headerlink" title="7.作用域安全问题有三种 代码的健壮性处理 容错机制 （重点）"></a>7.作用域安全问题有三种 代码的健壮性处理 容错机制 （重点）</h3><pre><code>&lt;script&gt;
    // 处理结果三种方法：
    // 1.
    if (this == window) { // (严格模式this不指向window)有点小问题不推荐
        return new Person(); // 容错机制 
    }


    // 2. 利用 instanceof
    if (!(this instanceof Person)) {
        return new Person(); // 容错机制
    }

    // 3. target没有使用new返回undefined-- --new.target == undefined
    if (!new.target) {
        // throw &quot;没有使用new创建&quot;
        return new Person(); // 容错机制

    }

    // 案例1：（ 严格模式thi不指向window）
    function Person(name, age) {
        if (this == window) {
            return new Person(); // 容错机制 
        }
        this.name = name;
        this.age = age;
    }
    let per = Person(&#39;下课&#39;, 45); // 没有return 就返回undefined
    console.log(per);
&lt;/script&gt;</code></pre><hr>
<h3 id="8-对象深拷贝（封装一个深拷贝函数）-（重点）"><a href="#8-对象深拷贝（封装一个深拷贝函数）-（重点）" class="headerlink" title="8.对象深拷贝（封装一个深拷贝函数） （重点）"></a>8.对象深拷贝（封装一个深拷贝函数） （重点）</h3><pre><code>&lt;script&gt;
    // 深拷贝： 他会一层一层拷贝， 每一层都会进入拷贝， 实现了数据独立问题， 不会存在数据共享了

    // 案例：
    var souce = {
        name: &#39;xiao&#39;,
        age: 15,
        arr: [45, 16, 18],
        wife: {
            name: &quot;小青&quot;,
            age: 15
        },
        color: &#39;红色&#39;,
        width: 89
    };
    var new2 = {};

    deepCopy(souce, new2);
    console.log(new2);

    function deepCopy(oldObj, newObj) {
        // 拷贝循环
        for (let key in oldObj) {
            // 去掉公有 判断只获取私有属性
            if (oldObj.hasOwnProperty(key)) { // 为了拿到私有属性

                // 接着处理不同的对象 数组对象和引用对象分开 判断对象typeof  引用对象都是Object
                if (typeof oldObj[key] == &#39;object&#39;) {
                    // 获取引用的对象，引用对象需要新增
                    newObj[key] = Array.isArray(oldObj[key]) ? [] : {}
                    deepCopy(oldObj[key], newObj[key]);
                } else {
                    // 表示拷贝的是值类型
                    newObj[key] = oldObj[key];
                }
            }
        }
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="9-入口函数封住id"><a href="#9-入口函数封住id" class="headerlink" title="9.入口函数封住id"></a>9.入口函数封住id</h3><pre><code>&lt;script&gt;
    window.onload = function () {
        etById(&quot;aaqq&quot;);
    }

    function getById(id) {
        return document.getElementById(id);
    }
&lt;/script&gt;</code></pre><hr>
<h2 id="第六天-2"><a href="#第六天-2" class="headerlink" title="第六天"></a>第六天</h2><h3 id="1-函数几种定义（自定义函数）-匿名函数"><a href="#1-函数几种定义（自定义函数）-匿名函数" class="headerlink" title="1.函数几种定义（自定义函数） 匿名函数"></a>1.函数几种定义（自定义函数） 匿名函数</h3><pre><code>&lt;script&gt;
    // 1. 命名函数定义
    function fun1() {
        console.log(&quot;命名函数&quot;);
    }
    fun1();

    // 2. 匿名函数表达式
    var fun2 = function () {
        console.log(&quot;匿名函数表达式&quot;);
    }
    fun2();

    // 3. 命名函数表达式
    var fun3 = function f4() {
        console.log(&quot;命名函数表达式&quot;);
        console.log(f4);
    }
    fun3();

    // 4. 创建函数对象的方式
    var fun5 = new Function();
    fun5();

    // 案例：
    var fun5 = new Function(&quot;var i=0; if(!i){ console.log(&#39;999&#39;);} &quot;);

    console.log(fun1.name); // fun1
    console.log(fun2.name); // fun2
    console.log(fun3.name); // f4
    console.log(fun5.name);
&lt;/script&gt;</code></pre><hr>
<h3 id="2-数组去重函数-（重点）"><a href="#2-数组去重函数-（重点）" class="headerlink" title="2.数组去重函数  （重点）"></a>2.数组去重函数  （重点）</h3><pre><code>&lt;script&gt;
    // 1. 去重案例：
    var arr = [1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 6, 7, 7, 7, 7, 8];

    function distinctArray(arr) {
        // 先定义要给数组，存放我筛选之后的数据
        var newArray = [];
        for (var i = 0; i &lt; arr.length; i++) {
            // 判断 indexOf检测数据里面的元素是否存在，如果存在返回对应的索引值，如果不存在返回 -1；
            if (newArray.indexOf(arr[i]) == -1) { // 表示的是不存在
                newArray.push(arr[i]);
            }
        }
        return newArray;
    }
    //  调用函数
    var result = distinctArray(arr);
    console.log(result);

    // 2. es6语法 - 去重案例

    var arr = [1, 1, 2, 2, 3, 6, 4, 6]
    var data = new Set(arr);
    var arr1 = Array.from(data);
    console.log(arr1);

    // 3. es6写法
    // 数组去重
    let arr = [10, 2, 30, 10, 5, 40, 1, 2];
    console.log(new Set(arr));
    let arr2 = [...new Set(arr)];
    console.log(arr2);
&lt;/script&gt;</code></pre><hr>
<h3 id="3-数组求最大值最小值"><a href="#3-数组求最大值最小值" class="headerlink" title="3.数组求最大值最小值"></a>3.数组求最大值最小值</h3><pre><code>&lt;script&gt;
    var arr = [1, 5, 1, 21, 33, 56, 89];

    function max(arr) {
        // 定义一个最大值
        var temp = arr[0];
        for (var i = 0; i &lt; arr.length; i++) {
            if (temp &lt; arr[i]) {
                temp = arr[i];
            }
        }
        return temp;
    }
    console.log(max(arr));

    function min(arr) {
        // 定义一个最小值
        var temp = arr[0];
        for (var i = 0; i &lt; arr.length; i++) {
            if (temp &gt; arr[i]) {
                temp = arr[i];
            }
        }
        return temp;
    }

    console.log(min(arr)); // 定义最小值
&lt;/script&gt;</code></pre><hr>
<h3 id="4-匿名函数6种-立即执行函数-自执行函数（自定义函数）-匿名函数"><a href="#4-匿名函数6种-立即执行函数-自执行函数（自定义函数）-匿名函数" class="headerlink" title="4.匿名函数6种 立即执行函数,自执行函数（自定义函数） 匿名函数"></a>4.匿名函数6种 立即执行函数,自执行函数（自定义函数） 匿名函数</h3><pre><code>&lt;script&gt;
    // 第一种方式
    (function () {
        console.log(&#39;第一种方式&#39;);
    })();

    // 第二种方式
    (function () {
        console.log(&#39;第二种方式&#39;);
    }());

    // 第三种写法
    ! function () {
        console.log(&#39;第三种方式&#39;);
    }();

    // 第四种写法
    + function () {
        console.log(&#39;第四种写法&#39;);

    }();

    // 第五种写法 
    - function () {
        console.log(&#39;第五种写法&#39;);
    }();

    // 第六种写法
    ~ function () {
        console.log(&#39;第六种写法&#39;);
    }();
&lt;/script&gt;</code></pre><hr>
<h3 id="5-操作增删改查-封装函数-对象增删改查"><a href="#5-操作增删改查-封装函数-对象增删改查" class="headerlink" title="5.操作增删改查(封装函数) 对象增删改查"></a>5.操作增删改查(封装函数) 对象增删改查</h3><pre><code>&lt;script&gt;
    // --删除splice(下标， 删几个) 查下标indexOf

    // 案例：
    var books = [{
        name: &quot;活着&quot;,
        price: 27.7,
        press: &quot;作家出版社&quot;
    }, {
        name: &quot;流浪地球&quot;,
        price: 37.6,
        press: &quot;中国华侨出版社&quot;
    }, {
        name: &quot;罗生门&quot;,
        price: 36.3,
        press: &quot;开明出版社&quot;
    }, {
        name: &quot;三体&quot;,
        price: 51.5,
        press: &quot;重庆出版社&quot;
    }];

    // 函数封装
    function getBookByName(name) {
        for (var i = 0; i &lt; books.length; i++) {
            if (books[i].name == name) {
                return books[i];
            }
        }
        return &quot;查无此书&quot;;
    }
    console.log(getBookByName(&quot;三体&quot;));
    // 添加封装
    function addBook(newBook) {
        books.push(newBook);
    }

    addBook({
        name: &quot;JS从三分钟入门&quot;,
        price: 10,
        press: &quot;二十四期出版社&quot;
    });

    //需求3：将罗生门这本书的价格修改为40
    function updateBookByName(name, newBook) {
        var book = getBookByName(name); // 先调用我们前面查询的方法
        var i = books.indexOf(book); // 拿到这本书的索引值并且修改这本书
        books.splice(i, 1, newBook);
    }
    updateBookByName(&quot;三体&quot;, {
        name: &quot;一只特立独行的猪&quot;,
        price: 50,
        press: &quot;王小波&quot;
    });

    // 需求4：将三体这本书从书单中删除
    function deleteBookByName(name) {
        var book = getBookByName(name);
        var i = books.indexOf(book); // 此时就是获取你这个元素索引
        books.splice(i, 1);
    }
    deleteBookByName(&quot;流浪地球&quot;);
    console.log(books);
&lt;/script&gt;</code></pre><hr>
<h3 id="6-函数封装到对象-重点"><a href="#6-函数封装到对象-重点" class="headerlink" title="6.函数封装到对象(重点)"></a>6.函数封装到对象(重点)</h3><pre><code>&lt;script&gt;
    // 案例：
    var books = [{
        name: &quot;活着&quot;,
        price: 27.7,
        press: &quot;作家出版社&quot;
    }, {
        name: &quot;流浪地球&quot;,
        price: 37.6,
        press: &quot;中国华侨出版社&quot;
    }, {
        name: &quot;罗生门&quot;,
        price: 36.3,
        press: &quot;开明出版社&quot;
    }, {
        name: &quot;三体&quot;,
        price: 51.5,
        press: &quot;重庆出版社&quot;
    }];

    function BookManager(books) { // 构造函数
        this.books = books;
    }
    // 方法都放在原型上,books前面加this， getBookByName加this
    BookManager.prototype = {
        constructor: BookManager,
        getBookByName: function (name) {
            for (var i = 0; i &lt; this.books.length; i++) {
                if (this.books[i].name == name) {
                    return this.books[i];
                }
            }
            return &quot;查无此书&quot;;
        },
        addBook: function (newBook) {
            this.books.push(newBook);
        },
        updateBookByName: function (name, newBook) {
            var book = this.getBookByName(name); // 先调用我们前面查询的方法
            var i = this.books.indexOf(book); // 拿到这本书的索引值并且修改这本书
            this.books.splice(i, 1, newBook);
        },
        deleteBookByName: function (name) {
            var book = this.getBookByName(name);
            var i = this.books.indexOf(book); // 此时就是获取你这个元素索引
            this.books.splice(i, 1);
        }
    }

    // 实例化对象
    var manager = new BookManager(books);
&lt;/script&gt;</code></pre><hr>
<h3 id="7-with-使用（echarc中用）"><a href="#7-with-使用（echarc中用）" class="headerlink" title="7.with 使用（echarc中用）"></a>7.with 使用（echarc中用）</h3><pre><code>&lt;script&gt;
    // 案例：
    var a = {
        name: &quot;zs&quot;,
        b: {
            age: 10,
            c: {
                color: &quot;red&quot;,
                des: &quot;description&quot;
            }
        }
    }

    with(a.b.c) {
        console.log(color);
        console.log(des);
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="8-自执行函数方式-立即执行函数"><a href="#8-自执行函数方式-立即执行函数" class="headerlink" title="8.自执行函数方式(立即执行函数)"></a>8.自执行函数方式(立即执行函数)</h3><pre><code>&lt;script&gt;
    // 案例：
    // 1. 匿名函数
    var div = document.getElementById(&quot;div1&quot;);

    (function (style) {
        div.style.backgroundColor = &quot;pink&quot;;
        style.width = &quot;300px&quot;;
        style.height = &quot;300px&quot;;
        style.border = &quot;1px solid #000&quot;;
    })(div.style)

    // 2. 普通函数

    function setStyle(style) {
        div.style.backgroundColor = &quot;pink&quot;;
        style.width = &quot;300px&quot;;
        style.height = &quot;300px&quot;;
        style.border = &quot;1px solid #000&quot;;
    }
    setStyle(div.style);
&lt;/script&gt;</code></pre><hr>
<h3 id="9-严格模式（慎用，启用后之前代码重写）"><a href="#9-严格模式（慎用，启用后之前代码重写）" class="headerlink" title="9.严格模式（慎用，启用后之前代码重写）"></a>9.严格模式（慎用，启用后之前代码重写）</h3><pre><code>&lt;script&gt;
    // 1. 不允许使用未声明的变量
    &quot;use strict&quot;;
    num = 10;
    console.log(num);

    // 2. 严格模式定义在脚本开头， 会对整个脚本执行严格模式
    function fun() {
        num = 100;
        console.log(num);
    }
    fun();

    // 3. 如果严格模式定义在函数头部， 那么只在当前函数中使用严格模式， 对函数外部的代码没有影响。
    function fun() {
        &quot;use strict&quot;;
        age = 18;
        console.log(age);
    }
    fun();

    // 4. 在严格模式下， 试图删除不可删除的属性时， 会抛出异常
    delete Object.prototype;

    function fun(a, a, b) {
        &quot;use strict&quot;;
        return a + a + b;
    }
    var result = fun(1, 2, 3);

    // 5. 禁止八进制数字语法
    &quot;use strict&quot;;
    var sum = 015 + // 语法错误
        197 +
        142;
    console.log(sum);

    // 6.禁止this指向全局对象，当this指向全局对象时，自动转为undefined
    function fun() {
        &quot;use strict&quot;;
        console.log(this);
    }
    fun();
&lt;/script&gt;</code></pre><hr>
<h3 id="10-块级作用域（函数作用域）"><a href="#10-块级作用域（函数作用域）" class="headerlink" title="10.块级作用域（函数作用域）"></a>10.块级作用域（函数作用域）</h3><pre><code>概念：js没有块级作用域的，如果在一对大括号{}里面定义的变量，外面访问不了，那么此时就形成了块级作用域，如果能访问就没有块级作用域（left 和函数除外）</code></pre><hr>
<h3 id="11-域解析试题"><a href="#11-域解析试题" class="headerlink" title="11.域解析试题"></a>11.域解析试题</h3><pre><code>&lt;script&gt;
    var a;
    var b;
    var c;

    console.log(a, b, c); // undefined undefined undefined
    a = 10,
        b = 20,
        c = 30;

    function f(a) { // 形参就是局部的
        var b;
        console.log(a, b, c); // 10 undefined 30
        b = a = c = 100;
        console.log(a, b, c); // 100 100 100  c是全局的，修改了c全局被修改了
    }
    f(10, 20);
    console.log(a, b, c); // 10,20,100
&lt;/script&gt;</code></pre><hr>
<h2 id="第七天-1"><a href="#第七天-1" class="headerlink" title="第七天"></a>第七天</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><pre><code>&lt;script&gt;
    // 闭包： 首先是函数套函数， 子函数调用了父函数的变量或参数， 并且子函数被外界所引用。 此时这变量就被缓存了。

    // 优势：缓存数据，想办法把数据缓存下来
    // 缺点：内存泄漏
    // 典型闭包案例

    // 闭包可以缓存数据
    // 案例经典1：
    function fun1() {
        var a = 10;

        function fun2() {
            return a;
        }
        return fun2;
    }
    var result = fun1();
    console.log(result);
    console.log(result());

    // 案例2(优化后)：

    function fun1() {
        var a = 10;
        return function () {
            return a;
        }
    }
    var result = fun1();
    console.log(result);
    console.log(result());

    // 案例3(优化后)：

    function fun1() {
        var a = 10;
        var b = 20;
        return function () {
            return [a, b];
        }
    }
    // 调用这个函数
    var result = fun1();
    var a = result()[0];
    var b = result()[1];
    console.log(a, b);

    // 案例4：
    function fun1() {
        var a = 10;
        var b = 20;
        return [
            function () {
                return a;
            },
            function () {
                return b;
            }
        ]
    }

    var result = fun1();
    var a = result[0]();
    var b = result[1]();
    console.log(a, b);

    // 案例五 变成对象 {}：
    function fun1() {
        var a = 10;
        var b = 20;
        return { // return 后面可以跟任意数据类型当然也可以跟对象
            getA: function () {
                return a;
            },
            getB: function () {
                return b;
            }
        }
    }

    var result = fun1();
    var a = result.getA();
    var b = result.getB();
    console.log(a, b);

    // 案例六: 工作或者面试的写法

    function fun1() {
        var a = 10;
        var b = 20;

        function getA() {
            return a;
        }

        function getB() {
            return b;
        }
        return { // return 后面可以跟任意数据类型当然也可以跟对象
            getA: getA,
            getB: getB
        }
    }
    var result = fun1();
    var a = result.getA();
    var b = result.getB();
    console.log(a, b);

    // 优化后：
    var modual = (function fun1() {
        var a = 10;
        var b = 20;

        function getA() {
            return a;
        }

        function getB() {
            return b;
        }
        return { // return 后面可以跟任意数据类型当然也可以跟对象
            getA: getA,
            getB: getB
        }
    })();

    var a = modual.getA();
    var b = modual.getB();
    console.log(a, b);
&lt;/script&gt;
</code></pre><hr>
<h3 id="2-闭包案例（面试时）（重点）定时输出0-9-延迟执行"><a href="#2-闭包案例（面试时）（重点）定时输出0-9-延迟执行" class="headerlink" title="2.闭包案例（面试时）（重点）定时输出0-9(延迟执行)"></a>2.闭包案例（面试时）（重点）定时输出0-9(延迟执行)</h3><pre><code>&lt;script&gt;
    // 案例：
    for (var i = 0; i &lt; 10; i++) {
        function fun() {
            return function (i) {
                console.log(i);
            }
        }
        setTimeout(fun(), 1000, i); //　延迟1秒后执行,只是执行一次
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="3-闭包-点击事件-（案例）"><a href="#3-闭包-点击事件-（案例）" class="headerlink" title="3.闭包+点击事件 （案例）"></a>3.闭包+点击事件 （案例）</h3><pre><code>&lt;!-- 解析：点击是异步，for已执行完打印是9，用()()匿名函数先执行 --&gt;

&lt;!-- 案例： --&gt;
&lt;div&gt;我是div1&lt;/div&gt;
&lt;div&gt;我是div2&lt;/div&gt;
&lt;div&gt;我是div3&lt;/div&gt;
&lt;div&gt;我是div4&lt;/div&gt;
&lt;div&gt;我是div5&lt;/div&gt;
&lt;div&gt;我是div6&lt;/div&gt;
&lt;div&gt;我是div7&lt;/div&gt;
&lt;div&gt;我是div8&lt;/div&gt;
&lt;div&gt;我是div9&lt;/div&gt;
&lt;div&gt;我是div10&lt;/div&gt;

&lt;script&gt;
    // 需求:点击每个div显示对应的div的顺序（闭包+点击事件）函数套函数
    // 获取元素
    var divs = document.getElementsByTagName(&quot;div&quot;); //　伪数组，集合
    for (var i = 0; i &lt; divs.length; i++) { //　闭包能缓存数据
        divs[i].onclick = (function (j) {
            return function () {
                console.log(&quot;我是第&quot; + (j + 1) + &quot;div&quot;);
            }
        })(i)
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="4-对象初始化"><a href="#4-对象初始化" class="headerlink" title="4.对象初始化"></a>4.对象初始化</h3><pre><code>&lt;script&gt;
    // 案例：
    var obj = {
        name: &#39;默认&#39;,
        age: &quot;默认&quot;,
        showName: function () {
            console.log(&quot;姓名:&quot; + this.name);
        },
        showAge: function () {
            console.log(&quot;年龄:&quot; + this.age);
        },
        // 初始化
        init: function (name, age) {
            this.name = name;
            this.age = age;
        }
    }

    obj.init(&quot;zs&quot;, 18);
    console.log(obj.name);
    console.log(obj.age);

    // 2. 如果这个对象只使用一次
    ({
        name: &#39;默认&#39;,
        age: &quot;默认&quot;,
        showName: function () {
            console.log(&quot;姓名:&quot; + this.name);
        },
        showAge: function () {
            console.log(&quot;年龄:&quot; + this.age);
        },
        // 初始化
        init: function (name, age) {
            this.name = name;
            this.age = age;
            this.showName();
            this.showAge();
        }
    }).init(&quot;zs&quot;, 18);
&lt;/script&gt;</code></pre><hr>
<h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><pre><code>&lt;script&gt;
    // 单例模式： 对于我们js来说就是单个实例， 某一个模块是一个独立的实例, 下划线定义的变量不可改变
    // 案例：
    function Person() {
        if (Person._instance) {
            console.log(&#39;之前已经创建过,直接返回之前创建的对象&#39;);
            return Person._instance;
        }
        Person._instance = this;
        console.log(&quot;创建了对象&quot;);
    }

    var per1 = new Person();
    var per2 = new Person();

    console.log(per1 === per2); // true
    console.log(per1 === per2); // true
&lt;/script&gt;</code></pre><hr>
<h3 id="4-发布订阅–观察者模式"><a href="#4-发布订阅–观察者模式" class="headerlink" title="4.发布订阅–观察者模式"></a>4.发布订阅–观察者模式</h3><pre><code>&lt;script&gt;
    // 案例：

    // 发布者
    var Rose = {
        eat: function () {
            console.log(&quot;我饿了，我想吃大餐&quot;);
            Jack.jack_eat(); // 有联系方式了
            Tom.tom_eat();
        }
    };

    // 观察者：订阅者
    var Jack = {
        jack_eat: function () {
            console.log(&quot;邀请，下课我们一起吃大龙虾---Jack&quot;);
        }
    };

    // 观察者，订阅者
    var Tom = {
        tom_eat: function () {
            console.log(&quot;女神，我们一起去吃麻辣烫啊，---TOM&quot;);
        }
    }

    Rose.eat();
&lt;/script&gt;</code></pre><hr>
<h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h3><pre><code>&lt;script&gt;
    function MakePhone() { // 1、相当于开了工厂

    }
    // 2、设置构造函数的原型对象(设置共同的属性或方法)--我们在原型上添加了方法
    MakePhone.prototype = {
        constructor: MakePhone, //修改指向
        logDes: function () {
            console.log(&quot;广告语:&quot; + this.des);
        },
        callPhone: function () {
            console.log(&quot;打电话的方法&quot;);
        }
    }
    // 3、生产车间(在构造函数上提供一个静态的工厂方法)
    MakePhone.factory = function (type) {
        // 设置子构造函数的原型对象，指向父构造函数的原型对象，为了拿到里面的方法
        // MakePhone[type]==表示的就是子构造函数
        MakePhone[type].prototype = MakePhone.prototype;
        // 实例化对象
        var obj = new MakePhone[type]();
        // 返回
        return obj;

    };

    // 4、建立合作关系(定制合作伙伴)，在构造函数身上提供静态方法
    MakePhone.iphone = function () {
        this.des = &quot;最贵的手机，最垃圾的系统!&quot;;
    };
    MakePhone.oppo = function () {
        this.des = &quot;充电两小时，通话五分钟&quot;;
    };
    MakePhone.xiaoMi = function () {
        this.des = &quot;小米可以吃，不像锤子&quot;;
    };

    // 实例化对象--获取产品--生成产品，调用工厂函数，传递参数
    var iphone1 = MakePhone.factory(&quot;iphone&quot;);
    var iphone2 = MakePhone.factory(&quot;iphone&quot;);
    var oppo1 = MakePhone.factory(&quot;oppo&quot;);

    // 调用属性和方法
    iphone1.callPhone();
    iphone2.callPhone();

    // 广告的方法
    iphone1.logDes();
    oppo1.logDes();
&lt;/script&gt;</code></pre><hr>
<h3 id="6-命名空间模式"><a href="#6-命名空间模式" class="headerlink" title="6.命名空间模式"></a>6.命名空间模式</h3><pre><code>&lt;script&gt;
    //约定:命名空间的名字一般是项目的名称或者简写,一般都是大写；现在几乎不用了，现在用的都是模块化开发。--了解    

    var MOMO = {};
    // 1、定义变量
    MOMO.a = 10;
    MOMO.b = 20;
    // 2、定义对象
    MOMO.obj = {
        name: &quot;zs&quot;,
        age: 18
    };

    // 3、函数
    MOMO.fun = function () {
        console.log(&quot;我是函数&quot;);
    }

    // 构造函数
    MOMO.Person = function () {
        this.name = &quot;命名空间模式&quot;;
    }
    console.log(new MOMO.Person());
&lt;/script&gt;</code></pre><hr>
<h3 id="7-单线程和多线程（同步异步）"><a href="#7-单线程和多线程（同步异步）" class="headerlink" title="7.单线程和多线程（同步异步）"></a>7.单线程和多线程（同步异步）</h3><pre><code>&lt;script&gt;
    // JS是单线程

    // 1. 同步
    // 单程
    var start = new Date();
    for (var i = 0; i &lt; 100000000; i++) {
        // 判断
        if (i === 99999999) {
            console.log(&quot;no&quot;);
        }
    }

    while (1 === 1) {

    }

    // 2. 异步：
    setTimeout(function () {
        console.log(1);
    }, 50);
    setTimeout(function () {
        console.log(2);
    }, 10);
    setTimeout(function () {
        console.log(3);
    }, 30);

    for (var i = 0; i &lt; 100000000; i++) {

    }
    console.log(6);
&lt;/script&gt;</code></pre><hr>
<h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><h3 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h3><pre><code>&lt;script&gt;
    // . 除了换行以外所有的任意的字符
    // \ 转义
    // \n 换行
    // \d 表示的是0-9之间任意的一个数字 0 1 2 3 4 5....
    // \D 表示除了0-9之外的任意的字符
    // \w 表示的是数字、字母和下划线
    // \W 除了数字、字母和下划线
    // \s 空白符 （是存在的但是眼睛看不到   空格 tab键）
    // \S 除了空白符之外的字符
&lt;/script&gt;</code></pre><hr>
<h3 id="2-限定符"><a href="#2-限定符" class="headerlink" title="2.限定符"></a>2.限定符</h3><pre><code>&lt;script&gt;
    // [.] 除了换行以外的字符
    // [a-z]
    // [0-9]
    // [A-Z]
    // [^0-9]
    // |
    // $ 以什么结束    

    // {5} 可以出现5次
    // {2,} 最少2次
    // {2,5} 最少2次，最多5次
&lt;/script&gt;</code></pre><hr>
<h3 id="3-表示的是范围"><a href="#3-表示的是范围" class="headerlink" title="3.[] 表示的是范围"></a>3.[] 表示的是范围</h3><pre><code>&lt;script&gt;
    // [0-9] 表示的是0-9之间任意的一个数字 
    // [a-z] 表示的是 小写字母a-z之间的任意的一个字符
    // [A-Z] 表示的是大写字母A-Z之间的任意的一个字符
    // [0-9a-z] 表示的是任意0-9之间的数组或者小写a-z任意的一个字符
    // [0-9a-zA-Z] 表示的是任意0-9之间的数,或者a-z之间的小写字母或者A-Z之间的任意的一个大写字母

    // []还有其他一个意义，去除元字符的本身的意义 [.]---表示的就是一个点

    // | 或者 
    // [0-9]|[a-z]|[A-Z]  举例 &quot;0123abcA&quot;--true

    // ()----分组--为了提高优先级  
    // [0-9]|([a-z])|[A-Z]--优先匹配 a-z之间的任意的一个字母然后在匹配数组和大写字母
    // ([0-9])([a-z])([A-Z])---三组

    // ^ 以什么开始 （还有一个意义取反）
    // ^[0-9][a-z] 必须以数字开头
    // [^0-9] 除了0-9以外的所有的字符
    // $ 以什么结束  [0-9][a-z]$ 必须要求以小写字母结束 &quot;123abc&quot; true
&lt;/script&gt;</code></pre><hr>
<h3 id="4-限定符"><a href="#4-限定符" class="headerlink" title="4.限定符"></a>4.限定符</h3><pre><code>&lt;script&gt;
    // {} 也是表示范围
    // {5} 表示连续出现了5次
    // {2,} 表示最少出现2次
    // {2,6} 表示出现了2次到6次

    // ？ ---表示的是出现了0次或者1次
    // * ---表示出现了0次或者多次
    // + ---表示出现了1次或者多次
&lt;/script&gt;</code></pre><hr>
<h3 id="5-身份证号码验证"><a href="#5-身份证号码验证" class="headerlink" title="5.身份证号码验证"></a>5.身份证号码验证</h3><pre><code>    1.([1-9][0-9]{14})|([1-9][0-9]{16}[0-9xX])---15位或者18位的身份证号码

    2.优化 ？出现了0次或者1次
    ([1-9][0-9]{14})([0-9]{2}[0-9xX])?</code></pre><hr>
<h3 id="6-手机号码验证-的正则表达式"><a href="#6-手机号码验证-的正则表达式" class="headerlink" title="6.手机号码验证 的正则表达式"></a>6.手机号码验证 的正则表达式</h3><pre><code>&lt;script&gt;
    案例:
    1、手机号码的正则表达式 直接复制笔记上的手机号码
    130 131 132 133 134 135 136 137 138 139
    143 147
    150 151 152 153 154 155 156 157 158 159
    170 171 173 176 177
    180 181 182 183 184 185 186 187 188 189

    1. ([1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})

    2. [1]\d{10}
&lt;/script&gt;</code></pre><hr>
<h3 id="7-邮箱的正则"><a href="#7-邮箱的正则" class="headerlink" title="7.邮箱的正则"></a>7.邮箱的正则</h3><pre><code>案例:
    d2113_3.-fd@wolfcode.com.cn
    [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}
    [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.]com|cn+){1,2}</code></pre><hr>
<h3 id="8-正则表达式的创建"><a href="#8-正则表达式的创建" class="headerlink" title="8.正则表达式的创建"></a>8.正则表达式的创建</h3><pre><code>&lt;script&gt;
    // 正则里面有一个方法， 验证正则是否匹配这个字符的 test, 如果匹配成功返回true否则返回flase
    // 1. 通过构造函数方式创建正则

    var reg = new RegExp(/\d{5}/);
    // 定义一个字符串
    var str = &quot;我的电话号码是10086&quot;;
    // 正则里面有一个方法，验证正则是否匹配这个字符的 test,如果匹配成功返回true否则返回flase
    var flag = reg.test(str);
    console.log(flag);

    // 2. 字面量的方式创建

    var reg = /\d{1,5}/;
    var flag1 = reg.test(&quot;我们的幸运数字是888&quot;);
    console.log(flag1);
&lt;/script&gt;</code></pre><hr>
<h3 id="9-正则表达式案例"><a href="#9-正则表达式案例" class="headerlink" title="9.正则表达式案例"></a>9.正则表达式案例</h3><pre><code>&lt;script&gt;
    console.log(/./.test(&quot;除了回车换行以为的任意字符&quot;)); // true
    console.log(/.*/.test(&quot;0个到多个&quot;)); // true
    console.log(/.+/.test(&quot;1个到多个&quot;)); // true
    console.log(/.?/.test(&quot;哈呵&quot;)); // true
    console.log(/[0-9]/.test(&quot;9527&quot;)); // true
    console.log(/[a-z]/.test(&quot;what&quot;)); // true
    console.log(/[A-Z]/.test(&quot;Are&quot;)); // true
    console.log(/[a-zA-Z]/.test(&quot;干啥子&quot;)); // false
    console.log(/[0-9a-zA-Z]/.test(&quot;9ebg&quot;)); // true
    console.log(/b|(ara)/.test(&quot;abra&quot;)); // true
    console.log(/[a-z]{2,3}/.test(&quot;arfsf&quot;)); // true
    console.log(&quot;=============================&gt;&quot;);
    console.log(/\d/.test(&quot;998&quot;)); // true
    console.log(/\d*/.test(&quot;998&quot;)); // true
    console.log(/\d+/.test(&quot;998&quot;)); // true
    console.log(/\d{0,}/.test(&quot;998&quot;)); // true
    console.log(/\d{2,3}/.test(&quot;998&quot;)); // true
    console.log(/\D/.test(&quot;eat&quot;)); // true
    console.log(/\s/.test(&quot;  &quot;)); // true
    console.log(/\S/.test(&quot;嘎嘎&quot;)); // true
    console.log(/\w/.test(&quot;_&quot;)); // true
    console.log(/\W/.test(&quot;_&quot;)); // false
&lt;/script&gt;</code></pre><hr>
<h3 id="10-验证密码强度"><a href="#10-验证密码强度" class="headerlink" title="10.验证密码强度"></a>10.验证密码强度</h3><pre><code>&lt;!-- 案例: --&gt;

&lt;style&gt;
    #dv {
        width: 300px;
        height: 200px;
        position: absolute;
        left: 300px;
        top: 100px;
    }

    .strengthLv0 {
        height: 6px;
        width: 120px;
        border: 1px solid #ccc;
        padding: 2px;
    }

    .strengthLv1 {
        background: red;
        height: 6px;
        width: 40px;
        border: 1px solid #ccc;
        padding: 2px;
    }

    .strengthLv2 {
        background: green;
        height: 6px;
        width: 80px;
        border: 1px solid #ccc;
        padding: 2px;
    }

    .strengthLv3 {
        background: blue;
        height: 6px;
        width: 120px;
        border: 1px solid #ccc;
        padding: 2px;
    }
&lt;/style&gt;

&lt;div id=&quot;dv&quot;&gt;
    &lt;label for=&quot;pwd&quot;&gt;密码&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;pwd&quot; maxlength=&quot;16&quot;&gt;
    &lt;!--课外话题--&gt;
    &lt;div&gt;
        &lt;em&gt;密码强度：&lt;/em&gt;
        &lt;em id=&quot;strength&quot;&gt;&lt;/em&gt;
        &lt;div id=&quot;strengthLevel&quot; class=&quot;strengthLv0&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    // document.getElementById(&quot;pwd&quot;)
    my$(&quot;pwd&quot;).onkeyup = function () {
        // 获取文本框里面内容，根据你输入的不同的级别来显示不同的颜色
        // 判断密码的长度
        if (this.value.length &gt;= 6) {
            // 调用级别函数
            var lvl = getLvl(this.value);
            // 判断
            if (lvl == 1) {
                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv1&quot;;
            } else if (lvl == 2) {
                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv2&quot;;
            } else if (lvl == 3) {
                my$(&quot;strengthLevel&quot;).className = &quot;strengthLv3&quot;;
            }
        } else {
            my$(&quot;strengthLevel&quot;).className = &quot;strengthLv0&quot;;
        }
    }

    // 封装函数判断级别,给我密码，我来显示级别
    function getLvl(pwd) { // 参数 pwd
        // 默认的是0 级别
        var lvl = 0; //默认值
        // 密码中是否有数字
        if (/[0-9]/.test(pwd)) {
            lvl++; // 此时表示1级
        }
        // 两两组合
        if (/[a-zA-Z]/.test(pwd)) {
            lvl++; // 表示2级
        }
        // 三个组合
        if (/[^0-9a-zA-Z_]/.test(pwd)) {
            lvl++; // 表示3级
        }

        return lvl; // 1 2 3
    }
&lt;/script&gt;</code></pre><hr>
<h3 id="11-表单验证案例"><a href="#11-表单验证案例" class="headerlink" title="11.表单验证案例"></a>11.表单验证案例</h3><pre><code>&lt;style type=&quot;text/css&quot;&gt;
    * {
        margin: 0px;
        padding: 0px;
    }

    body {
        background: #ccc;
    }

    label,
    input,
    span {
        display: inline-block;
    }

    label {
        width: 40px;

    }

    span {
        color: red;
        margin-left: 40px;
        width: 100%;
    }

    .container {
        margin: 100px auto;
        width: 280px;
        padding: 50px;
        line-height: 40px;
        border: 1px solid #999;
        background: #efefef;
    }
&lt;/style&gt;

&lt;div class=&quot;container&quot; id&gt;
    &lt;label for=&quot;qq&quot;&gt;Q Q:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;qq&quot;&gt;
    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;
    &lt;label for=&quot;phone&quot;&gt;手机:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;phone&quot;&gt;
    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;
    &lt;label for=&quot;email&quot;&gt;邮箱:&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;email&quot;&gt;
    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;
    &lt;label for=&quot;telephone&quot;&gt;座机:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;telephone&quot;&gt;
    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;
    &lt;label for=&quot;name&quot;&gt;姓名:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;
    &lt;br /&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;
&lt;/div&gt;

&lt;script&gt;
    function getId(id) {
        return document.getElementById(id);
    };

    function getHint(eleId, reg, str) {
        eleId.onblur = function () { // 失去焦点事件
            if (reg.test(this.value)) {
                this.nextElementSibling.nextElementSibling.innerText = &#39;正确&#39;;
                this.nextElementSibling.nextElementSibling.style.color = &#39;green&#39;;
            } else {
                this.nextElementSibling.nextElementSibling.innerText = str;
                this.nextElementSibling.nextElementSibling.style.color = &#39;red&#39;;
            }
        }
    };

    getHint(getId(&#39;qq&#39;), /^[1-9]\d{5,10}$/, &quot;qq号码要求1开头，纯数字6到11位&quot;);
    getHint(getId(&#39;phone&#39;), /^[1-9]\d{10}$/, &quot;手机号要求1开头，纯数字11位&quot;);
    getHint(getId(&#39;email&#39;), /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/, &quot;输入有误,按邮箱规则输入&quot;);
    getHint(getId(&#39;telephone&#39;), /^\d{3,4}[-]\d{7,8}$/, &quot;区号要3-4位,号码要7到8位&quot;);
    getHint(getId(&#39;name&#39;), /^[\u4e00-\u9fa5]{2,5}$/, &quot;要纯中文，字符长度2-5&quot;);
&lt;/script&gt;</code></pre><hr>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">小茗</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com/2020/01/13/javascript-jia-shen-xue-xi-bi-ji/">http://yoursite.com/2020/01/13/javascript-jia-shen-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">小茗</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JavaScript/">
                                    <span class="chip bg-color">JavaScript</span>
                                </a>
                            
                                <a href="/tags/ES6/">
                                    <span class="chip bg-color">ES6</span>
                                </a>
                            
                                <a href="/tags/WebAPI/">
                                    <span class="chip bg-color">WebAPI</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'n5vy9gQnUaBpvgllfBaEfDeW-gzGzoHsz',
        appKey: '3F1LLlv92dcIFqVqlvqcVdLX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: '请输入您的评论'
    });
</script>

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2020/01/25/jquery-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        <img src="https://www.xmubshw.com/clients/hexo/JQueryimg.jpg" class="responsive-img" alt="JQuery学习笔记">
                        
                        <span class="card-title">JQuery学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JQuery学习笔记
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-01-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JQuery/" class="post-category">
                                    JQuery
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JQuery/">
                        <span class="chip bg-color">JQuery</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/12/25/javascriptes6-yu-fa-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        <img src="https://www.xmubshw.com/clients/hexo/JavaScriptES6img.jpg" class="responsive-img" alt="JavaScriptES6语法学习笔记">
                        
                        <span class="card-title">JavaScriptES6语法学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JavaScriptES6语法学习笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-12-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaScript/" class="post-category">
                                    JavaScript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/ES6/">
                        <span class="chip bg-color">ES6</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">小茗</a>
            |&nbsp;Powered by&nbsp;<a href="https://www.xmubshw.com" target="_blank">小茗Ub生活网</a>
            |&nbsp;Theme&nbsp;<a href="https://xdhxm.xmubshw.com" target="_blank">小茗'Blog</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">57.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://www.beian.gov.cn/apply/selectBeiAn?id=562202" target="_blank">陇ICP备18002661号-2</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/1411v6" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:908265504@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=908265504" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 908265504" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/1698701827" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/1698701827" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "c4acc70b"
        });
        daovoice('update');
    </script>
    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
